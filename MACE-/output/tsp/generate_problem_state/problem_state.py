# This file is generated by generate_problem_state.py.

from src.problems.tsp.components import Solution


import numpy as np

def get_instance_problem_state(instance_data: dict) -> dict:
    """Extract instance problem state from instance data.

    Args:
        instance_data (dict): The dictionary contains the instance data.

    Returns:
        dict: The dictionary contains the instance problem state with:
            - num_cities (int): The total number of cities/nodes in the instance.
            - min_distance (float): The minimum pairwise distance between distinct nodes.
            - max_distance (float): The maximum pairwise distance between distinct nodes.
            - avg_distance (float): The average pairwise distance between distinct nodes.
            - std_distance (float): The standard deviation of pairwise distances between distinct nodes.
            - aspect_ratio (float or None): The aspect ratio of the city positions if coordinates were available; set to None if not computable from distance matrix alone.
    """
    # Extract node_num and distance_matrix without modifying the input
    node_num = instance_data['node_num']
    distance_matrix = instance_data['distance_matrix']
    
    # Ensure distance_matrix is a NumPy array for efficient computations
    if not isinstance(distance_matrix, np.ndarray):
        raise ValueError("distance_matrix must be a numpy.ndarray")
    
    # Create a mask to exclude the diagonal (self-distances, assumed to be 0)
    mask = np.ones_like(distance_matrix, dtype=bool)
    np.fill_diagonal(mask, False)
    
    # Extract off-diagonal elements for distance calculations
    off_diagonal_distances = distance_matrix[mask]
    
    # Compute num_cities directly from node_num
    num_cities = node_num
    
    # Compute min_distance: minimum off-diagonal distance
    min_distance = np.min(off_diagonal_distances) if len(off_diagonal_distances) > 0 else 0.0
    
    # Compute max_distance: maximum off-diagonal distance
    max_distance = np.max(off_diagonal_distances) if len(off_diagonal_distances) > 0 else 0.0
    
    # Compute avg_distance: mean of off-diagonal distances
    avg_distance = np.mean(off_diagonal_distances) if len(off_diagonal_distances) > 0 else 0.0
    
    # Compute std_distance: standard deviation of off-diagonal distances
    std_distance = np.std(off_diagonal_distances) if len(off_diagonal_distances) > 0 else 0.0
    
    # For aspect_ratio: This requires city coordinates (e.g., x, y positions) to compute the ratio of bounding box dimensions.
    # Since only distance_matrix is provided, it cannot be computed accurately from distances alone without additional assumptions.
    # Set to None; in a full implementation, coordinates should be added to instance_data if needed.
    aspect_ratio = None
    
    # Return the dictionary of problem states
    return {
        'num_cities': num_cities,
        'min_distance': min_distance,
        'max_distance': max_distance,
        'avg_distance': avg_distance,
        'std_distance': std_distance,
        'aspect_ratio': aspect_ratio
    }

from src.problems.tsp.components import Solution
import numpy as np

def get_solution_problem_state(instance_data: dict, solution: Solution) -> dict:
    """Extract solution problem state from instance data and partial solution.

    Args:
        instance_data (dict): The dictionary contains the instance data with 'node_num' and 'distance_matrix'.
        solution (Solution): The target solution instance representing the partial tour.

    Returns:
        dict: The dictionary contains the solution problem state with:
            - num_visited (int): The number of distinct cities visited in the partial tour.
            - current_tour_length (float): The total length of the partial tour (sum of edge distances).
            - num_unvisited (int): The number of cities remaining unvisited.
            - avg_visited_edge_length (float): The average length of edges in the partial tour.
            - min_unvisited_to_visited (float): The minimum distance from any unvisited city to the tour endpoints.
            - estimated_lower_bound (float): An approximation of the lower bound for the total tour length, including partial tour, MST on unvisited, and connection estimates.
            - progress_ratio (float): The ratio of visited cities to total cities (0 to 1).
    """
    # Extract data without modifying inputs
    node_num = instance_data['node_num']
    distance_matrix = instance_data['distance_matrix']
    tour = solution.tour  # List of visited node indices, assumed distinct and in order
    
    # Ensure distance_matrix is NumPy for efficiency
    if not isinstance(distance_matrix, np.ndarray):
        raise ValueError("distance_matrix must be a numpy.ndarray")
    
    # Compute num_visited: length of tour (assume distinct nodes)
    num_visited = len(tour)
    
    # Compute set of visited nodes for quick lookup
    visited_set = set(tour)
    
    # Compute num_unvisited
    num_unvisited = node_num - num_visited
    
    # Compute progress_ratio
    progress_ratio = num_visited / node_num if node_num > 0 else 0.0
    
    # Compute current_tour_length: sum of consecutive distances in partial tour
    current_tour_length = 0.0
    if num_visited > 1:
        for i in range(num_visited - 1):
            current_tour_length += distance_matrix[tour[i], tour[i + 1]]
    
    # Compute avg_visited_edge_length: average edge in partial tour
    avg_visited_edge_length = current_tour_length / max(num_visited - 1, 1)  # Avoid div by zero
    
    # Compute min_unvisited_to_visited: min dist from unvisited to endpoints (tour[0] or tour[-1])
    min_unvisited_to_visited = float('inf')
    if num_visited > 0 and num_unvisited > 0:
        start_node = tour[0]
        end_node = tour[-1]
        unvisited = [i for i in range(node_num) if i not in visited_set]
        for u in unvisited:
            min_to_endpoints = min(distance_matrix[u, start_node], distance_matrix[u, end_node])
            min_unvisited_to_visited = min(min_unvisited_to_visited, min_to_endpoints)
    elif num_unvisited == 0:
        min_unvisited_to_visited = 0.0  # No unvisited, no min needed
    else:
        min_unvisited_to_visited = 0.0  # Empty tour, default to 0
    
    # Helper function for Prim's algorithm to compute MST cost on unvisited subgraph
    def mst_cost(unvisited_nodes, dist_matrix):
        """Compute the sum of edge weights in the MST of the subgraph induced by unvisited_nodes using Prim's algorithm.
        
        Args:
            unvisited_nodes (list[int]): List of node indices.
            dist_matrix (np.ndarray): Distance matrix.
        
        Returns:
            float: Total MST cost; 0 if fewer than 2 nodes.
        """
        if len(unvisited_nodes) < 2:
            return 0.0
        
        n = len(unvisited_nodes)
        # Map unvisited indices to 0 to n-1 for simplicity
        node_map = {unvisited_nodes[i]: i for i in range(n)}
        inf = float('inf')
        
        # Initialize Prim's: key is min dist to MST, parent for tree
        key = [inf] * n
        parent = [-1] * n
        in_mst = [False] * n
        
        # Start from node 0
        key[0] = 0
        parent[0] = -1
        
        for _ in range(n):
            # Find node with min key not in MST
            u = -1
            min_key = inf
            for i in range(n):
                if not in_mst[i] and key[i] < min_key:
                    min_key = key[i]
                    u = i
            if u == -1:
                break  # Disconnected, but assume complete graph
            
            in_mst[u] = True
            
            # Update adjacent
            orig_u = unvisited_nodes[u]
            for v in range(n):
                if not in_mst[v]:
                    orig_v = unvisited_nodes[v]
                    weight = dist_matrix[orig_u, orig_v]
                    if weight < key[v]:
                        key[v] = weight
                        parent[v] = u
        
        # Sum the key values (MST edges)
        mst_sum = sum(key)
        return mst_sum
    
    # Compute estimated_lower_bound: partial length + MST(unvisited) + 2 * min_unvisited_to_visited (approx for connections and closing)
    # This is a rough lower bound; for complete tour, add closing edge if needed, but here it's partial-focused
    unvisited = [i for i in range(node_num) if i not in visited_set]
    mst_unvisited = mst_cost(unvisited, distance_matrix)
    connection_estimate = 2 * min_unvisited_to_visited if num_unvisited > 0 else 0.0
    # If complete, add closing edge to bound
    closing_edge = 0.0
    if num_unvisited == 0 and num_visited > 1:
        closing_edge = distance_matrix[tour[-1], tour[0]]
    estimated_lower_bound = current_tour_length + mst_unvisited + connection_estimate + closing_edge
    
    # Return the dictionary of solution states
    return {
        'num_visited': num_visited,
        'current_tour_length': current_tour_length,
        'num_unvisited': num_unvisited,
        'avg_visited_edge_length': avg_visited_edge_length,
        'min_unvisited_to_visited': min_unvisited_to_visited,
        'estimated_lower_bound': estimated_lower_bound,
        'progress_ratio': progress_ratio
    }

def get_observation_problem_state(solution_problem_state: dict) -> dict:
    """Extract core problem state as observation.

    Args:
        solution_problem_state (dict): The dictionary contains the solution problem state.

    Returns:
        dict: The dictionary contains the core problem state with:
            - num_visited (int): The number of distinct cities visited in the partial tour.
            - current_tour_length (float): The total length of the partial tour (sum of edge distances).
            - progress_ratio (float): The ratio of visited cities to total cities (0 to 1).
            - min_unvisited_to_visited (float): The minimum distance from any unvisited city to the tour endpoints.
            - estimated_lower_bound (float): An approximation of the lower bound for the total tour length.
    """
    # Extract the selected core states directly from the input dictionary without any modifications
    # This ensures the observation is a filtered view for tracking changes
    observation = {
        'num_visited': solution_problem_state['num_visited'],
        'current_tour_length': solution_problem_state['current_tour_length'],
        'progress_ratio': solution_problem_state['progress_ratio'],
        'min_unvisited_to_visited': solution_problem_state['min_unvisited_to_visited'],
        'estimated_lower_bound': solution_problem_state['estimated_lower_bound']
    }
    
    # Return the filtered dictionary
    return observation