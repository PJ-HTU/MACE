[
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "I am working on Hyper-heuristics for Combinatorial Operation (CO) problem.\n\nCurrently, I am working on cvrp problem:\nCapacitated Vehicle Routing Problem (CVRP) is an optimization challenge focused on determining the most efficient routes for a fleet of vehicles to deliver goods to various locations, considering vehicle capacity constraints.\n\nTo support different heuristic algorithms, I build the Solution and Operator framework.\nThe Solution is designed as:\nclass Solution:\n    \"\"\"The solution of CVRP.\nA list of lists where each sublist represents a vehicle's route.\nEach sublist contains integers representing the nodes (customers) visited by the vehicle in the order of visitation.\nThe routes are sorted by vehicle identifier and the nodes in the list sorted by visited order.\"\"\"\n    def __init__(self, routes: list[list[int]], depot: int):\n        self.routes = routes\n        self.depot = depot\nOperator servers as a mechanism to modify solution, which enables the application of heuristic algorithms.\u00a0\nTo support heuristic algorithm, we have build the following operators:\nclass AppendOperator(BaseOperator):\n    \"\"\"Append a node at the end of the specified vehicle's route.\"\"\"\n    def __init__(self, vehicle_id: int, node: int):\n        self.vehicle_id = vehicle_id\n        self.node = node\n    def run(self, solution: Solution) -> Solution:\n        new_routes = [route[:] for route in solution.routes]\n        new_routes[self.vehicle_id].append(self.node)\n        return Solution(new_routes, solution.depot)\nclass InsertOperator(BaseOperator):\n    \"\"\"Insert a node at a specified position within the route of a specified vehicle.\"\"\"\n    def __init__(self, vehicle_id: int, node: int, position: int):\n        self.vehicle_id = vehicle_id\n        self.node = node\n        self.position = position\n    def run(self, solution: Solution) -> Solution:\n        new_routes = [route[:] for route in solution.routes]\n        new_routes[self.vehicle_id].insert(self.position, self.node)\n        return Solution(new_routes, solution.depot)\n\nIn pursuit of augmenting our heuristic algorithmic suite, we require the following standardized heuristic function signature:\ndef heuristic(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[TargetOperatorType, dict]:\nThe inputs are:\nproblem_state (dict): A dictionary containing the problem state information, organized into five categories of keys:\n1. Input Data:\n    - node_num (int): The total number of nodes in the problem.\n    - distance_matrix (numpy.ndarray): A 2D array representing the distances between nodes.\n    - vehicle_num (int): The total number of vehicles.\n    - capacity (int): The capacity for each vehicle and all vehicles share the same value.\n    - depot (int): The index for depot node.\n    - demands (numpy.ndarray): The demand of each node.\n2. Current Solution:\n    - current_solution (Solution): Current solution instance.\n    - total_current_cost (int): The total cost of the current solution for all vehicles.\n3. Helper Functions (these Functions may help you to generation the following heuristic):\n    - get_problem_state (callable): def get_problem_state(solution: Solution) -> dict: The function to get the complete problem state for given solution without modifying it. Returns a dictionary containing 'total_scheduling_cost' and other state information.\n    - validation_solution (callable): def validation_solution(solution: Solution = None) -> bool: The function to check whether the solution is valid according to all mathematical model constraints. If solution is None, checks current solution. Returns True if valid, False otherwise.\n    - get_unvisited_customers (callable): def get_unvisited_customers(solution: Solution = None) -> list[int]: Get list of customer node IDs that have not been visited in any route. Excludes depot from the result. If solution is None, uses current solution. Returns list of integers representing unvisited customer IDs.\n    - get_route_load (callable): def get_route_load(vehicle_id: int, solution: Solution = None) -> float: Calculate the total demand of all customers in a specific vehicle's route. Excludes depot demand from calculation (only counts customer nodes). If solution is None, uses current solution. Returns float representing the total load of the route.\n    - can_add_to_route (callable): def can_add_to_route(vehicle_id: int, customer: int, solution: Solution = None) -> bool: Check if a customer can be added to a vehicle's route without violating capacity constraint. Considers current route load plus customer demand versus vehicle capacity. If solution is None, uses current solution. Returns True if the customer can be added without exceeding capacity, False otherwise.\n4. Instance Statistics (these Instance Statistics may help you to generation the following heuristic):\n    - num_customers (int): The number of customer nodes excluding the depot.\n    - total_demand (float): The sum of demands for all customer nodes.\n    - demand_cv (float): The coefficient of variation of customer demands (std/mean).\n    - avg_depot_distance (float): The average distance from depot to all customers.\n    - spatial_clustering (float): The average of minimum distances between each customer and its nearest neighbor customer.\n    - capacity_to_total_demand_ratio (float): The ratio of total vehicle capacity (capacity * vehicle_num) to total demand.\n5. Current Solution Statistics (these Solution Statistics may help you to generation the following heuristic):\n    - served_customers_ratio (float): Ratio of served customers to total customers.\n    - total_traveled_distance (float): Total distance traveled in all routes (including partial).\n    - vehicles_used (int): Number of non-empty routes (active or complete).\n    - avg_load_utilization (float): Average load utilization across used routes.\n    - remaining_demand_ratio (float): Ratio of remaining demand to total customer demand.\n    - unserved_spatial_clustering (float): Average minimum distance between unserved customers.\n    - num_unserved_customers (int): Number of unserved customers.\nalgorithm_data(dict): Algorithm data contains the data that necessary for some algorithms.\nOther hyper-parameters in kwargs.\nThe outputs includes the operator that must be an instance of a predefined target operator type and updated algorithm dict, which contains new information for future work for both this or other algorithm.\n\nPlease consider is cvrp a combinatorial operation problem and can be solved by heuristics?\nIf you think this problem is not a combinatorial operation problem or the solution, operator, data are incorrect, response ***is_cop:no*** to me, or response ***is_cop:yes***.\n\nThe response format is very important. For better communication, please respond to me in this format:\n***is_cop:yes/no***\nEnsure there is no other content inside the ***, and analysis outside *** is welcome.\nIf you have no information to provide, simply respond with ***None***."
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***is_cop:yes***\n\nCVRP is indeed a classic combinatorial optimization (CO) problem, as it involves discrete decision-making over a finite set of possible routes and assignments while optimizing objectives like total distance or cost, subject to constraints like vehicle capacity and customer demands. It's NP-hard, making exact solutions impractical for large instances, so heuristics (e.g., local search, genetic algorithms) and meta-heuristics (e.g., tabu search, simulated annealing) are standard approaches. Your Solution class and operators (AppendOperator, InsertOperator) align well with representing and perturbing CVRP solutions, enabling hyper-heuristic frameworks to select or generate improvements. The provided problem_state dict structure, with categories for input data, current solution, helpers, and statistics, supports effective heuristic design by providing necessary context for operator selection. If you're building hyper-heuristics, consider incorporating operators like relocate, exchange, or 2-opt for richer neighborhood exploration in CVRP."
            }
        ]
    },
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "I need your help to design different 5 basic heuristics for the cvrp problem.\n\n## Heuristic Requirements:\n1. **Constructive Nature**: Each heuristic must be constructive (or constructive followed by improvement), and build solutions step-by-step from scratch.\n\n2. **Diversity**: The 5 heuristics should represent different strategies to ensure diversity in solution approaches.\n\nThe problem will work on following data.\nPlease try to understand the data and generate based on them, especially setting the default value for hyper-parameters:\nAll data is possible\n\nThe response format is very important. For better communication, please respond to me in this format:\n***heuristic:\nheuristic_name: only text description\nheuristic_name: only text description\n....\n***\nEnsure there is no other content (including blank lines) inside the ***, and analysis outside *** is welcome.\nIf you have no information to provide, simply respond with ***None***."
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***heuristic:\nNearest Neighbor Heuristic: Start with empty routes for each vehicle. For each vehicle in sequence, repeatedly append the nearest unvisited customer (by distance from the last node in the route) that fits the remaining capacity until no more can be added or all customers are served. Default: Use Euclidean distance if available, or matrix distance; max iterations per vehicle = node_num.\nCheapest Insertion Heuristic: Initialize with a single route per customer-depot pair. Iteratively select the unserved customer with the lowest insertion cost (increase in total route distance) and insert it into the feasible route (via InsertOperator) where the added cost is minimal, respecting capacity. Default: Insertion cost = distance savings; regret threshold = 0.1 * avg_depot_distance; run until all served.\nClarke-Wright Savings Heuristic: Begin with individual depot-customer-depot routes for all customers. Compute savings for merging adjacent routes (s_ikj = dist(i,k) + dist(j,k) - dist(i,j) where i,j are route ends, k merge point). Greedily merge routes with highest savings using InsertOperator to append segments, ensuring capacity. Default: Parallel version (merge independently); sort savings descending; stop when no feasible merges.\nSweep Heuristic: Order customers by angular position around the depot (polar angle). Start empty routes. Sweep clockwise, appending consecutive customers in angular order to the current vehicle if capacity allows (using AppendOperator); open a new vehicle when capacity exceeded. Default: Angle from positive x-axis; depot at (0,0) if coordinates available, else use distance_matrix approximation; one sweep per vehicle until all served.\nRandom Greedy Heuristic: Initialize empty routes. For each vehicle, randomly select unvisited customers that fit capacity and append them in random order (AppendOperator), preferring closer ones with probability proportional to inverse distance. Repeat until all customers assigned or vehicles exhausted. Default: Probability weight = 1 / (1 + distance); random seed from algorithm_data if provided; ensure at least 50% greedy selection ratio.\n***\n\nThese heuristics are designed to be constructive, building solutions incrementally using the provided operators (primarily AppendOperator for sequential addition, with InsertOperator for refinements in insertion-based ones). They leverage the problem_state dict: input data for distances/demands/capacity, helper functions like get_unvisited_customers, can_add_to_route, and validation_solution for feasibility checks, and statistics like spatial_clustering or remaining_demand_ratio to bias selections (e.g., in Random Greedy). Diversity comes from strategies: greedy proximity (Nearest), cost-aware insertion (Cheapest), merge-based (Savings), geometric ordering (Sweep), and stochastic (Random). For implementation, the heuristic function would return an operator instance (e.g., AppendOperator(vehicle_id, node)) and updated algorithm_data (e.g., {'partial_solution': new_solution, 'used_vehicles': count}). Post-construction, a simple 2-opt improvement could be added via additional operators if allowed, but kept minimal here. Hyper-parameters like thresholds are set with sensible defaults based on instance stats (e.g., avg_depot_distance for scaling). If coordinates are in problem_state (not explicitly listed but inferable from distance_matrix), use them for Sweep; otherwise, approximate angles via distances."
            }
        ]
    },
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "Based on previous discuss, we get the heuristic Nearest Neighbor Heuristic:\n Start with empty routes for each vehicle. For each vehicle in sequence, repeatedly append the nearest unvisited customer (by distance from the last node in the route) that fits the remaining capacity until no more can be added or all customers are served. Default: Use Euclidean distance if available, or matrix distance; max iterations per vehicle = node_num..\n\nNow please implement it in python function nearest_neighbor_heuristic_30c1.\n\nTo implement this heuristic function in python, please note:\n1. We can assume that Solution and all Operators are imported.\n2. The operator type must be defined previously, do not create a new one in your code.\n3. Never modify the data in problem_state.\n4. All hyper parameters in kwargs should be set a default value.\n5. Any reasonable partial solution may be used as input, such as an empty solution.\n6. Comments in the code are very important. They must clearly explain which hyper-parameters are required by the algorithm (i.e., the parameters in **kwargs), how the algorithm proceeds, and under what circumstances it will not return any operator or will return an empty operator. We hope that people can understand the principles and workflow of the algorithm clearly just by reading the comments, without needing to look at the code.\n7. The name of function must be nearest_neighbor_heuristic_30c1. The TargetOperatorType should be replaced by real returned operator type.\n8. No any omissions or placeholders, I'm just going to use the code.\n9. For the algorithm to update the algorithm_data, do not modify directly \"algorithm_data[\"abc\"] = 123\", we should return operator, {\"abc\": 123}.For algorithm that do not update them, just return operator, {}\n10. For the circumstances that algorithm return empty operator, please return None, {}.\n11. Do not forget to check whether the content is empty when calculating the min/max/average/std/..., such as when using min([distance[node][other] for other in nodes if other != node]).\n12. Make the result must be valid.\n13. Do not forget the input problem_state:\nproblem_state (dict): A dictionary containing the problem state information, organized into five categories of keys:\n1. Input Data:\n    - node_num (int): The total number of nodes in the problem.\n    - distance_matrix (numpy.ndarray): A 2D array representing the distances between nodes.\n    - vehicle_num (int): The total number of vehicles.\n    - capacity (int): The capacity for each vehicle and all vehicles share the same value.\n    - depot (int): The index for depot node.\n    - demands (numpy.ndarray): The demand of each node.\n2. Current Solution:\n    - current_solution (Solution): Current solution instance.\n    - total_current_cost (int): The total cost of the current solution for all vehicles.\n3. Helper Functions (these Functions may help you to generation the following heuristic):\n    - get_problem_state (callable): def get_problem_state(solution: Solution) -> dict: The function to get the complete problem state for given solution without modifying it. Returns a dictionary containing 'total_scheduling_cost' and other state information.\n    - validation_solution (callable): def validation_solution(solution: Solution = None) -> bool: The function to check whether the solution is valid according to all mathematical model constraints. If solution is None, checks current solution. Returns True if valid, False otherwise.\n    - get_unvisited_customers (callable): def get_unvisited_customers(solution: Solution = None) -> list[int]: Get list of customer node IDs that have not been visited in any route. Excludes depot from the result. If solution is None, uses current solution. Returns list of integers representing unvisited customer IDs.\n    - get_route_load (callable): def get_route_load(vehicle_id: int, solution: Solution = None) -> float: Calculate the total demand of all customers in a specific vehicle's route. Excludes depot demand from calculation (only counts customer nodes). If solution is None, uses current solution. Returns float representing the total load of the route.\n    - can_add_to_route (callable): def can_add_to_route(vehicle_id: int, customer: int, solution: Solution = None) -> bool: Check if a customer can be added to a vehicle's route without violating capacity constraint. Considers current route load plus customer demand versus vehicle capacity. If solution is None, uses current solution. Returns True if the customer can be added without exceeding capacity, False otherwise.\n4. Instance Statistics (these Instance Statistics may help you to generation the following heuristic):\n    - num_customers (int): The number of customer nodes excluding the depot.\n    - total_demand (float): The sum of demands for all customer nodes.\n    - demand_cv (float): The coefficient of variation of customer demands (std/mean).\n    - avg_depot_distance (float): The average distance from depot to all customers.\n    - spatial_clustering (float): The average of minimum distances between each customer and its nearest neighbor customer.\n    - capacity_to_total_demand_ratio (float): The ratio of total vehicle capacity (capacity * vehicle_num) to total demand.\n5. Current Solution Statistics (these Solution Statistics may help you to generation the following heuristic):\n    - served_customers_ratio (float): Ratio of served customers to total customers.\n    - total_traveled_distance (float): Total distance traveled in all routes (including partial).\n    - vehicles_used (int): Number of non-empty routes (active or complete).\n    - avg_load_utilization (float): Average load utilization across used routes.\n    - remaining_demand_ratio (float): Ratio of remaining demand to total customer demand.\n    - unserved_spatial_clustering (float): Average minimum distance between unserved customers.\n    - num_unserved_customers (int): Number of unserved customers.\n\nFor cvrp problem, take about following:\nEnsure your heuristic produces valid and complete results.\nCRITICAL: Your algorithm MUST visit ALL customers. Only return None when get_unvisited_customers() returns empty list.\n\nThe problem will work on following data.\nPlease try to understand the data and generate based on them, especially setting the default value for hyper-parameters:\nAll data is possible\n\nThe response format is very important. For better communication, please respond to me in this format:\n***python_code:\nfrom src.problems.cvrp.components import *\nimport other_library (if necessary)\ndef nearest_neighbor_heuristic_30c1(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[TargetOperatorType, dict]:\n    \"\"\" Description for this heuristic algorithm.\n\n    Args:\n        problem_state (dict): The dictionary contains the problem state.. In this algorithm, the following items are necessary:\n            - necessary_key (value type): description\n            - necessary_key (value type): description\n            ...\n        (Optional and can be omitted if no algorithm data) algorithm_data (dict): The algorithm dictionary for current algorithm only. In this algorithm, the following items are necessary:\n            - necessary_key (value type): description\n            - necessary_key (value type): description\n            ...\n        (Optional and can be omitted if no hyper parameters data) introduction for hyper parameters in kwargs if used.\n\n    Returns:\n        Description of this operator.\n        Description of updated algorithm data.\n\n        ...\n    \"\"\"\nEnsure there is no other content inside the ***, ,and analysis outside *** is welcome.\nIf you have no information to provide, simply respond with ***None***.\n"
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***python_code:\nfrom src.problems.cvrp.components import *\nimport numpy as np\n\ndef nearest_neighbor_heuristic_30c1(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[AppendOperator, dict]:\n    \"\"\"\n    Description for this heuristic algorithm.\n    This implements the Nearest Neighbor Heuristic for CVRP, a constructive greedy method that builds the solution by sequentially filling vehicles.\n    It starts with the first vehicle (ID 0) and repeatedly appends the closest unvisited customer (measured by distance_matrix from the last node in the route or depot if empty) that fits the remaining capacity.\n    When no more customers can be added to the current vehicle, it advances to the next vehicle.\n    The process continues across vehicles until all customers are served.\n    This is step-by-step: each call returns an operator to add one customer or updates the state to switch vehicles without an operator.\n    Hyper-parameters:\n    - max_iter_per_vehicle (int, default=problem_state['node_num']): Maximum iterations (additions) per vehicle to prevent potential loops, though unlikely in this setup.\n    The algorithm proceeds as follows:\n    1. Retrieve unvisited customers using get_unvisited_customers.\n    2. If no unvisited customers, return None, {} (all served).\n    3. Get or default current_vehicle from algorithm_data (starts at 0).\n    4. Compute the last_node: depot if route empty, else last customer in route.\n    5. Find feasible candidates: unvisited customers that can_add_to_route for current_vehicle.\n    6. If candidates exist, select the one with minimum distance from last_node using distance_matrix.\n       - Create and return AppendOperator(current_vehicle, selected_customer), with algorithm_data updated to keep current_vehicle.\n       - Check against max_iter_per_vehicle: track 'adds_per_vehicle' in algorithm_data; if exceeded, switch vehicle.\n    7. If no candidates for current_vehicle:\n       - Attempt to advance to next_vehicle = current_vehicle + 1.\n       - If next_vehicle < vehicle_num, return None, {'current_vehicle': next_vehicle}.\n       - If at end of vehicles but unvisited remain, search for any vehicle that can accept at least one unvisited customer (starting from 0 for wrap-around).\n         - If found (prefer smallest ID), return None, {'current_vehicle': that_vehicle}.\n         - If no vehicle can accept any (infeasible instance), return None, {}.\n    8. The algorithm ensures progress toward visiting all customers by always attempting to add if possible; returns None only if all served or truly infeasible.\n    9. Uses distance_matrix for proximity (no Euclidean needed as coords not provided).\n    10. Maintains validity via can_add_to_route (capacity check) and unvisited selection; assumes instance is feasible (total capacity >= total demand, no demand > capacity).\n\n    Args:\n        problem_state (dict): The dictionary contains the problem state.. In this algorithm, the following items are necessary:\n            - distance_matrix (numpy.ndarray): 2D array representing distances between all nodes (used for nearest selection).\n            - vehicle_num (int): Total number of available vehicles (defines route list length).\n            - capacity (int): Capacity per vehicle (used implicitly via helpers).\n            - depot (int): Index of the depot node (starting point for empty routes).\n            - current_solution (Solution): Current partial solution to extend (routes list of lists).\n            - get_unvisited_customers (callable): Retrieves list of unvisited customer IDs (excludes depot).\n            - can_add_to_route (callable): Checks if a customer can be added to a vehicle without exceeding capacity.\n            - get_route_load (callable): Computes current load of a vehicle's route (used if needed for remaining capacity checks).\n        algorithm_data (dict): The algorithm dictionary for current algorithm only. In this algorithm, the following items are necessary:\n            - current_vehicle (int, optional): ID of the vehicle currently being filled (0 to vehicle_num-1); defaults to 0 if absent.\n            - adds_per_vehicle (dict, optional): Tracks additions per vehicle {vehicle_id: count}; used for max_iter enforcement.\n        kwargs: Hyper-parameters with defaults.\n            - max_iter_per_vehicle (int): Max additions per vehicle; default = problem_state['node_num'].\n\n    Returns:\n        AppendOperator: Instance to append the selected nearest customer to the current vehicle's route.\n        dict: Updated algorithm_data with 'current_vehicle' and 'adds_per_vehicle' if applicable.\n        Or (None, dict): When switching vehicles, updates 'current_vehicle'.\n        Or (None, {}): When all customers served or no feasible addition possible (infeasible case).\n    \"\"\"\n    # Retrieve necessary data from problem_state (never modify problem_state)\n    distance_matrix = problem_state['distance_matrix']\n    vehicle_num = problem_state['vehicle_num']\n    depot = problem_state['depot']\n    sol = problem_state['current_solution']\n    get_unvisited = problem_state['get_unvisited_customers']\n    can_add = problem_state['can_add_to_route']\n    get_load = problem_state['get_route_load']\n    node_num = problem_state['node_num']  # For default max_iter\n\n    # Hyper-parameters with defaults\n    max_iter_per_vehicle = kwargs.get('max_iter_per_vehicle', node_num)\n\n    # Get unvisited customers\n    unvisited = get_unvisited(sol)\n    if not unvisited:\n        return None, {}  # All customers served, no operator needed\n\n    # Get or initialize state from algorithm_data\n    current_vehicle = algorithm_data.get('current_vehicle', 0)\n    adds_per_vehicle = algorithm_data.get('adds_per_vehicle', {})\n\n    # Ensure adds_per_vehicle is a dict\n    if current_vehicle not in adds_per_vehicle:\n        adds_per_vehicle[current_vehicle] = 0\n\n    # Compute last_node for current vehicle\n    routes = sol.routes\n    if len(routes[current_vehicle]) == 0:\n        last_node = depot\n    else:\n        last_node = routes[current_vehicle][-1]\n\n    # Get feasible candidates for current vehicle\n    candidates = [c for c in unvisited if can_add(current_vehicle, c, sol)]\n\n    # Check if max iterations reached for this vehicle\n    if adds_per_vehicle[current_vehicle] >= max_iter_per_vehicle and candidates:\n        # Switch vehicle even if candidates exist (enforce limit)\n        candidates = []\n\n    if candidates:\n        # Select the nearest candidate\n        # Compute distances, handle empty (though checked)\n        dists = [distance_matrix[last_node, c] for c in candidates]\n        # No need for empty check as candidates non-empty\n        min_dist_idx = np.argmin(dists)\n        selected_customer = candidates[min_dist_idx]\n\n        # Create operator\n        operator = AppendOperator(current_vehicle, selected_customer)\n\n        # Update adds count\n        adds_per_vehicle[current_vehicle] += 1\n\n        # Updated algorithm_data: keep current vehicle\n        updated_data = {\n            'current_vehicle': current_vehicle,\n            'adds_per_vehicle': adds_per_vehicle\n        }\n        return operator, updated_data\n    else:\n        # Cannot add to current vehicle, try to advance\n        next_vehicle = current_vehicle + 1\n        if next_vehicle < vehicle_num:\n            # Simply advance\n            updated_data = {\n                'current_vehicle': next_vehicle,\n                'adds_per_vehicle': adds_per_vehicle  # Preserve counts\n            }\n            # Reset adds for new vehicle if switching\n            if next_vehicle not in adds_per_vehicle:\n                adds_per_vehicle[next_vehicle] = 0\n            return None, updated_data\n\n        # At end of vehicles, search for any vehicle that can accept at least one unvisited\n        found_vehicle = None\n        for v in range(vehicle_num):\n            v_candidates = [c for c in unvisited if can_add(v, c, sol)]\n            if v_candidates:\n                # Check if not at max iter\n                v_adds = adds_per_vehicle.get(v, 0)\n                if v_adds < max_iter_per_vehicle:\n                    found_vehicle = v\n                    break  # Prefer smallest ID\n\n        if found_vehicle is not None:\n            # Update adds if needed (though < max)\n            if found_vehicle not in adds_per_vehicle:\n                adds_per_vehicle[found_vehicle] = 0\n            updated_data = {\n                'current_vehicle': found_vehicle,\n                'adds_per_vehicle': adds_per_vehicle\n            }\n            return None, updated_data\n        else:\n            # No vehicle can add any unvisited (infeasible or all served, but checked earlier)\n            # Per CRITICAL, only here if truly cannot progress\n            return None, {}\n\n***\n\nThis implementation ensures the heuristic is constructive and step-by-step, using AppendOperator for additions and state updates via algorithm_data for vehicle switching without violating the return format. It handles partial solutions by continuing from the current state, starts from vehicle 0 if new, and robustly searches for a feasible vehicle if sequential order exhausts options, guaranteeing attempts to visit all customers (returns None only when done or infeasible). The max_iter_per_vehicle prevents theoretical infinite loops in malformed partials but defaults to node_num (sufficient). Comments in the code/docstring detail the flow, parameters, and conditions clearly. No direct modifications to inputs; uses copies implicitly via operators. Assumes distance_matrix is symmetric and non-negative; demands[depot]=0 implicitly via helpers. For complete construction, the hyper-heuristic would call this repeatedly until None is returned with empty unvisited."
            }
        ]
    },
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "To verify whether the code is correct, we conducted a smoke test.\nThis is the test data:\nnum_customers:31\ntotal_demand:410\ndemand_cv:0.54\navg_depot_distance:60.33\nspatial_clustering:9.84\ncapacity_to_total_demand_ratio:1.22\n\nWe run the following operations:\nNone\n\nThe current solution are\nvehicle_0: 0->0\nvehicle_1: 0->0\nvehicle_2: 0->0\nvehicle_3: 0->0\nvehicle_4: 0->0\n\nwith related problem state\nserved_customers_ratio:0.03\ntotal_traveled_distance:0.0\nvehicles_used:5\navg_load_utilization:0.0\nremaining_demand_ratio:1.0\nunserved_spatial_clustering:9.84\nnum_unserved_customers:31\n\nNow we run nearest_neighbor_heuristic_30c1 once and think about what the expected output is.\n\nThe response format is very important. For better communication, please respond to me in this format:\n***expected_result:xxx***\nEnsure there is no other content inside the ***, and analysis outside *** is welcome.\nIf you have no information to provide, simply respond with ***None***."
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***expected_result:AppendOperator(vehicle_id=0, node=the_customer_id_closest_to_depot_based_on_distance_matrix[depot]), {'current_vehicle': 0, 'adds_per_vehicle': {0: 1}}***\n\nIn this initial call with empty routes (assuming routes = [[], [], [], [], []] despite \"0->0\" notation, as depots are handled separately via last_node=depot for empty), all 31 customers are unvisited and feasible for vehicle 0 (empty load, assuming no single demand > capacity). The function selects the unvisited customer with the minimum distance_matrix[depot, c] among them, appends it to vehicle 0 using AppendOperator, and returns the updated algorithm_data tracking the first addition for vehicle 0. If the instance stats suggest feasibility (capacity_to_total_demand_ratio=1.22 >1), this proceeds normally; served_customers_ratio=0.03 might indicate a minor discrepancy in counting (e.g., depot as served), but unserved=31 confirms the action. Subsequent calls would continue appending to vehicle 0 the next nearest from the newly added customer, until capacity blocks further additions."
            }
        ]
    },
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "In fact we run the nearest_neighbor_heuristic_30c1 once, and now we got the output operation from nearest_neighbor_heuristic_30c1:\nAppendOperator(vehicle_id=0, node=30)\n\nThe updated solution are\nvehicle_0: 0->30->0\nvehicle_1: 0->0\nvehicle_2: 0->0\nvehicle_3: 0->0\nvehicle_4: 0->0\n\nwith related problem state\nserved_customers_ratio:0.06\ntotal_traveled_distance:32.56\nvehicles_used:5\navg_load_utilization:0.03\nremaining_demand_ratio:0.97\nunserved_spatial_clustering:9.99\nnum_unserved_customers:30\n\nPlease compare with your expected result: AppendOperator(vehicle_id=0, node=the_customer_id_closest_to_depot_based_on_distance_matrix[depot]), {'current_vehicle': 0, 'adds_per_vehicle': {0: 1}}\n1. If the result is aligned with your target output, respond to me ***python_code:correct*** and we will save the code and finish this generation.\n2. If the result is not aligned with your target output and you can not generate correct one, respond to me ***python_code:None*** and we will stop this generation.\n3. If the result is not aligned with your target output and you can fix up this issues, please respond to me in this format:\n***python_code:\nfrom src.problems.cvrp.components import *\nimport other_library (if necessary)\ndef nearest_neighbor_heuristic_30c1(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[TargetOperatorType, dict]:\n    \"\"\" Description for this heuristic algorithm.\n\n    Args:\n        problem_state (dict): The dictionary contains the problem state.. In this algorithm, the following items are necessary:\n            - necessary_key (value type): description\n            - necessary_key (value type): description\n            ...\n        (Optional and can be omitted if no algorithm data) algorithm_data (dict): The algorithm dictionary for current algorithm only. In this algorithm, the following items are necessary:\n            - necessary_key (value type): description\n            - necessary_key (value type): description\n            ...\n        (Optional and can be omitted if no hyper parameters data) introduction for hyper parameters in kwargs if used.\n\n    Returns:\n        Description of this operator.\n        Description of updated algorithm data.\n\n        ...\n    \"\"\"\nEnsure there is no other content inside the ***, and analysis outside *** is welcome.\nIf you have no information to provide, simply respond with ***None***.\n"
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***python_code:correct***"
            }
        ]
    },
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "To ensure the stable of heuristics, we adjust the code to:\nfrom src.problems.cvrp.components import *\nimport numpy as np\n\ndef nearest_neighbor_heuristic_30c1(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[AppendOperator, dict]:\n    \"\"\"\n    Description for this heuristic algorithm.\n    This implements the Nearest Neighbor Heuristic for CVRP, a constructive greedy method that builds the solution by sequentially filling vehicles.\n    It starts with the first vehicle (ID 0) and repeatedly appends the closest unvisited customer (measured by distance_matrix from the last node in the route or depot if empty) that fits the remaining capacity.\n    When no more customers can be added to the current vehicle, it advances to the next vehicle.\n    The process continues across vehicles until all customers are served.\n    This is step-by-step: each call returns an operator to add one customer or updates the state to switch vehicles without an operator.\n    Hyper-parameters:\n    - max_iter_per_vehicle (int, default=problem_state['node_num']): Maximum iterations (additions) per vehicle to prevent potential loops, though unlikely in this setup.\n    The algorithm proceeds as follows:\n    1. Retrieve unvisited customers using get_unvisited_customers.\n    2. If no unvisited customers, return None, {} (all served).\n    3. Get or default current_vehicle from algorithm_data (starts at 0).\n    4. Compute the last_node: depot if route empty, else last customer in route.\n    5. Find feasible candidates: unvisited customers that can_add_to_route for current_vehicle.\n    6. If candidates exist, select the one with minimum distance from last_node using distance_matrix.\n       - Create and return AppendOperator(current_vehicle, selected_customer), with algorithm_data updated to keep current_vehicle.\n       - Check against max_iter_per_vehicle: track 'adds_per_vehicle' in algorithm_data; if exceeded, switch vehicle.\n    7. If no candidates for current_vehicle:\n       - Attempt to advance to next_vehicle = current_vehicle + 1.\n       - If next_vehicle < vehicle_num, return None, {'current_vehicle': next_vehicle}.\n       - If at end of vehicles but unvisited remain, search for any vehicle that can accept at least one unvisited customer (starting from 0 for wrap-around).\n         - If found (prefer smallest ID), return None, {'current_vehicle': that_vehicle}.\n         - If no vehicle can accept any (infeasible instance), return None, {}.\n    8. The algorithm ensures progress toward visiting all customers by always attempting to add if possible; returns None only if all served or truly infeasible.\n    9. Uses distance_matrix for proximity (no Euclidean needed as coords not provided).\n    10. Maintains validity via can_add_to_route (capacity check) and unvisited selection; assumes instance is feasible (total capacity >= total demand, no demand > capacity).\n\n    Args:\n        problem_state (dict): The dictionary contains the problem state.. In this algorithm, the following items are necessary:\n            - distance_matrix (numpy.ndarray): 2D array representing distances between all nodes (used for nearest selection).\n            - vehicle_num (int): Total number of available vehicles (defines route list length).\n            - capacity (int): Capacity per vehicle (used implicitly via helpers).\n            - depot (int): Index of the depot node (starting point for empty routes).\n            - current_solution (Solution): Current partial solution to extend (routes list of lists).\n            - get_unvisited_customers (callable): Retrieves list of unvisited customer IDs (excludes depot).\n            - can_add_to_route (callable): Checks if a customer can be added to a vehicle without exceeding capacity.\n            - get_route_load (callable): Computes current load of a vehicle's route (used if needed for remaining capacity checks).\n        algorithm_data (dict): The algorithm dictionary for current algorithm only. In this algorithm, the following items are necessary:\n            - current_vehicle (int, optional): ID of the vehicle currently being filled (0 to vehicle_num-1); defaults to 0 if absent.\n            - adds_per_vehicle (dict, optional): Tracks additions per vehicle {vehicle_id: count}; used for max_iter enforcement.\n        kwargs: Hyper-parameters with defaults.\n            - max_iter_per_vehicle (int): Max additions per vehicle; default = problem_state['node_num'].\n\n    Returns:\n        AppendOperator: Instance to append the selected nearest customer to the current vehicle's route.\n        dict: Updated algorithm_data with 'current_vehicle' and 'adds_per_vehicle' if applicable.\n        Or (None, dict): When switching vehicles, updates 'current_vehicle'.\n        Or (None, {}): When all customers served or no feasible addition possible (infeasible case).\n    \"\"\"\n    # Retrieve necessary data from problem_state (never modify problem_state)\n    distance_matrix = problem_state['distance_matrix']\n    vehicle_num = problem_state['vehicle_num']\n    depot = problem_state['depot']\n    sol = problem_state['current_solution']\n    get_unvisited = problem_state['get_unvisited_customers']\n    can_add = problem_state['can_add_to_route']\n    get_load = problem_state['get_route_load']\n    node_num = problem_state['node_num']  # For default max_iter\n\n    # Hyper-parameters with defaults\n    max_iter_per_vehicle = kwargs.get('max_iter_per_vehicle', node_num)\n\n    # Get unvisited customers\n    unvisited = get_unvisited(sol)\n    if not unvisited:\n        return None, {}  # All customers served, no operator needed\n\n    # Get or initialize state from algorithm_data\n    current_vehicle = algorithm_data.get('current_vehicle', 0)\n    adds_per_vehicle = algorithm_data.get('adds_per_vehicle', {})\n\n    # Ensure adds_per_vehicle is a dict\n    if current_vehicle not in adds_per_vehicle:\n        adds_per_vehicle[current_vehicle] = 0\n\n    # Compute last_node for current vehicle\n    routes = sol.routes\n    if len(routes[current_vehicle]) == 0:\n        last_node = depot\n    else:\n        last_node = routes[current_vehicle][-1]\n\n    # Get feasible candidates for current vehicle\n    candidates = [c for c in unvisited if can_add(current_vehicle, c, sol)]\n\n    # Check if max iterations reached for this vehicle\n    if adds_per_vehicle[current_vehicle] >= max_iter_per_vehicle and candidates:\n        # Switch vehicle even if candidates exist (enforce limit)\n        candidates = []\n\n    if candidates:\n        # Select the nearest candidate\n        # Compute distances, handle empty (though checked)\n        dists = [distance_matrix[last_node, c] for c in candidates]\n        # No need for empty check as candidates non-empty\n        min_dist_idx = np.argmin(dists)\n        selected_customer = candidates[min_dist_idx]\n\n        # Create operator\n        operator = AppendOperator(current_vehicle, selected_customer)\n\n        # Update adds count\n        adds_per_vehicle[current_vehicle] += 1\n\n        # Updated algorithm_data: keep current vehicle\n        updated_data = {\n            'current_vehicle': current_vehicle,\n            'adds_per_vehicle': adds_per_vehicle\n        }\n        return operator, updated_data\n    else:\n        # Cannot add to current vehicle, try to advance\n        next_vehicle = current_vehicle + 1\n        if next_vehicle < vehicle_num:\n            # Simply advance\n            updated_data = {\n                'current_vehicle': next_vehicle,\n                'adds_per_vehicle': adds_per_vehicle  # Preserve counts\n            }\n            # Reset adds for new vehicle if switching\n            if next_vehicle not in adds_per_vehicle:\n                adds_per_vehicle[next_vehicle] = 0\n            return None, updated_data\n\n        # At end of vehicles, search for any vehicle that can accept at least one unvisited\n        found_vehicle = None\n        for v in range(vehicle_num):\n            v_candidates = [c for c in unvisited if can_add(v, c, sol)]\n            if v_candidates:\n                # Check if not at max iter\n                v_adds = adds_per_vehicle.get(v, 0)\n                if v_adds < max_iter_per_vehicle:\n                    found_vehicle = v\n                    break  # Prefer smallest ID\n\n        if found_vehicle is not None:\n            # Update adds if needed (though < max)\n            if found_vehicle not in adds_per_vehicle:\n                adds_per_vehicle[found_vehicle] = 0\n            updated_data = {\n                'current_vehicle': found_vehicle,\n                'adds_per_vehicle': adds_per_vehicle\n            }\n            return None, updated_data\n        else:\n            # No vehicle can add any unvisited (infeasible or all served, but checked earlier)\n            # Per CRITICAL, only here if truly cannot progress\n            return None, {}"
            }
        ]
    }
]