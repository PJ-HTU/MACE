user
I am working on Hyper-heuristics for Combinatorial Operation (CO) problem.

Currently, I am working on cvrp problem:
Capacitated Vehicle Routing Problem (CVRP) is an optimization challenge focused on determining the most efficient routes for a fleet of vehicles to deliver goods to various locations, considering vehicle capacity constraints.

To support different heuristic algorithms, I build the Solution and Operator framework.
The Solution is designed as:
class Solution:
    """The solution of CVRP.
A list of lists where each sublist represents a vehicle's route.
Each sublist contains integers representing the nodes (customers) visited by the vehicle in the order of visitation.
The routes are sorted by vehicle identifier and the nodes in the list sorted by visited order."""
    def __init__(self, routes: list[list[int]], depot: int):
        self.routes = routes
        self.depot = depot
Operator servers as a mechanism to modify solution, which enables the application of heuristic algorithms.Â 
To support heuristic algorithm, we have build the following operators:
class AppendOperator(BaseOperator):
    """Append a node at the end of the specified vehicle's route."""
    def __init__(self, vehicle_id: int, node: int):
        self.vehicle_id = vehicle_id
        self.node = node
    def run(self, solution: Solution) -> Solution:
        new_routes = [route[:] for route in solution.routes]
        new_routes[self.vehicle_id].append(self.node)
        return Solution(new_routes, solution.depot)
class InsertOperator(BaseOperator):
    """Insert a node at a specified position within the route of a specified vehicle."""
    def __init__(self, vehicle_id: int, node: int, position: int):
        self.vehicle_id = vehicle_id
        self.node = node
        self.position = position
    def run(self, solution: Solution) -> Solution:
        new_routes = [route[:] for route in solution.routes]
        new_routes[self.vehicle_id].insert(self.position, self.node)
        return Solution(new_routes, solution.depot)

In pursuit of augmenting our heuristic algorithmic suite, we require the following standardized heuristic function signature:
def heuristic(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[TargetOperatorType, dict]:
The inputs are:
problem_state (dict): A dictionary containing the problem state information, organized into five categories of keys:
1. Input Data:
    - node_num (int): The total number of nodes in the problem.
    - distance_matrix (numpy.ndarray): A 2D array representing the distances between nodes.
    - vehicle_num (int): The total number of vehicles.
    - capacity (int): The capacity for each vehicle and all vehicles share the same value.
    - depot (int): The index for depot node.
    - demands (numpy.ndarray): The demand of each node.
2. Current Solution:
    - current_solution (Solution): Current solution instance.
    - total_current_cost (int): The total cost of the current solution for all vehicles.
3. Helper Functions (these Functions may help you to generation the following heuristic):
    - get_problem_state (callable): def get_problem_state(solution: Solution) -> dict: The function to get the complete problem state for given solution without modifying it. Returns a dictionary containing 'total_scheduling_cost' and other state information.
    - validation_solution (callable): def validation_solution(solution: Solution = None) -> bool: The function to check whether the solution is valid according to all mathematical model constraints. If solution is None, checks current solution. Returns True if valid, False otherwise.
    - get_unvisited_customers (callable): def get_unvisited_customers(solution: Solution = None) -> list[int]: Get list of customer node IDs that have not been visited in any route. Excludes depot from the result. If solution is None, uses current solution. Returns list of integers representing unvisited customer IDs.
    - get_route_load (callable): def get_route_load(vehicle_id: int, solution: Solution = None) -> float: Calculate the total demand of all customers in a specific vehicle's route. Excludes depot demand from calculation (only counts customer nodes). If solution is None, uses current solution. Returns float representing the total load of the route.
    - can_add_to_route (callable): def can_add_to_route(vehicle_id: int, customer: int, solution: Solution = None) -> bool: Check if a customer can be added to a vehicle's route without violating capacity constraint. Considers current route load plus customer demand versus vehicle capacity. If solution is None, uses current solution. Returns True if the customer can be added without exceeding capacity, False otherwise.
4. Instance Statistics (these Instance Statistics may help you to generation the following heuristic):
    - num_customers (int): The number of customer nodes excluding the depot.
    - total_demand (float): The sum of demands for all customer nodes.
    - demand_cv (float): The coefficient of variation of customer demands (std/mean).
    - avg_depot_distance (float): The average distance from depot to all customers.
    - spatial_clustering (float): The average of minimum distances between each customer and its nearest neighbor customer.
    - capacity_to_total_demand_ratio (float): The ratio of total vehicle capacity (capacity * vehicle_num) to total demand.
5. Current Solution Statistics (these Solution Statistics may help you to generation the following heuristic):
    - served_customers_ratio (float): Ratio of served customers to total customers.
    - total_traveled_distance (float): Total distance traveled in all routes (including partial).
    - vehicles_used (int): Number of non-empty routes (active or complete).
    - avg_load_utilization (float): Average load utilization across used routes.
    - remaining_demand_ratio (float): Ratio of remaining demand to total customer demand.
    - unserved_spatial_clustering (float): Average minimum distance between unserved customers.
    - num_unserved_customers (int): Number of unserved customers.
algorithm_data(dict): Algorithm data contains the data that necessary for some algorithms.
Other hyper-parameters in kwargs.
The outputs includes the operator that must be an instance of a predefined target operator type and updated algorithm dict, which contains new information for future work for both this or other algorithm.

Please consider is cvrp a combinatorial operation problem and can be solved by heuristics?
If you think this problem is not a combinatorial operation problem or the solution, operator, data are incorrect, response ***is_cop:no*** to me, or response ***is_cop:yes***.

The response format is very important. For better communication, please respond to me in this format:
***is_cop:yes/no***
Ensure there is no other content inside the ***, and analysis outside *** is welcome.
If you have no information to provide, simply respond with ***None***.
------------------------------------------------------------------------------------

assistant
***is_cop:yes***

CVRP is indeed a classic combinatorial optimization (CO) problem, as it involves discrete decision-making over a finite set of possible routes and assignments while optimizing objectives like total distance or cost, subject to constraints like vehicle capacity and customer demands. It's NP-hard, making exact solutions impractical for large instances, so heuristics (e.g., local search, genetic algorithms) and meta-heuristics (e.g., tabu search, simulated annealing) are standard approaches. Your Solution class and operators (AppendOperator, InsertOperator) align well with representing and perturbing CVRP solutions, enabling hyper-heuristic frameworks to select or generate improvements. The provided problem_state dict structure, with categories for input data, current solution, helpers, and statistics, supports effective heuristic design by providing necessary context for operator selection. If you're building hyper-heuristics, consider incorporating operators like relocate, exchange, or 2-opt for richer neighborhood exploration in CVRP.
------------------------------------------------------------------------------------

user
I need your help to design different 5 basic heuristics for the cvrp problem.

## Heuristic Requirements:
1. **Constructive Nature**: Each heuristic must be constructive (or constructive followed by improvement), and build solutions step-by-step from scratch.

2. **Diversity**: The 5 heuristics should represent different strategies to ensure diversity in solution approaches.

The problem will work on following data.
Please try to understand the data and generate based on them, especially setting the default value for hyper-parameters:
All data is possible

The response format is very important. For better communication, please respond to me in this format:
***heuristic:
heuristic_name: only text description
heuristic_name: only text description
....
***
Ensure there is no other content (including blank lines) inside the ***, and analysis outside *** is welcome.
If you have no information to provide, simply respond with ***None***.
------------------------------------------------------------------------------------

assistant
***heuristic:
Nearest Neighbor Heuristic: Start with empty routes for each vehicle. For each vehicle in sequence, repeatedly append the nearest unvisited customer (by distance from the last node in the route) that fits the remaining capacity until no more can be added or all customers are served. Default: Use Euclidean distance if available, or matrix distance; max iterations per vehicle = node_num.
Cheapest Insertion Heuristic: Initialize with a single route per customer-depot pair. Iteratively select the unserved customer with the lowest insertion cost (increase in total route distance) and insert it into the feasible route (via InsertOperator) where the added cost is minimal, respecting capacity. Default: Insertion cost = distance savings; regret threshold = 0.1 * avg_depot_distance; run until all served.
Clarke-Wright Savings Heuristic: Begin with individual depot-customer-depot routes for all customers. Compute savings for merging adjacent routes (s_ikj = dist(i,k) + dist(j,k) - dist(i,j) where i,j are route ends, k merge point). Greedily merge routes with highest savings using InsertOperator to append segments, ensuring capacity. Default: Parallel version (merge independently); sort savings descending; stop when no feasible merges.
Sweep Heuristic: Order customers by angular position around the depot (polar angle). Start empty routes. Sweep clockwise, appending consecutive customers in angular order to the current vehicle if capacity allows (using AppendOperator); open a new vehicle when capacity exceeded. Default: Angle from positive x-axis; depot at (0,0) if coordinates available, else use distance_matrix approximation; one sweep per vehicle until all served.
Random Greedy Heuristic: Initialize empty routes. For each vehicle, randomly select unvisited customers that fit capacity and append them in random order (AppendOperator), preferring closer ones with probability proportional to inverse distance. Repeat until all customers assigned or vehicles exhausted. Default: Probability weight = 1 / (1 + distance); random seed from algorithm_data if provided; ensure at least 50% greedy selection ratio.
***

These heuristics are designed to be constructive, building solutions incrementally using the provided operators (primarily AppendOperator for sequential addition, with InsertOperator for refinements in insertion-based ones). They leverage the problem_state dict: input data for distances/demands/capacity, helper functions like get_unvisited_customers, can_add_to_route, and validation_solution for feasibility checks, and statistics like spatial_clustering or remaining_demand_ratio to bias selections (e.g., in Random Greedy). Diversity comes from strategies: greedy proximity (Nearest), cost-aware insertion (Cheapest), merge-based (Savings), geometric ordering (Sweep), and stochastic (Random). For implementation, the heuristic function would return an operator instance (e.g., AppendOperator(vehicle_id, node)) and updated algorithm_data (e.g., {'partial_solution': new_solution, 'used_vehicles': count}). Post-construction, a simple 2-opt improvement could be added via additional operators if allowed, but kept minimal here. Hyper-parameters like thresholds are set with sensible defaults based on instance stats (e.g., avg_depot_distance for scaling). If coordinates are in problem_state (not explicitly listed but inferable from distance_matrix), use them for Sweep; otherwise, approximate angles via distances.
------------------------------------------------------------------------------------

user
Based on previous discuss, we get the heuristic Clarke-Wright Savings Heuristic:
 Begin with individual depot-customer-depot routes for all customers. Compute savings for merging adjacent routes (s_ikj = dist(i,k) + dist(j,k) - dist(i,j) where i,j are route ends, k merge point). Greedily merge routes with highest savings using InsertOperator to append segments, ensuring capacity. Default: Parallel version (merge independently); sort savings descending; stop when no feasible merges..

Now please implement it in python function clarke_wright_savings_heuristic_9bf6.

To implement this heuristic function in python, please note:
1. We can assume that Solution and all Operators are imported.
2. The operator type must be defined previously, do not create a new one in your code.
3. Never modify the data in problem_state.
4. All hyper parameters in kwargs should be set a default value.
5. Any reasonable partial solution may be used as input, such as an empty solution.
6. Comments in the code are very important. They must clearly explain which hyper-parameters are required by the algorithm (i.e., the parameters in **kwargs), how the algorithm proceeds, and under what circumstances it will not return any operator or will return an empty operator. We hope that people can understand the principles and workflow of the algorithm clearly just by reading the comments, without needing to look at the code.
7. The name of function must be clarke_wright_savings_heuristic_9bf6. The TargetOperatorType should be replaced by real returned operator type.
8. No any omissions or placeholders, I'm just going to use the code.
9. For the algorithm to update the algorithm_data, do not modify directly "algorithm_data["abc"] = 123", we should return operator, {"abc": 123}.For algorithm that do not update them, just return operator, {}
10. For the circumstances that algorithm return empty operator, please return None, {}.
11. Do not forget to check whether the content is empty when calculating the min/max/average/std/..., such as when using min([distance[node][other] for other in nodes if other != node]).
12. Make the result must be valid.
13. Do not forget the input problem_state:
problem_state (dict): A dictionary containing the problem state information, organized into five categories of keys:
1. Input Data:
    - node_num (int): The total number of nodes in the problem.
    - distance_matrix (numpy.ndarray): A 2D array representing the distances between nodes.
    - vehicle_num (int): The total number of vehicles.
    - capacity (int): The capacity for each vehicle and all vehicles share the same value.
    - depot (int): The index for depot node.
    - demands (numpy.ndarray): The demand of each node.
2. Current Solution:
    - current_solution (Solution): Current solution instance.
    - total_current_cost (int): The total cost of the current solution for all vehicles.
3. Helper Functions (these Functions may help you to generation the following heuristic):
    - get_problem_state (callable): def get_problem_state(solution: Solution) -> dict: The function to get the complete problem state for given solution without modifying it. Returns a dictionary containing 'total_scheduling_cost' and other state information.
    - validation_solution (callable): def validation_solution(solution: Solution = None) -> bool: The function to check whether the solution is valid according to all mathematical model constraints. If solution is None, checks current solution. Returns True if valid, False otherwise.
    - get_unvisited_customers (callable): def get_unvisited_customers(solution: Solution = None) -> list[int]: Get list of customer node IDs that have not been visited in any route. Excludes depot from the result. If solution is None, uses current solution. Returns list of integers representing unvisited customer IDs.
    - get_route_load (callable): def get_route_load(vehicle_id: int, solution: Solution = None) -> float: Calculate the total demand of all customers in a specific vehicle's route. Excludes depot demand from calculation (only counts customer nodes). If solution is None, uses current solution. Returns float representing the total load of the route.
    - can_add_to_route (callable): def can_add_to_route(vehicle_id: int, customer: int, solution: Solution = None) -> bool: Check if a customer can be added to a vehicle's route without violating capacity constraint. Considers current route load plus customer demand versus vehicle capacity. If solution is None, uses current solution. Returns True if the customer can be added without exceeding capacity, False otherwise.
4. Instance Statistics (these Instance Statistics may help you to generation the following heuristic):
    - num_customers (int): The number of customer nodes excluding the depot.
    - total_demand (float): The sum of demands for all customer nodes.
    - demand_cv (float): The coefficient of variation of customer demands (std/mean).
    - avg_depot_distance (float): The average distance from depot to all customers.
    - spatial_clustering (float): The average of minimum distances between each customer and its nearest neighbor customer.
    - capacity_to_total_demand_ratio (float): The ratio of total vehicle capacity (capacity * vehicle_num) to total demand.
5. Current Solution Statistics (these Solution Statistics may help you to generation the following heuristic):
    - served_customers_ratio (float): Ratio of served customers to total customers.
    - total_traveled_distance (float): Total distance traveled in all routes (including partial).
    - vehicles_used (int): Number of non-empty routes (active or complete).
    - avg_load_utilization (float): Average load utilization across used routes.
    - remaining_demand_ratio (float): Ratio of remaining demand to total customer demand.
    - unserved_spatial_clustering (float): Average minimum distance between unserved customers.
    - num_unserved_customers (int): Number of unserved customers.

For cvrp problem, take about following:
Ensure your heuristic produces valid and complete results.
CRITICAL: Your algorithm MUST visit ALL customers. Only return None when get_unvisited_customers() returns empty list.

The problem will work on following data.
Please try to understand the data and generate based on them, especially setting the default value for hyper-parameters:
All data is possible

The response format is very important. For better communication, please respond to me in this format:
***python_code:
from src.problems.cvrp.components import *
import other_library (if necessary)
def clarke_wright_savings_heuristic_9bf6(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[TargetOperatorType, dict]:
    """ Description for this heuristic algorithm.

    Args:
        problem_state (dict): The dictionary contains the problem state.. In this algorithm, the following items are necessary:
            - necessary_key (value type): description
            - necessary_key (value type): description
            ...
        (Optional and can be omitted if no algorithm data) algorithm_data (dict): The algorithm dictionary for current algorithm only. In this algorithm, the following items are necessary:
            - necessary_key (value type): description
            - necessary_key (value type): description
            ...
        (Optional and can be omitted if no hyper parameters data) introduction for hyper parameters in kwargs if used.

    Returns:
        Description of this operator.
        Description of updated algorithm data.

        ...
    """
Ensure there is no other content inside the ***, ,and analysis outside *** is welcome.
If you have no information to provide, simply respond with ***None***.

------------------------------------------------------------------------------------

assistant
***python_code:
from src.problems.cvrp.components import *
def clarke_wright_savings_heuristic_9bf6(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[AppendOperator, dict]:
    """Clarke-Wright Savings Heuristic adapted as a sequential constructive method for CVRP.
    This heuristic builds the solution step-by-step by greedily adding unvisited customers to existing routes or starting new routes based on computed savings.
    It mimics the merging idea of Clarke-Wright by preferring to extend routes where the saving (compared to serving the customer separately) is maximized.
    Savings for appending customer j to a route ending at i: distance(i, depot) + distance(depot, j) - distance(i, j).
    The process continues until all customers are served. Each call adds one customer.

    Args:
        problem_state (dict): The dictionary contains the problem state. In this algorithm, the following items are necessary:
            - distance_matrix (numpy.ndarray): 2D array representing distances between all nodes (used to compute savings and select closest for new routes).
            - depot (int): The index of the depot node (used in savings calculations and selecting customers for new routes).
            - vehicle_num (int): The total number of available vehicles (to check if new routes can be started).
            - current_solution (Solution): The current partial solution instance (to access routes and determine route ends).
            - get_unvisited_customers (callable): Function to retrieve the list of unvisited customer nodes (to identify candidates for addition).
            - can_add_to_route (callable): Function to check if a customer can be added to a specific vehicle's route without exceeding capacity.
            - vehicles_used (int): The number of currently used (non-empty) vehicles (to determine the next vehicle ID for new routes).
        algorithm_data (dict): Not used in this implementation, as the heuristic is stateless and recomputes based on the current solution each time.
        **kwargs: Hyper-parameters for the algorithm:
            - saving_threshold (float, optional): The minimum savings value required to prefer extending an existing route over starting a new one. If the best extension saving is below this threshold and a new route is possible, a new route is started instead. Defaults to 0.0. Lower values (e.g., negative) make it more aggressive in extending routes.

    Returns:
        tuple[AppendOperator or None, dict]: Returns an AppendOperator to add the next customer to the best route (or new vehicle) based on savings, which when applied will produce a valid partial solution. If all customers are served (no unvisited), returns (None, {}). The second element is always an empty dict as no updates to algorithm_data are needed. If no feasible action is possible (e.g., all routes full, no more vehicles, unvisited remain), returns (None, {}), though instances are assumed feasible so this should only occur when complete.
    """
    # Extract necessary data from problem_state (never modify problem_state)
    distance_matrix = problem_state['distance_matrix']
    depot = problem_state['depot']
    vehicle_num = problem_state['vehicle_num']
    current_solution = problem_state['current_solution']
    get_unvisited_customers = problem_state['get_unvisited_customers']
    can_add_to_route = problem_state['can_add_to_route']
    vehicles_used = problem_state['vehicles_used']

    # Hyper-parameter: saving_threshold controls when to prefer extension vs. new route
    # Default: 0.0 (extend if saving >= 0, else consider new route if possible)
    saving_threshold = kwargs.get('saving_threshold', 0.0)

    # Get unvisited customers; if none, solution is complete
    unvisited = get_unvisited_customers(current_solution)
    if not unvisited:
        # No more customers to serve; return None to indicate completion
        return None, {}

    # Get current routes for analysis
    routes = current_solution.routes

    # Find the best extension: max saving for appending to an existing route
    best_extension_saving = float('-inf')
    best_vid = -1
    best_node = -1
    has_feasible_extension = False

    # Iterate over all vehicles with non-empty routes
    for vid in range(len(routes)):
        route = routes[vid]
        if not route:  # Skip empty routes
            continue
        end = route[-1]  # Last customer in the route (end point)
        # Check each unvisited customer for this route
        for node in unvisited:
            # Only consider if capacity allows addition
            if can_add_to_route(vid, node, current_solution):
                has_feasible_extension = True
                # Compute saving: dist(end, depot) + dist(depot, node) - dist(end, node)
                saving = (distance_matrix[end][depot] +
                          distance_matrix[depot][node] -
                          distance_matrix[end][node])
                # Update if this is the best saving found
                if saving > best_extension_saving:
                    best_extension_saving = saving
                    best_vid = vid
                    best_node = node

    # Decide on action based on best extension and threshold
    if has_feasible_extension and best_extension_saving >= saving_threshold:
        # Prefer extending the route with the highest saving >= threshold
        # This appends to the end, producing a valid extension
        return AppendOperator(best_vid, best_node), {}
    elif vehicles_used < vehicle_num and unvisited:
        # No good extension (saving < threshold); start a new route if possible
        # Select the unvisited customer closest to depot (minimize initial cost: 2 * dist(depot, node))
        # Check for empty list to avoid errors in min
        if unvisited:
            best_node_new = min(unvisited, key=lambda n: distance_matrix[depot][n])
            # Next vehicle ID is the current number of used vehicles (assuming routes list is sized to vehicle_num with empties at end)
            next_vid = vehicles_used
            # This starts a new valid single-customer route
            return AppendOperator(next_vid, best_node_new), {}
        else:
            # Should not reach here if unvisited check passed
            return None, {}
    elif has_feasible_extension:
        # No new route possible, but extensions available; use the best even if saving < threshold
        # Ensures progress toward serving all customers
        return AppendOperator(best_vid, best_node), {}
    else:
        # No feasible extensions and cannot start new route (e.g., max vehicles used, all routes full)
        # Per assumptions, instances are feasible, so this indicates completion or error; return None
        # But only truly complete if unvisited empty (already checked earlier)
        return None, {}
***
This implementation adapts the Clarke-Wright Savings heuristic into a sequential constructive process suitable for the operator framework, using only AppendOperator to add unvisited customers one at a time. It ensures validity by relying on can_add_to_route for capacity checks and get_unvisited_customers to avoid duplicates or depot inclusion. The greedy selection based on savings promotes merging-like behavior by favoring connections that save distance compared to separate servicing. Recomputing each time ensures it works with the partial current_solution without needing algorithm_data state. If the instance is infeasible (e.g., total_demand > capacity * vehicle_num), it may return None prematurely, but the prompt assumes all data is possible and feasible. For the parallel version, this sequential approximation sorts implicitly by max saving at each step; a full parallel would require precomputing and buffering in algorithm_data, but that complicates the stateless design. The code handles empty lists safely (e.g., no min on empty unvisited). After all applications, the final solution should be valid and complete, as each step preserves validity and covers all customers.
------------------------------------------------------------------------------------

user
To verify whether the code is correct, we conducted a smoke test.
This is the test data:
num_customers:31
total_demand:410
demand_cv:0.54
avg_depot_distance:60.33
spatial_clustering:9.84
capacity_to_total_demand_ratio:1.22

We run the following operations:
None

The current solution are
vehicle_0: 0->0
vehicle_1: 0->0
vehicle_2: 0->0
vehicle_3: 0->0
vehicle_4: 0->0

with related problem state
served_customers_ratio:0.03
total_traveled_distance:0.0
vehicles_used:5
avg_load_utilization:0.0
remaining_demand_ratio:1.0
unserved_spatial_clustering:9.84
num_unserved_customers:31

Now we run clarke_wright_savings_heuristic_9bf6 once and think about what the expected output is.

The response format is very important. For better communication, please respond to me in this format:
***expected_result:xxx***
Ensure there is no other content inside the ***, and analysis outside *** is welcome.
If you have no information to provide, simply respond with ***None***.
------------------------------------------------------------------------------------

assistant
***expected_result:AppendOperator(vehicle_id=5, node=closest_customer_to_depot), {}***
Given the initial empty solution (all routes empty, vehicles_used=5 but no customers served, unserved=31), the code skips the extension loop as all routes are empty (no 'end' node). With has_feasible_extension=False, it proceeds to the elif: vehicles_used (5) < vehicle_num (assumed >5 based on ratio 1.22 allowing feasibility for 31 customers), so it selects the unvisited customer minimizing distance_matrix[depot][node] (closest to depot) and returns AppendOperator(5, that_node), {}. This starts the first actual route. If vehicle_num==5 and all "used" but empty, it might fallback to None if no new route possible, but test data implies feasibility so vehicle_num>5. The served_ratio=0.03 seems anomalous (should be 0.0), but doesn't affect logic as unvisited=31 triggers action. After application, the solution updates to include that customer in vehicle 5's route, remaining valid.
------------------------------------------------------------------------------------

user
In fact we run the clarke_wright_savings_heuristic_9bf6 once, and now we got the output operation from clarke_wright_savings_heuristic_9bf6:
AppendOperator(vehicle_id=0, node=1)

The updated solution are
vehicle_0: 0->1->0
vehicle_1: 0->0
vehicle_2: 0->0
vehicle_3: 0->0
vehicle_4: 0->0

with related problem state
served_customers_ratio:0.06
total_traveled_distance:69.86
vehicles_used:5
avg_load_utilization:0.04
remaining_demand_ratio:0.95
unserved_spatial_clustering:9.95
num_unserved_customers:30

Please compare with your expected result: AppendOperator(vehicle_id=5, node=closest_customer_to_depot), {}
1. If the result is aligned with your target output, respond to me ***python_code:correct*** and we will save the code and finish this generation.
2. If the result is not aligned with your target output and you can not generate correct one, respond to me ***python_code:None*** and we will stop this generation.
3. If the result is not aligned with your target output and you can fix up this issues, please respond to me in this format:
***python_code:
from src.problems.cvrp.components import *
import other_library (if necessary)
def clarke_wright_savings_heuristic_9bf6(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[TargetOperatorType, dict]:
    """ Description for this heuristic algorithm.

    Args:
        problem_state (dict): The dictionary contains the problem state.. In this algorithm, the following items are necessary:
            - necessary_key (value type): description
            - necessary_key (value type): description
            ...
        (Optional and can be omitted if no algorithm data) algorithm_data (dict): The algorithm dictionary for current algorithm only. In this algorithm, the following items are necessary:
            - necessary_key (value type): description
            - necessary_key (value type): description
            ...
        (Optional and can be omitted if no hyper parameters data) introduction for hyper parameters in kwargs if used.

    Returns:
        Description of this operator.
        Description of updated algorithm data.

        ...
    """
Ensure there is no other content inside the ***, and analysis outside *** is welcome.
If you have no information to provide, simply respond with ***None***.

------------------------------------------------------------------------------------

assistant
***python_code:
from src.problems.cvrp.components import *
def clarke_wright_savings_heuristic_9bf6(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[AppendOperator, dict]:
    """Clarke-Wright Savings Heuristic adapted as a sequential constructive method for CVRP.
    This heuristic builds the solution step-by-step by greedily adding unvisited customers to existing routes or starting new routes based on computed savings.
    It mimics the merging idea of Clarke-Wright by preferring to extend routes where the saving (compared to serving the customer separately) is maximized.
    Savings for appending customer j to a route ending at i: distance(i, depot) + distance(depot, j) - distance(i, j).
    The process continues until all customers are served. Each call adds one customer.

    Args:
        problem_state (dict): The dictionary contains the problem state. In this algorithm, the following items are necessary:
            - distance_matrix (numpy.ndarray): 2D array representing distances between all nodes (used to compute savings and select closest for new routes).
            - depot (int): The index of the depot node (used in savings calculations and selecting customers for new routes).
            - current_solution (Solution): The current partial solution instance (to access routes and determine route ends).
            - get_unvisited_customers (callable): Function to retrieve the list of unvisited customer nodes (to identify candidates for addition).
            - can_add_to_route (callable): Function to check if a customer can be added to a specific vehicle's route without exceeding capacity.
        algorithm_data (dict): Not used in this implementation, as the heuristic is stateless and recomputes based on the current solution each time.
        **kwargs: Hyper-parameters for the algorithm:
            - saving_threshold (float, optional): The minimum savings value required to prefer extending an existing route over starting a new one. If the best extension saving is below this threshold and a new route is possible, a new route is started instead. Defaults to 0.0. Lower values (e.g., negative) make it more aggressive in extending routes.

    Returns:
        tuple[AppendOperator or None, dict]: Returns an AppendOperator to add the next customer to the best route (or new vehicle) based on savings, which when applied will produce a valid partial solution. If all customers are served (no unvisited), returns (None, {}). The second element is always an empty dict as no updates to algorithm_data are needed. If no feasible action is possible (e.g., all routes full, no more vehicles, unvisited remain), returns (None, {}), though instances are assumed feasible so this should only occur when complete.
    """
    # Extract necessary data from problem_state (never modify problem_state)
    distance_matrix = problem_state['distance_matrix']
    depot = problem_state['depot']
    current_solution = problem_state['current_solution']
    get_unvisited_customers = problem_state['get_unvisited_customers']
    can_add_to_route = problem_state['can_add_to_route']

    # Hyper-parameter: saving_threshold controls when to prefer extension vs. new route
    # Default: 0.0 (extend if saving >= 0, else consider new route if possible)
    saving_threshold = kwargs.get('saving_threshold', 0.0)

    # Get unvisited customers; if none, solution is complete
    unvisited = get_unvisited_customers(current_solution)
    if not unvisited:
        # No more customers to serve; return None to indicate completion
        return None, {}

    # Get current routes for analysis
    routes = current_solution.routes
    vehicle_num = len(routes)  # Assume routes list length equals vehicle_num

    # Find the best extension: max saving for appending to an existing route
    best_extension_saving = float('-inf')
    best_vid = -1
    best_node = -1
    has_feasible_extension = False

    # Iterate over all vehicles with non-empty routes
    for vid in range(vehicle_num):
        route = routes[vid]
        if len(route) == 0:  # Skip empty routes
            continue
        end = route[-1]  # Last customer in the route (end point)
        # Check each unvisited customer for this route
        for node in unvisited:
            # Only consider if capacity allows addition
            if can_add_to_route(vid, node, current_solution):
                has_feasible_extension = True
                # Compute saving: dist(end, depot) + dist(depot, node) - dist(end, node)
                saving = (distance_matrix[end][depot] +
                          distance_matrix[depot][node] -
                          distance_matrix[end][node])
                # Update if this is the best saving found
                if saving > best_extension_saving:
                    best_extension_saving = saving
                    best_vid = vid
                    best_node = node

    # Find available vehicles for new route (empty routes)
    available_vids = [vid for vid in range(vehicle_num) if len(routes[vid]) == 0]

    # Decide on action based on best extension and threshold
    if has_feasible_extension and best_extension_saving >= saving_threshold:
        # Prefer extending the route with the highest saving >= threshold
        # This appends to the end, producing a valid extension
        return AppendOperator(best_vid, best_node), {}
    elif available_vids:
        # No good extension (saving < threshold) or no extension possible; start a new route if possible
        # Select the unvisited customer closest to depot (minimize initial cost: 2 * dist(depot, node))
        # Since unvisited non-empty (checked earlier), min is safe
        best_node_new = min(unvisited, key=lambda n: distance_matrix[depot][n])
        # Use the first available vehicle ID
        next_vid = min(available_vids)
        # This starts a new valid single-customer route
        return AppendOperator(next_vid, best_node_new), {}
    elif has_feasible_extension:
        # No new route possible, but extensions available; use the best even if saving < threshold
        # Ensures progress toward serving all customers
        return AppendOperator(best_vid, best_node), {}
    else:
        # No feasible extensions and cannot start new route (e.g., no available vehicles, all routes full)
        # Per assumptions, instances are feasible, so this indicates completion or error; return None
        # But only truly complete if unvisited empty (already checked earlier)
        return None, {}
***

The fix aligns the code with the actual output by selecting the first empty vehicle (vid=0 initially) for starting a new route, using available_vids instead of relying on vehicles_used for the vehicle ID. This handles cases where initial routes are empty (len(route)==0), regardless of the reported vehicles_used value, which seems inconsistent in the test (possibly counting allocated vehicles including empties). The min on unvisited is safe as it's after checking not unvisited. Node=1 is assumed to be the closest to depot (depot=0, dist[0][1] minimal). After this fix, the first call adds to vehicle 0, matching the smoke test. Subsequent calls will prefer extensions to existing routes (now vid=0 with end=1) if high saving, else start new at next available (vid=1, etc.). This ensures progressive construction toward a complete, valid solution covering all 31 customers. Removed vehicles_used from extraction and doc as it's no longer used. The code remains stateless and uses only provided helpers for validity.
------------------------------------------------------------------------------------

user
To verify whether the code is correct, we conducted a smoke test.
This is the test data:
num_customers:31
total_demand:410
demand_cv:0.54
avg_depot_distance:60.33
spatial_clustering:9.84
capacity_to_total_demand_ratio:1.22

We run the following operations:
None

The current solution are
vehicle_0: 0->0
vehicle_1: 0->0
vehicle_2: 0->0
vehicle_3: 0->0
vehicle_4: 0->0

with related problem state
served_customers_ratio:0.03
total_traveled_distance:0.0
vehicles_used:5
avg_load_utilization:0.0
remaining_demand_ratio:1.0
unserved_spatial_clustering:9.84
num_unserved_customers:31

Now we run clarke_wright_savings_heuristic_9bf6 once and think about what the expected output is.

The response format is very important. For better communication, please respond to me in this format:
***expected_result:xxx***
Ensure there is no other content inside the ***, and analysis outside *** is welcome.
If you have no information to provide, simply respond with ***None***.
------------------------------------------------------------------------------------

assistant
***expected_result:AppendOperator(vehicle_id=0, node=closest_customer_to_depot), {}***

In the initial empty solution (all routes empty, depicted as 0->0), the code identifies no feasible extensions (all len(route)==0), so has_feasible_extension=False. available_vids=[0,1,2,3,4] (all empty), so it selects the unvisited customer closest to the depot (min distance_matrix[depot][n]) and assigns to the first available vehicle (min(available_vids)=0), returning AppendOperator(0, that_node), {}. This matches the smoke test output where node=1 is the closest, starting the first route validly. Subsequent calls would then consider extensions to this new route or start on next available (vid=1, etc.). The vehicles_used=5 in state might count allocated vehicles, but code relies on actual route lengths for availability, ensuring correct behavior.
------------------------------------------------------------------------------------

user
In fact we run the clarke_wright_savings_heuristic_9bf6 once, and now we got the output operation from clarke_wright_savings_heuristic_9bf6:
AppendOperator(vehicle_id=0, node=1)

The updated solution are
vehicle_0: 0->1->0
vehicle_1: 0->0
vehicle_2: 0->0
vehicle_3: 0->0
vehicle_4: 0->0

with related problem state
served_customers_ratio:0.06
total_traveled_distance:69.86
vehicles_used:5
avg_load_utilization:0.04
remaining_demand_ratio:0.95
unserved_spatial_clustering:9.95
num_unserved_customers:30

Please compare with your expected result: AppendOperator(vehicle_id=0, node=closest_customer_to_depot), {}
1. If the result is aligned with your target output, respond to me ***python_code:correct*** and we will save the code and finish this generation.
2. If the result is not aligned with your target output and you can not generate correct one, respond to me ***python_code:None*** and we will stop this generation.
3. If the result is not aligned with your target output and you can fix up this issues, please respond to me in this format:
***python_code:
from src.problems.cvrp.components import *
import other_library (if necessary)
def clarke_wright_savings_heuristic_9bf6(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[TargetOperatorType, dict]:
    """ Description for this heuristic algorithm.

    Args:
        problem_state (dict): The dictionary contains the problem state.. In this algorithm, the following items are necessary:
            - necessary_key (value type): description
            - necessary_key (value type): description
            ...
        (Optional and can be omitted if no algorithm data) algorithm_data (dict): The algorithm dictionary for current algorithm only. In this algorithm, the following items are necessary:
            - necessary_key (value type): description
            - necessary_key (value type): description
            ...
        (Optional and can be omitted if no hyper parameters data) introduction for hyper parameters in kwargs if used.

    Returns:
        Description of this operator.
        Description of updated algorithm data.

        ...
    """
Ensure there is no other content inside the ***, and analysis outside *** is welcome.
If you have no information to provide, simply respond with ***None***.

------------------------------------------------------------------------------------

assistant
***python_code:correct***

The actual output matches the expected: it starts a new route on the first available vehicle (0) with the closest unvisited customer to the depot (node=1), producing a valid partial solution as shown. The code logic correctly identifies empty routes and proceeds to initialize the first one, ensuring progressive construction. With this alignment, the implementation is verified correct for the initial step, and subsequent calls would continue similarly, building toward a complete solution.
------------------------------------------------------------------------------------

user
To ensure the stable of heuristics, we adjust the code to:
from src.problems.cvrp.components import *
def clarke_wright_savings_heuristic_9bf6(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[AppendOperator, dict]:
    """Clarke-Wright Savings Heuristic adapted as a sequential constructive method for CVRP.
    This heuristic builds the solution step-by-step by greedily adding unvisited customers to existing routes or starting new routes based on computed savings.
    It mimics the merging idea of Clarke-Wright by preferring to extend routes where the saving (compared to serving the customer separately) is maximized.
    Savings for appending customer j to a route ending at i: distance(i, depot) + distance(depot, j) - distance(i, j).
    The process continues until all customers are served. Each call adds one customer.

    Args:
        problem_state (dict): The dictionary contains the problem state. In this algorithm, the following items are necessary:
            - distance_matrix (numpy.ndarray): 2D array representing distances between all nodes (used to compute savings and select closest for new routes).
            - depot (int): The index of the depot node (used in savings calculations and selecting customers for new routes).
            - current_solution (Solution): The current partial solution instance (to access routes and determine route ends).
            - get_unvisited_customers (callable): Function to retrieve the list of unvisited customer nodes (to identify candidates for addition).
            - can_add_to_route (callable): Function to check if a customer can be added to a specific vehicle's route without exceeding capacity.
        algorithm_data (dict): Not used in this implementation, as the heuristic is stateless and recomputes based on the current solution each time.
        **kwargs: Hyper-parameters for the algorithm:
            - saving_threshold (float, optional): The minimum savings value required to prefer extending an existing route over starting a new one. If the best extension saving is below this threshold and a new route is possible, a new route is started instead. Defaults to 0.0. Lower values (e.g., negative) make it more aggressive in extending routes.

    Returns:
        tuple[AppendOperator or None, dict]: Returns an AppendOperator to add the next customer to the best route (or new vehicle) based on savings, which when applied will produce a valid partial solution. If all customers are served (no unvisited), returns (None, {}). The second element is always an empty dict as no updates to algorithm_data are needed. If no feasible action is possible (e.g., all routes full, no more vehicles, unvisited remain), returns (None, {}), though instances are assumed feasible so this should only occur when complete.
    """
    # Extract necessary data from problem_state (never modify problem_state)
    distance_matrix = problem_state['distance_matrix']
    depot = problem_state['depot']
    current_solution = problem_state['current_solution']
    get_unvisited_customers = problem_state['get_unvisited_customers']
    can_add_to_route = problem_state['can_add_to_route']

    # Hyper-parameter: saving_threshold controls when to prefer extension vs. new route
    # Default: 0.0 (extend if saving >= 0, else consider new route if possible)
    saving_threshold = kwargs.get('saving_threshold', 0.0)

    # Get unvisited customers; if none, solution is complete
    unvisited = get_unvisited_customers(current_solution)
    if not unvisited:
        # No more customers to serve; return None to indicate completion
        return None, {}

    # Get current routes for analysis
    routes = current_solution.routes
    vehicle_num = len(routes)  # Assume routes list length equals vehicle_num

    # Find the best extension: max saving for appending to an existing route
    best_extension_saving = float('-inf')
    best_vid = -1
    best_node = -1
    has_feasible_extension = False

    # Iterate over all vehicles with non-empty routes
    for vid in range(vehicle_num):
        route = routes[vid]
        if len(route) == 0:  # Skip empty routes
            continue
        end = route[-1]  # Last customer in the route (end point)
        # Check each unvisited customer for this route
        for node in unvisited:
            # Only consider if capacity allows addition
            if can_add_to_route(vid, node, current_solution):
                has_feasible_extension = True
                # Compute saving: dist(end, depot) + dist(depot, node) - dist(end, node)
                saving = (distance_matrix[end][depot] +
                          distance_matrix[depot][node] -
                          distance_matrix[end][node])
                # Update if this is the best saving found
                if saving > best_extension_saving:
                    best_extension_saving = saving
                    best_vid = vid
                    best_node = node

    # Find available vehicles for new route (empty routes)
    available_vids = [vid for vid in range(vehicle_num) if len(routes[vid]) == 0]

    # Decide on action based on best extension and threshold
    if has_feasible_extension and best_extension_saving >= saving_threshold:
        # Prefer extending the route with the highest saving >= threshold
        # This appends to the end, producing a valid extension
        return AppendOperator(best_vid, best_node), {}
    elif available_vids:
        # No good extension (saving < threshold) or no extension possible; start a new route if possible
        # Select the unvisited customer closest to depot (minimize initial cost: 2 * dist(depot, node))
        # Since unvisited non-empty (checked earlier), min is safe
        best_node_new = min(unvisited, key=lambda n: distance_matrix[depot][n])
        # Use the first available vehicle ID
        next_vid = min(available_vids)
        # This starts a new valid single-customer route
        return AppendOperator(next_vid, best_node_new), {}
    elif has_feasible_extension:
        # No new route possible, but extensions available; use the best even if saving < threshold
        # Ensures progress toward serving all customers
        return AppendOperator(best_vid, best_node), {}
    else:
        # No feasible extensions and cannot start new route (e.g., no available vehicles, all routes full)
        # Per assumptions, instances are feasible, so this indicates completion or error; return None
        # But only truly complete if unvisited empty (already checked earlier)
        return None, {}
------------------------------------------------------------------------------------

