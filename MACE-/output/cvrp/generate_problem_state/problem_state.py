# This file is generated by generate_problem_state.py.

from src.problems.cvrp.components import Solution


import numpy as np

def get_instance_problem_state(instance_data: dict) -> dict:
    """Extract instance problem state from instance data.

    Args:
        instance_data (dict): The dictionary contains the instance data.

    Returns:
        dict: The dictionary contains the instance problem state with:
            - num_customers (int): The number of customer nodes excluding the depot.
            - total_demand (float): The sum of demands for all customer nodes.
            - demand_cv (float): The coefficient of variation of customer demands (std/mean).
            - avg_depot_distance (float): The average distance from depot to all customers.
            - spatial_clustering (float): The average of minimum distances between each customer and its nearest neighbor customer.
            - capacity_to_total_demand_ratio (float): The ratio of total vehicle capacity (capacity * vehicle_num) to total demand.
    """
    # Extract data from instance_data without modification
    node_num = instance_data['node_num']
    distance_matrix = instance_data['distance_matrix']
    vehicle_num = instance_data['vehicle_num']
    capacity = instance_data['capacity']
    depot = instance_data['depot']
    demands = instance_data['demands']
    
    # Assume depot index is provided, and customers are all other nodes (0 to node_num-1 excluding depot)
    # Typically depot demand is 0, so sum all demands but exclude depot for customer-specific metrics
    customer_indices = np.arange(node_num)
    customer_indices = customer_indices[customer_indices != depot]  # Exclude depot
    num_customers = len(customer_indices)
    
    # Total demand: sum of customer demands only
    customer_demands = demands[customer_indices]
    total_demand = np.sum(customer_demands)
    
    # Demand CV: coefficient of variation for customer demands (exclude depot)
    if num_customers > 0:
        demand_mean = np.mean(customer_demands)
        demand_std = np.std(customer_demands)
        demand_cv = demand_std / demand_mean if demand_mean > 0 else 0.0
    else:
        demand_cv = 0.0
    
    # Average depot distance: mean distance from depot to customers
    depot_to_customers = distance_matrix[depot, customer_indices]
    avg_depot_distance = np.mean(depot_to_customers) if num_customers > 0 else 0.0
    
    # Spatial clustering: average min distance to nearest neighbor for each customer (only among customers)
    spatial_clustering = 0.0
    if num_customers > 1:
        min_dists = []
        for i in customer_indices:
            # Distances from i to other customers (exclude depot and self)
            dists_to_others = distance_matrix[i, customer_indices]
            dists_to_others[i == customer_indices] = np.inf  # Exclude self
            min_dist = np.min(dists_to_others)
            min_dists.append(min_dist)
        spatial_clustering = np.mean(min_dists)
    
    # Capacity to total demand ratio: total capacity / total demand
    total_capacity = capacity * vehicle_num
    capacity_to_total_demand_ratio = total_capacity / total_demand if total_demand > 0 else float('inf')
    
    # Return the problem state dictionary
    return {
        'num_customers': num_customers,
        'total_demand': total_demand,
        'demand_cv': demand_cv,
        'avg_depot_distance': avg_depot_distance,
        'spatial_clustering': spatial_clustering,
        'capacity_to_total_demand_ratio': capacity_to_total_demand_ratio
    }

from src.problems.cvrp.components import Solution
import numpy as np

def get_solution_problem_state(instance_data: dict, solution: Solution) -> dict:
    """Extract solution problem state from instance data and partial solution.

    Args:
        instance_data (dict): The dictionary contains the instance data.
        solution (Solution): The target solution instance.

    Returns:
        dict: The dictionary contains the solution problem state with:
            - served_customers_ratio (float): Ratio of served customers to total customers.
            - total_traveled_distance (float): Total distance traveled in all routes (including partial).
            - vehicles_used (int): Number of non-empty routes (active or complete).
            - avg_load_utilization (float): Average load utilization across used routes.
            - remaining_demand_ratio (float): Ratio of remaining demand to total customer demand.
            - unserved_spatial_clustering (float): Average minimum distance between unserved customers.
            - num_unserved_customers (int): Number of unserved customers.
    """
    # Extract data from instance_data without modification
    node_num = instance_data['node_num']
    distance_matrix = instance_data['distance_matrix']
    vehicle_num = instance_data['vehicle_num']
    capacity = instance_data['capacity']
    depot = instance_data['depot']
    demands = instance_data['demands']
    
    # Extract solution data without modification
    routes = solution.routes
    sol_depot = solution.depot  # Should match instance depot, but use for consistency
    
    # Determine customer indices: all nodes except depot
    customer_indices = np.arange(node_num)
    customer_indices = customer_indices[customer_indices != depot]
    total_customers = len(customer_indices)
    total_customer_demand = np.sum(demands[customer_indices])
    
    # Find served customers: unique customers across all routes
    served_customers = set()
    for route in routes:
        served_customers.update(route)
    num_served = len(served_customers)
    served_customers_ratio = num_served / total_customers if total_customers > 0 else 0.0
    
    # Unserved customers: customers not in served set
    all_customers_set = set(customer_indices)
    unserved_customers = list(all_customers_set - served_customers)
    num_unserved_customers = len(unserved_customers)
    
    # Remaining demand: sum of demands for unserved customers
    remaining_demand = np.sum(demands[unserved_customers]) if unserved_customers else 0.0
    remaining_demand_ratio = remaining_demand / total_customer_demand if total_customer_demand > 0 else 0.0
    
    # Vehicles used: count non-empty routes
    vehicles_used = sum(1 for route in routes if route)  # Non-empty routes are used
    
    # Total traveled distance: for each route, compute depot -> route -> depot distance
    total_traveled_distance = 0.0
    for route in routes:
        if not route:
            continue  # Empty route contributes 0
        # Full route: depot -> first -> ... -> last -> depot
        route_dist = distance_matrix[sol_depot, route[0]]  # depot to first
        for i in range(len(route) - 1):
            route_dist += distance_matrix[route[i], route[i + 1]]  # consecutive
        route_dist += distance_matrix[route[-1], sol_depot]  # last to depot
        total_traveled_distance += route_dist
    
    # Average load utilization: for each non-empty route, load / capacity, then average
    load_utilizations = []
    for route in routes:
        if not route:
            continue
        route_load = np.sum(demands[route])
        load_util = route_load / capacity if capacity > 0 else 0.0
        load_utilizations.append(load_util)
    avg_load_utilization = np.mean(load_utilizations) if load_utilizations else 0.0
    
    # Unserved spatial clustering: average min distance to nearest unserved neighbor
    unserved_spatial_clustering = 0.0
    if len(unserved_customers) > 1:
        min_dists = []
        for i in unserved_customers:
            # Distances to other unserved (exclude self)
            dists_to_others = distance_matrix[i, unserved_customers]
            dists_to_others[unserved_customers.index(i)] = np.inf  # Exclude self
            min_dist = np.min(dists_to_others)
            min_dists.append(min_dist)
        unserved_spatial_clustering = np.mean(min_dists)
    
    # Return the solution problem state dictionary
    return {
        'served_customers_ratio': served_customers_ratio,
        'total_traveled_distance': total_traveled_distance,
        'vehicles_used': vehicles_used,
        'avg_load_utilization': avg_load_utilization,
        'remaining_demand_ratio': remaining_demand_ratio,
        'unserved_spatial_clustering': unserved_spatial_clustering,
        'num_unserved_customers': num_unserved_customers
    }

def get_observation_problem_state(solution_problem_state: dict) -> dict:
    """Extract core problem state as observation.

    Args:
        solution_problem_state (dict): The dictionary contains the solution problem state.

    Returns:
        dict: The dictionary contains the core problem state with keys:
            - served_customers_ratio (float): Ratio of served customers.
            - total_traveled_distance (float): Total distance in the solution.
            - vehicles_used (int): Number of used vehicles.
            - remaining_demand_ratio (float): Ratio of remaining demand.
            - num_unserved_customers (int): Number of unserved customers.
    """
    # Extract only the selected core states from the input dictionary without modification
    # This creates a lightweight observation for tracking changes during solution evolution
    return {
        'served_customers_ratio': solution_problem_state['served_customers_ratio'],
        'total_traveled_distance': solution_problem_state['total_traveled_distance'],
        'vehicles_used': solution_problem_state['vehicles_used'],
        'remaining_demand_ratio': solution_problem_state['remaining_demand_ratio'],
        'num_unserved_customers': solution_problem_state['num_unserved_customers']
    }