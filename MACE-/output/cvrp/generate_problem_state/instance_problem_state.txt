user
I am working on Hyper-heuristics for Combinatorial Operation (CO) problem.

Currently, I am working on cvrp problem:
Capacitated Vehicle Routing Problem (CVRP) is an optimization challenge focused on determining the most efficient routes for a fleet of vehicles to deliver goods to various locations, considering vehicle capacity constraints.


Please consider is cvrp a combinatorial operation problem and can be solved by heuristics?
If you think this problem is not a combinatorial operation problem or the solution, operator, data are incorrect, response ***is_cop:no*** to me, or response ***is_cop:yes***.

The response format is very important. For better communication, please respond to me in this format:
***is_cop:yes/no***
Ensure there is no other content inside the ***, and analysis outside *** is welcome.
If you have no information to provide, simply respond with ***None***.
------------------------------------------------------------------------------------

assistant
***is_cop:yes***

Yes, the Capacitated Vehicle Routing Problem (CVRP) is indeed a combinatorial optimization (CO) problem. It involves discrete decision-making, such as selecting routes and assignments for vehicles from a finite set of possibilities, while optimizing objectives like total distance or cost under constraints like capacity limits. CVRP is NP-hard, making exact solutions computationally intensive for large instances, so heuristics (e.g., nearest neighbor, Clarke-Wright savings algorithm, genetic algorithms, or tabu search) and metaheuristics are widely used and effective for solving it in practice. Hyper-heuristics, which select or generate heuristics at a higher level, are also a promising approach for tackling CVRP variations. If your work involves specific operators, data, or solution representations, feel free to share more details for further discussion!
------------------------------------------------------------------------------------

user
We aim to collaboratively create the functions to generate some problem states(statistics data), which captures the high-level features of problem instance for the cvrp. 

These functions will be underpinned by rigorous statistical analysis and domain-specific knowledge, ensuring they are both accurate and relevant.


In determining the optimal problem states to represent instance, we must adhere to the following criteria:
1. The data representation should be succinct to minimize computational load while retaining sufficient granularity to recognize the feature of the problem and solution.
2. It must incorporate unique attributes that aid in the clear distinction between different instances.
3. The most important, these data only focus on instance and has nothing to do with solution.

Now, please tell me which statistical data are best serve as instance problem state.

The response format is very important. For better communication, please respond to me in this format:
***instance_problem_state:
problem_state_name;how_to_calculate;reason
problem_state_name;how_to_calculate;reason
....
***
Ensure there is no other content inside the ***, and analysis outside *** is welcome.
If you have no information to provide, simply respond with ***None***.
------------------------------------------------------------------------------------

assistant
***instance_problem_state:
num_customers;count the total number of customer nodes (excluding depot);Provides a basic measure of problem scale, essential for distinguishing small vs. large instances without computational overhead.
total_demand;sum of all customer demands;Captures the overall delivery volume, helping differentiate instances with light vs. heavy loads relative to capacity.
demand_cv;standard deviation of customer demands divided by their mean (coefficient of variation);Quantifies demand variability, allowing distinction between uniform and skewed demand distributions, which impacts route feasibility.
avg_depot_distance;average Euclidean distance from depot to all customer locations;Indicates spatial extent from the starting point, useful for separating clustered (low value) vs. dispersed (high value) geographic layouts.
spatial_clustering;average distance between each customer and its nearest neighbor, then averaged over all customers;Measures local density, enabling differentiation of clustered vs. uniformly spread customer distributions.
capacity_to_total_demand_ratio;vehicle capacity divided by total demand (or by total demand divided by a fixed fleet size if specified in instance);Highlights relative tightness of capacity constraints, distinguishing easy (high ratio) vs. tight (low ratio) instances without referencing solutions.
***

These suggested problem states are derived from standard CVRP instance characteristics (locations, demands, and capacity) and are commonly used in empirical analyses and hyper-heuristic frameworks for VRP to abstract instance features. They are computationally efficient (O(n) or O(n log n) at worst for distances) and focus solely on the input data, avoiding any solution-dependent metrics like route lengths. For spatial features, assuming Euclidean distances based on coordinates, which is typical in benchmark instances like Solomon or Christofides. If your instances include specific formats (e.g., TSPLIB), these can be adapted; let me know for refinements or code snippets to compute them!
------------------------------------------------------------------------------------

user
Try to implement the get_instance_problem_state function in python:
def get_instance_problem_state(instance_data: dict) -> dict:

The input is instance_data
- node_num (int): The total number of nodes in the problem.
    - distance_matrix (numpy.ndarray): A 2D array representing the distances between nodes.
    - vehicle_num (int): The total number of vehicles.
    - capacity (int): The capacity for each vehicle and all vehicles share the same value.
    - depot (int): The index for depot node.
    - demands (numpy.ndarray): The demand of each node.

The output is algo a dict, which contains the following problem states as keys: num_customers,total_demand,demand_cv,avg_depot_distance,spatial_clustering,capacity_to_total_demand_ratio.

Please note:
1. Never modify the instance_data.
2. The name of function must be get_instance_problem_state.
3. No any omissions or placeholders, I'm just going to use the code.
4. Comments in the code are very important.


The response format is very important. For better communication, please respond to me in this format:
***python_code:
import library (if necessary)
def get_instance_problem_state(instance_data: dict) -> dict:
    """Extract instance problem state from instance data.

    Args:
        instance_data (dict): The dictionary contains the instance data.

    Returns:
        dict: The dictionary contains the instance problem state with:
            - problem_state_name (type): description
            - problem_state_name (type): description
            ...
    """
    ...
***
Ensure there is no other content inside the ***, and analysis outside *** is welcome.
If you have no information to provide, simply respond with ***None***.
------------------------------------------------------------------------------------

assistant
***python_code:
import numpy as np

def get_instance_problem_state(instance_data: dict) -> dict:
    """Extract instance problem state from instance data.

    Args:
        instance_data (dict): The dictionary contains the instance data.

    Returns:
        dict: The dictionary contains the instance problem state with:
            - num_customers (int): The number of customer nodes excluding the depot.
            - total_demand (float): The sum of demands for all customer nodes.
            - demand_cv (float): The coefficient of variation of customer demands (std/mean).
            - avg_depot_distance (float): The average distance from depot to all customers.
            - spatial_clustering (float): The average of minimum distances between each customer and its nearest neighbor customer.
            - capacity_to_total_demand_ratio (float): The ratio of total vehicle capacity (capacity * vehicle_num) to total demand.
    """
    # Extract data from instance_data without modification
    node_num = instance_data['node_num']
    distance_matrix = instance_data['distance_matrix']
    vehicle_num = instance_data['vehicle_num']
    capacity = instance_data['capacity']
    depot = instance_data['depot']
    demands = instance_data['demands']
    
    # Assume depot index is provided, and customers are all other nodes (0 to node_num-1 excluding depot)
    # Typically depot demand is 0, so sum all demands but exclude depot for customer-specific metrics
    customer_indices = np.arange(node_num)
    customer_indices = customer_indices[customer_indices != depot]  # Exclude depot
    num_customers = len(customer_indices)
    
    # Total demand: sum of customer demands only
    customer_demands = demands[customer_indices]
    total_demand = np.sum(customer_demands)
    
    # Demand CV: coefficient of variation for customer demands (exclude depot)
    if num_customers > 0:
        demand_mean = np.mean(customer_demands)
        demand_std = np.std(customer_demands)
        demand_cv = demand_std / demand_mean if demand_mean > 0 else 0.0
    else:
        demand_cv = 0.0
    
    # Average depot distance: mean distance from depot to customers
    depot_to_customers = distance_matrix[depot, customer_indices]
    avg_depot_distance = np.mean(depot_to_customers) if num_customers > 0 else 0.0
    
    # Spatial clustering: average min distance to nearest neighbor for each customer (only among customers)
    spatial_clustering = 0.0
    if num_customers > 1:
        min_dists = []
        for i in customer_indices:
            # Distances from i to other customers (exclude depot and self)
            dists_to_others = distance_matrix[i, customer_indices]
            dists_to_others[i == customer_indices] = np.inf  # Exclude self
            min_dist = np.min(dists_to_others)
            min_dists.append(min_dist)
        spatial_clustering = np.mean(min_dists)
    
    # Capacity to total demand ratio: total capacity / total demand
    total_capacity = capacity * vehicle_num
    capacity_to_total_demand_ratio = total_capacity / total_demand if total_demand > 0 else float('inf')
    
    # Return the problem state dictionary
    return {
        'num_customers': num_customers,
        'total_demand': total_demand,
        'demand_cv': demand_cv,
        'avg_depot_distance': avg_depot_distance,
        'spatial_clustering': spatial_clustering,
        'capacity_to_total_demand_ratio': capacity_to_total_demand_ratio
    }
***

This implementation assumes the distance_matrix is symmetric and uses Euclidean or precomputed distances as provided. It handles edge cases like no customers (though unlikely for CVRP) by setting sensible defaults (e.g., 0 or inf). Customer indices are dynamically computed to exclude the depot, making it flexible if depot isn't at index 0. Computations are efficient: O(n) for most, O(n^2) for spatial_clustering (acceptable for typical CVRP sizes <1000 nodes). If your instances have depot demand non-zero or specific indexing, minor tweaks might be needed, but this should integrate directly. Test with sample data to verify!
------------------------------------------------------------------------------------

