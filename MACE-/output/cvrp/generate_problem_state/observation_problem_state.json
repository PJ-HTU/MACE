[
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "I am working on Hyper-heuristics for Combinatorial Operation (CO) problem.\n\nCurrently, I am working on cvrp problem:\nCapacitated Vehicle Routing Problem (CVRP) is an optimization challenge focused on determining the most efficient routes for a fleet of vehicles to deliver goods to various locations, considering vehicle capacity constraints.\n\n\nPlease consider is cvrp a combinatorial operation problem and can be solved by heuristics?\nIf you think this problem is not a combinatorial operation problem or the solution, operator, data are incorrect, response ***is_cop:no*** to me, or response ***is_cop:yes***.\n\nThe response format is very important. For better communication, please respond to me in this format:\n***is_cop:yes/no***\nEnsure there is no other content inside the ***, and analysis outside *** is welcome.\nIf you have no information to provide, simply respond with ***None***."
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***is_cop:yes***\n\nYes, the Capacitated Vehicle Routing Problem (CVRP) is indeed a combinatorial optimization (CO) problem. It involves discrete decision-making, such as selecting routes and assignments for vehicles from a finite set of possibilities, while optimizing objectives like total distance or cost under constraints like capacity limits. CVRP is NP-hard, making exact solutions computationally intensive for large instances, so heuristics (e.g., nearest neighbor, Clarke-Wright savings algorithm, genetic algorithms, or tabu search) and metaheuristics are widely used and effective for solving it in practice. Hyper-heuristics, which select or generate heuristics at a higher level, are also a promising approach for tackling CVRP variations. If your work involves specific operators, data, or solution representations, feel free to share more details for further discussion!"
            }
        ]
    },
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "We aim to collaboratively create the functions to generate some problem states(statistics data), which captures the high-level features of problem instance for the cvrp. \n\nThese functions will be underpinned by rigorous statistical analysis and domain-specific knowledge, ensuring they are both accurate and relevant.\n\n\nIn determining the optimal problem states to represent instance, we must adhere to the following criteria:\n1. The data representation should be succinct to minimize computational load while retaining sufficient granularity to recognize the feature of the problem and solution.\n2. It must incorporate unique attributes that aid in the clear distinction between different instances.\n3. The most important, these data only focus on instance and has nothing to do with solution.\n\nNow, please tell me which statistical data are best serve as instance problem state.\n\nThe response format is very important. For better communication, please respond to me in this format:\n***instance_problem_state:\nproblem_state_name;how_to_calculate;reason\nproblem_state_name;how_to_calculate;reason\n....\n***\nEnsure there is no other content inside the ***, and analysis outside *** is welcome.\nIf you have no information to provide, simply respond with ***None***."
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***instance_problem_state:\nnum_customers;count the total number of customer nodes (excluding depot);Provides a basic measure of problem scale, essential for distinguishing small vs. large instances without computational overhead.\ntotal_demand;sum of all customer demands;Captures the overall delivery volume, helping differentiate instances with light vs. heavy loads relative to capacity.\ndemand_cv;standard deviation of customer demands divided by their mean (coefficient of variation);Quantifies demand variability, allowing distinction between uniform and skewed demand distributions, which impacts route feasibility.\navg_depot_distance;average Euclidean distance from depot to all customer locations;Indicates spatial extent from the starting point, useful for separating clustered (low value) vs. dispersed (high value) geographic layouts.\nspatial_clustering;average distance between each customer and its nearest neighbor, then averaged over all customers;Measures local density, enabling differentiation of clustered vs. uniformly spread customer distributions.\ncapacity_to_total_demand_ratio;vehicle capacity divided by total demand (or by total demand divided by a fixed fleet size if specified in instance);Highlights relative tightness of capacity constraints, distinguishing easy (high ratio) vs. tight (low ratio) instances without referencing solutions.\n***\n\nThese suggested problem states are derived from standard CVRP instance characteristics (locations, demands, and capacity) and are commonly used in empirical analyses and hyper-heuristic frameworks for VRP to abstract instance features. They are computationally efficient (O(n) or O(n log n) at worst for distances) and focus solely on the input data, avoiding any solution-dependent metrics like route lengths. For spatial features, assuming Euclidean distances based on coordinates, which is typical in benchmark instances like Solomon or Christofides. If your instances include specific formats (e.g., TSPLIB), these can be adapted; let me know for refinements or code snippets to compute them!"
            }
        ]
    },
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "Try to implement the get_instance_problem_state function in python:\ndef get_instance_problem_state(instance_data: dict) -> dict:\n\nThe input is instance_data\n- node_num (int): The total number of nodes in the problem.\n    - distance_matrix (numpy.ndarray): A 2D array representing the distances between nodes.\n    - vehicle_num (int): The total number of vehicles.\n    - capacity (int): The capacity for each vehicle and all vehicles share the same value.\n    - depot (int): The index for depot node.\n    - demands (numpy.ndarray): The demand of each node.\n\nThe output is algo a dict, which contains the following problem states as keys: num_customers,total_demand,demand_cv,avg_depot_distance,spatial_clustering,capacity_to_total_demand_ratio.\n\nPlease note:\n1. Never modify the instance_data.\n2. The name of function must be get_instance_problem_state.\n3. No any omissions or placeholders, I'm just going to use the code.\n4. Comments in the code are very important.\n\n\nThe response format is very important. For better communication, please respond to me in this format:\n***python_code:\nimport library (if necessary)\ndef get_instance_problem_state(instance_data: dict) -> dict:\n    \"\"\"Extract instance problem state from instance data.\n\n    Args:\n        instance_data (dict): The dictionary contains the instance data.\n\n    Returns:\n        dict: The dictionary contains the instance problem state with:\n            - problem_state_name (type): description\n            - problem_state_name (type): description\n            ...\n    \"\"\"\n    ...\n***\nEnsure there is no other content inside the ***, and analysis outside *** is welcome.\nIf you have no information to provide, simply respond with ***None***."
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***python_code:\nimport numpy as np\n\ndef get_instance_problem_state(instance_data: dict) -> dict:\n    \"\"\"Extract instance problem state from instance data.\n\n    Args:\n        instance_data (dict): The dictionary contains the instance data.\n\n    Returns:\n        dict: The dictionary contains the instance problem state with:\n            - num_customers (int): The number of customer nodes excluding the depot.\n            - total_demand (float): The sum of demands for all customer nodes.\n            - demand_cv (float): The coefficient of variation of customer demands (std/mean).\n            - avg_depot_distance (float): The average distance from depot to all customers.\n            - spatial_clustering (float): The average of minimum distances between each customer and its nearest neighbor customer.\n            - capacity_to_total_demand_ratio (float): The ratio of total vehicle capacity (capacity * vehicle_num) to total demand.\n    \"\"\"\n    # Extract data from instance_data without modification\n    node_num = instance_data['node_num']\n    distance_matrix = instance_data['distance_matrix']\n    vehicle_num = instance_data['vehicle_num']\n    capacity = instance_data['capacity']\n    depot = instance_data['depot']\n    demands = instance_data['demands']\n    \n    # Assume depot index is provided, and customers are all other nodes (0 to node_num-1 excluding depot)\n    # Typically depot demand is 0, so sum all demands but exclude depot for customer-specific metrics\n    customer_indices = np.arange(node_num)\n    customer_indices = customer_indices[customer_indices != depot]  # Exclude depot\n    num_customers = len(customer_indices)\n    \n    # Total demand: sum of customer demands only\n    customer_demands = demands[customer_indices]\n    total_demand = np.sum(customer_demands)\n    \n    # Demand CV: coefficient of variation for customer demands (exclude depot)\n    if num_customers > 0:\n        demand_mean = np.mean(customer_demands)\n        demand_std = np.std(customer_demands)\n        demand_cv = demand_std / demand_mean if demand_mean > 0 else 0.0\n    else:\n        demand_cv = 0.0\n    \n    # Average depot distance: mean distance from depot to customers\n    depot_to_customers = distance_matrix[depot, customer_indices]\n    avg_depot_distance = np.mean(depot_to_customers) if num_customers > 0 else 0.0\n    \n    # Spatial clustering: average min distance to nearest neighbor for each customer (only among customers)\n    spatial_clustering = 0.0\n    if num_customers > 1:\n        min_dists = []\n        for i in customer_indices:\n            # Distances from i to other customers (exclude depot and self)\n            dists_to_others = distance_matrix[i, customer_indices]\n            dists_to_others[i == customer_indices] = np.inf  # Exclude self\n            min_dist = np.min(dists_to_others)\n            min_dists.append(min_dist)\n        spatial_clustering = np.mean(min_dists)\n    \n    # Capacity to total demand ratio: total capacity / total demand\n    total_capacity = capacity * vehicle_num\n    capacity_to_total_demand_ratio = total_capacity / total_demand if total_demand > 0 else float('inf')\n    \n    # Return the problem state dictionary\n    return {\n        'num_customers': num_customers,\n        'total_demand': total_demand,\n        'demand_cv': demand_cv,\n        'avg_depot_distance': avg_depot_distance,\n        'spatial_clustering': spatial_clustering,\n        'capacity_to_total_demand_ratio': capacity_to_total_demand_ratio\n    }\n***\n\nThis implementation assumes the distance_matrix is symmetric and uses Euclidean or precomputed distances as provided. It handles edge cases like no customers (though unlikely for CVRP) by setting sensible defaults (e.g., 0 or inf). Customer indices are dynamically computed to exclude the depot, making it flexible if depot isn't at index 0. Computations are efficient: O(n) for most, O(n^2) for spatial_clustering (acceptable for typical CVRP sizes <1000 nodes). If your instances have depot demand non-zero or specific indexing, minor tweaks might be needed, but this should integrate directly. Test with sample data to verify!"
            }
        ]
    },
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "Now, we aim to collaboratively create the functions to generate some problem states(statistics data), which captures the high-level features of current (partial) solution for the cvrp.\n\nThese functions will be underpinned by rigorous statistical analysis and domain-specific knowledge, ensuring they are both accurate and relevant.\n\n\nIn determining the optimal problem states to represent instance, we must adhere to the following criteria:\n1. The data representation should be succinct to minimize computational load while retaining sufficient granularity to recognize the solution feature.\n2. It must incorporate unique attributes that aid in the clear distinction between different solution stage.\n3. We need to evaluate the current status from multiple dimensions, including the current progress of the solution, the quality of the solution, the status of the remaining data, etc.\n4. The most important, these data relates to both instance and current solution, and will update during the problem solving process.\n\nNow, please tell me which statistical data are best serve as solution problem state.\n\nThe response format is very important. For better communication, please respond to me in this format:\n***solution_problem_state:\nproblem_state_name;how_to_calculate;reason\nproblem_state_name;how_to_calculate;reason\n....\n***\nEnsure there is no other content inside the ***, and analysis outside *** is welcome.\nIf you have no information to provide, simply respond with ***None***."
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***solution_problem_state:\nserved_customers_ratio;(number of served customers) / total number of customers;Quantifies solution progress by coverage percentage, distinguishing early (low ratio) from advanced (high ratio) stages succinctly.\ntotal_traveled_distance;sum of distances for all complete routes plus distances in partial (active) routes;Captures accumulated solution quality/cost, allowing differentiation of efficient vs. inefficient partial builds without full recomputation.\nvehicles_used;number of complete routes + number of active (partial) routes;Measures resource utilization progress, highlighting stages where fleet commitment is low (exploration) vs. high (commitment).\navg_load_utilization;average of (current load / capacity) across all active and complete routes, weighted by route length if needed;Evaluates packing efficiency in the partial solution, distinguishing well-utilized (high) from wasteful (low) load states for quality assessment.\nremaining_demand_ratio;total demand of unserved customers / total customer demand;Indicates remaining workload intensity, aiding distinction between demand-heavy early stages and near-complete phases.\nunserved_spatial_clustering;average minimum distance to nearest unserved neighbor among unserved customers;Assesses the spatial challenge of leftovers, differentiating clustered (easier to route) vs. dispersed (harder) remaining instances for strategic decisions.\nnum_unserved_customers;total number of unserved customers;Provides a direct count of progress gap, succinct for tracking solution advancement and remaining combinatorial complexity.\n***\n\nThese solution problem states build on the instance features previously defined, assuming access to partial solution data like route lists (with nodes, loads, distances), served/unserved sets, and integration with instance_data (e.g., demands, distances). They are designed for dynamic updates during heuristics (e.g., after adding a customer to a route), with low overhead (O(1) updates if incrementally maintained, O(m) for spatial where m is unserved count). Dimensions covered: progress (served/remaining ratios), quality (distance/load), and remaining status (unserved metrics). In CVRP hyper-heuristics, such states are useful for selecting operators (e.g., favor insertions if unserved clustering is low). If your solution representation differs (e.g., specific route data structure), these calculations can be adapted\u2014share details for refinements!"
            }
        ]
    },
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "Try to implement the get_solution_problem_state function in python:\ndef get_solution_problem_state(instance_data: dict, solution: Solution) -> dict:\n\nThe input is instance_data:\n- node_num (int): The total number of nodes in the problem.\n    - distance_matrix (numpy.ndarray): A 2D array representing the distances between nodes.\n    - vehicle_num (int): The total number of vehicles.\n    - capacity (int): The capacity for each vehicle and all vehicles share the same value.\n    - depot (int): The index for depot node.\n    - demands (numpy.ndarray): The demand of each node.\nThe format of solution is already defined as:\nclass Solution:\n    \"\"\"The solution of CVRP.\nA list of lists where each sublist represents a vehicle's route.\nEach sublist contains integers representing the nodes (customers) visited by the vehicle in the order of visitation.\nThe routes are sorted by vehicle identifier and the nodes in the list sorted by visited order.\"\"\"\n    def __init__(self, routes: list[list[int]], depot: int):\n        self.routes = routes\n        self.depot = depot\n\nThe output is algo a dict, which contains the following problem states as keys: served_customers_ratio,total_traveled_distance,vehicles_used,avg_load_utilization,remaining_demand_ratio,unserved_spatial_clustering,num_unserved_customers.\n\nPlease note:\n1. Never modify the instance_data and solution.\n2. The name of function must be get_solution_problem_state.\n3. No any omissions or placeholders, I'm just going to use the code.\n4. Comments in the code are very important.\n5. The solution is already defined, do not implement it again.\n\nThe response format is very important. For better communication, please respond to me in this format:\n***python_code:\nimport library (if necessary)\ndef get_solution_problem_state(instance_data: dict, solution: Solution) -> dict:\n    \"\"\"Extract instance problem state from instance data.\n\n    Args:\n        instance_data (dict): The dictionary contains the instance data.\n        solution (Solution): The target solution instance.\n    Returns:\n        dict: The dictionary contains the instance problem state with:\n            - problem_state_name (type): description\n            - problem_state_name (type): description\n            ...\n    \"\"\"\n    ...\n***\nEnsure there is no other content inside the ***, and analysis outside *** is welcome.\nIf you have no information to provide, simply respond with ***None***."
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***python_code:\nimport numpy as np\n\ndef get_solution_problem_state(instance_data: dict, solution: Solution) -> dict:\n    \"\"\"Extract solution problem state from instance data and partial solution.\n\n    Args:\n        instance_data (dict): The dictionary contains the instance data.\n        solution (Solution): The target solution instance.\n\n    Returns:\n        dict: The dictionary contains the solution problem state with:\n            - served_customers_ratio (float): Ratio of served customers to total customers.\n            - total_traveled_distance (float): Total distance traveled in all routes (including partial).\n            - vehicles_used (int): Number of non-empty routes (active or complete).\n            - avg_load_utilization (float): Average load utilization across used routes.\n            - remaining_demand_ratio (float): Ratio of remaining demand to total customer demand.\n            - unserved_spatial_clustering (float): Average minimum distance between unserved customers.\n            - num_unserved_customers (int): Number of unserved customers.\n    \"\"\"\n    # Extract data from instance_data without modification\n    node_num = instance_data['node_num']\n    distance_matrix = instance_data['distance_matrix']\n    vehicle_num = instance_data['vehicle_num']\n    capacity = instance_data['capacity']\n    depot = instance_data['depot']\n    demands = instance_data['demands']\n    \n    # Extract solution data without modification\n    routes = solution.routes\n    sol_depot = solution.depot  # Should match instance depot, but use for consistency\n    \n    # Determine customer indices: all nodes except depot\n    customer_indices = np.arange(node_num)\n    customer_indices = customer_indices[customer_indices != depot]\n    total_customers = len(customer_indices)\n    total_customer_demand = np.sum(demands[customer_indices])\n    \n    # Find served customers: unique customers across all routes\n    served_customers = set()\n    for route in routes:\n        served_customers.update(route)\n    num_served = len(served_customers)\n    served_customers_ratio = num_served / total_customers if total_customers > 0 else 0.0\n    \n    # Unserved customers: customers not in served set\n    all_customers_set = set(customer_indices)\n    unserved_customers = list(all_customers_set - served_customers)\n    num_unserved_customers = len(unserved_customers)\n    \n    # Remaining demand: sum of demands for unserved customers\n    remaining_demand = np.sum(demands[unserved_customers]) if unserved_customers else 0.0\n    remaining_demand_ratio = remaining_demand / total_customer_demand if total_customer_demand > 0 else 0.0\n    \n    # Vehicles used: count non-empty routes\n    vehicles_used = sum(1 for route in routes if route)  # Non-empty routes are used\n    \n    # Total traveled distance: for each route, compute depot -> route -> depot distance\n    total_traveled_distance = 0.0\n    for route in routes:\n        if not route:\n            continue  # Empty route contributes 0\n        # Full route: depot -> first -> ... -> last -> depot\n        route_dist = distance_matrix[sol_depot, route[0]]  # depot to first\n        for i in range(len(route) - 1):\n            route_dist += distance_matrix[route[i], route[i + 1]]  # consecutive\n        route_dist += distance_matrix[route[-1], sol_depot]  # last to depot\n        total_traveled_distance += route_dist\n    \n    # Average load utilization: for each non-empty route, load / capacity, then average\n    load_utilizations = []\n    for route in routes:\n        if not route:\n            continue\n        route_load = np.sum(demands[route])\n        load_util = route_load / capacity if capacity > 0 else 0.0\n        load_utilizations.append(load_util)\n    avg_load_utilization = np.mean(load_utilizations) if load_utilizations else 0.0\n    \n    # Unserved spatial clustering: average min distance to nearest unserved neighbor\n    unserved_spatial_clustering = 0.0\n    if len(unserved_customers) > 1:\n        min_dists = []\n        for i in unserved_customers:\n            # Distances to other unserved (exclude self)\n            dists_to_others = distance_matrix[i, unserved_customers]\n            dists_to_others[unserved_customers.index(i)] = np.inf  # Exclude self\n            min_dist = np.min(dists_to_others)\n            min_dists.append(min_dist)\n        unserved_spatial_clustering = np.mean(min_dists)\n    \n    # Return the solution problem state dictionary\n    return {\n        'served_customers_ratio': served_customers_ratio,\n        'total_traveled_distance': total_traveled_distance,\n        'vehicles_used': vehicles_used,\n        'avg_load_utilization': avg_load_utilization,\n        'remaining_demand_ratio': remaining_demand_ratio,\n        'unserved_spatial_clustering': unserved_spatial_clustering,\n        'num_unserved_customers': num_unserved_customers\n    }\n***\n\nThis implementation treats the solution as partial by considering only the customers in the routes as served, with distances computed for full round-trip routes (depot-inclusive, even if partial). It assumes routes contain only customer indices (no depot in lists), no duplicates across routes, and symmetric distance_matrix. Edge cases are handled: empty solution (all ratios 0, distances 0), no unserved (clustering 0), zero capacity/demand (avoids division by zero). Computations are efficient: O(total_customers + sum route lengths + O(u^2) for unserved clustering, where u is unserved count). For full solutions, unserved metrics will be 0. If your partial solutions include open routes or different conventions (e.g., partial without closing to depot), the distance calculation can be adjusted\u2014let me know for tweaks!"
            }
        ]
    },
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "Then, we need to filter some core problem state in solution problem state to record the changes of solution, please select some problem state in solution problem state.\n\n\nIn determining the optimal problem states to represent instance, we must adhere to the following criteria:\n1. Must select from solution problem state, not instance problem state\n\n\nThe response format is very important. For better communication, please respond to me in this format:\n***observation_problem_state:\nproblem_state_name;\nproblem_state_name;\n....\n***\nEnsure there is no other content inside the ***, and analysis outside *** is welcome.\nIf you have no information to provide, simply respond with ***None***."
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***observation_problem_state:\nserved_customers_ratio;\ntotal_traveled_distance;\nvehicles_used;\nremaining_demand_ratio;\nnum_unserved_customers;\n***\n\nThese selected states form a core subset focused on tracking solution evolution: progress (served_customers_ratio, num_unserved_customers), accumulated quality/cost (total_traveled_distance), resource commitment (vehicles_used), and remaining workload (remaining_demand_ratio). They exclude more computationally intensive or less dynamic features like avg_load_utilization (which stabilizes per route) and unserved_spatial_clustering (updates less frequently but is heavier to recompute). This keeps monitoring lightweight while capturing multi-dimensional changes during heuristic iterations, ideal for logging or hyper-heuristic decision-making. If you need more/fewer or specific rationale adjustments, let me know!"
            }
        ]
    },
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "Try to implement the get_observation_problem_state function in python:\ndef get_observation_problem_state(solution_problem_state: dict) -> dict:\n\nThe input is solution_problem_state.\n\nThe output is algo a dict, which contains the following problem states as keys: served_customers_ratio,total_traveled_distance,vehicles_used,remaining_demand_ratio,num_unserved_customers.\n\nPlease note:\n1. Just take it from solution_problem_state without modify it.\n2. The name of function must be get_observation_problem_state.\n3. No any omissions or placeholders, I'm just going to use the code.\n4. Comments in the code are very important.\n\n\nThe response format is very important. For better communication, please respond to me in this format:\n***python_code:\nimport library (if necessary)\n\ndef get_observation_problem_state(solution_problem_state: dict) -> dict:\n    \"\"\"Extract core problem state as observation.\n\n    Args:\n        solution_problem_state (dict): The dictionary contains the solution problem state.\n\n    Returns:\n        dict: The dictionary contains the core problem state.\n    \"\"\"\n    return {\n        \"xxx\": problem_state_name[\"xxx\"],\n        \"xxx\": problem_state_name[\"xxx\"],\n    }\n***\nEnsure there is no other content inside the ***, and analysis outside *** is welcome.\nIf you have no information to provide, simply respond with ***None***."
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***python_code:\ndef get_observation_problem_state(solution_problem_state: dict) -> dict:\n    \"\"\"Extract core problem state as observation.\n\n    Args:\n        solution_problem_state (dict): The dictionary contains the solution problem state.\n\n    Returns:\n        dict: The dictionary contains the core problem state with keys:\n            - served_customers_ratio (float): Ratio of served customers.\n            - total_traveled_distance (float): Total distance in the solution.\n            - vehicles_used (int): Number of used vehicles.\n            - remaining_demand_ratio (float): Ratio of remaining demand.\n            - num_unserved_customers (int): Number of unserved customers.\n    \"\"\"\n    # Extract only the selected core states from the input dictionary without modification\n    # This creates a lightweight observation for tracking changes during solution evolution\n    return {\n        'served_customers_ratio': solution_problem_state['served_customers_ratio'],\n        'total_traveled_distance': solution_problem_state['total_traveled_distance'],\n        'vehicles_used': solution_problem_state['vehicles_used'],\n        'remaining_demand_ratio': solution_problem_state['remaining_demand_ratio'],\n        'num_unserved_customers': solution_problem_state['num_unserved_customers']\n    }\n***\n\nThis function simply subsets the input dictionary to the core observation states, ensuring no data modification and O(1) efficiency. It's ideal for repeated calls in iterative solvers or logging, as it avoids recomputation. If the input lacks a key (unlikely if upstream functions are correct), it will raise a KeyError\u2014add checks if robustness is needed, but per instructions, kept minimal."
            }
        ]
    }
]