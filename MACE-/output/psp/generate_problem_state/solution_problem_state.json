[
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "I am working on Hyper-heuristics for Combinatorial Operation (CO) problem.\n\nCurrently, I am working on psp problem:\nPort Scheduling Problem (PSP) - Mathematical Model Description\n\nProblem Overview\n\nThe Port Scheduling Problem (PSP) involves optimal allocation of vessels to berths with coordinated tugboat services. The system manages multiple berths with different capacity levels, multiple tugboats with varying horsepower capabilities, and multiple vessels with specific requirements and time constraints.\n\nKey Problem Characteristics\n\nEach vessel must receive three sequential services if allocated:\n1. Inbound tugboat service - to guide vessel to berth\n2. Berthing service - vessel occupies berth for cargo operations\n3. Outbound tugboat service - to guide vessel away from berth\n\nThe services must be properly sequenced and temporally connected within allowable time tolerances. Vessels that cannot receive complete service are penalized heavily.\n\nMathematical Model Formulation\n\nDecision Variables\n- x_ijt \u2208 {0,1}: vessel i starts berthing at berth j at time t (only if berth capacity C\u2c7c \u2265 vessel size S\u1d62)\n- y^in_ikt \u2208 {0,1}: tugboat k starts inbound service for vessel i at time t\n- y^out_ikt \u2208 {0,1}: tugboat k starts outbound service for vessel i at time t\n- z^in_it \u2208 {0,1}: auxiliary variable indicating vessel i starts inbound tugboat service at time t\n- z^out_it \u2208 {0,1}: auxiliary variable indicating vessel i starts outbound tugboat service at time t\n- u^early_i \u2265 0: early deviation from ETA for vessel i\n- u^late_i \u2265 0: late deviation from ETA for vessel i\n\nObjective Function\nMinimize: \u03bb\u2081Z\u2081 + \u03bb\u2082Z\u2082 + \u03bb\u2083Z\u2083 + \u03bb\u2084Z\u2084\n\nWhere:\n- Z\u2081 = \u03a3\u1d62 M\u00b7\u03b1\u1d62\u00b7(1 - \u03a3\u2c7c \u03a3\u209c x_ijt) [Unserved vessel penalty]\n- Z\u2082 = \u03a3\u1d62 \u03b1\u1d62\u00b7\u03b2\u1d62\u00b7[\u03a3\u209c (t + \u03c4^out_i)\u00b7z^out_it - \u03a3\u209c t\u00b7z^in_it] [Total port time cost]\n- Z\u2083 = \u03a3\u1d62 \u03b1\u1d62\u00b7\u03b3\u1d62\u00b7(u^early_i + u^late_i) [ETA deviation cost]\n- Z\u2084 = \u03a3\u2096 \u03a3\u1d62 \u03a3\u209c c\u2096\u00b7(\u03c4^in_i\u00b7y^in_ikt + \u03c4^out_i\u00b7y^out_ikt) [Tugboat utilization cost]\n\nComplete Constraint Set\n\nConstraint (1): Vessel Assignment Constraints\n\u03a3\u2c7c \u03a3\u209c x_ijt \u2264 1, \u2200i \u2208 I\nEach vessel can be assigned at most once.\n\nConstraint (2): Vessel-Berth Compatibility Constraints\nx_ijt = 0, \u2200i \u2208 I, j \u2208 J, t \u2208 T : C\u2c7c < S\u1d62\nVessels can only be assigned to berths with sufficient capacity.\n\nConstraint (3): Inbound Tugboat Service Coupling\n\u03a3\u209c z^in_it = \u03a3\u2c7c \u03a3\u209c x_ijt, \u2200i \u2208 I\nIf a vessel is assigned to any berth, it must receive inbound tugboat service exactly once.\n\nConstraint (4): Outbound Tugboat Service Coupling\n\u03a3\u209c z^out_it = \u03a3\u2c7c \u03a3\u209c x_ijt, \u2200i \u2208 I\nIf a vessel is assigned to any berth, it must receive outbound tugboat service exactly once.\n\nConstraint (5): Tugboat Horsepower Constraints for Inbound\n\u03a3\u2096 P\u2096\u00b7y^in_ikt \u2265 P^req_i\u00b7z^in_it, \u2200i \u2208 I, t \u2208 T\nAssigned tugboats must provide sufficient total horsepower for inbound service.\n\nConstraint (6): Tugboat Horsepower Constraints for Outbound\n\u03a3\u2096 P\u2096\u00b7y^out_ikt \u2265 P^req_i\u00b7z^out_it, \u2200i \u2208 I, t \u2208 T\nAssigned tugboats must provide sufficient total horsepower for outbound service.\n\nConstraint (7): Tugboat Quantity Limits for Inbound\n\u03a3\u2096 y^in_ikt \u2264 H_max\u00b7z^in_it, \u2200i \u2208 I, t \u2208 T\nMaximum number of tugboats per inbound service is limited to H_max.\n\nConstraint (8): Tugboat Quantity Limits for Outbound\n\u03a3\u2096 y^out_ikt \u2264 H_max\u00b7z^out_it, \u2200i \u2208 I, t \u2208 T\nMaximum number of tugboats per outbound service is limited to H_max.\n\nConstraint (9): Auxiliary Variable Definition for Inbound\nz^in_it \u2264 \u03a3\u2096 y^in_ikt, \u2200i \u2208 I, t \u2208 T\nAuxiliary variables for inbound service are properly linked to tugboat assignment variables.\nAdditional requirement: All tugboats serving the same vessel for inbound service must start at the same time.\n\nConstraint (10): Auxiliary Variable Definition for Outbound\nz^out_it \u2264 \u03a3\u2096 y^out_ikt, \u2200i \u2208 I, t \u2208 T\nAuxiliary variables for outbound service are properly linked to tugboat assignment variables.\nAdditional requirement: All tugboats serving the same vessel for outbound service must start at the same time.\n\nConstraint (11): Berth Capacity Constraints\n\u03a3\u1d62 \u03a3\u209c'=max(1,t-D\u1d62+1)^t x_ijt' \u2264 1, \u2200j \u2208 J, t \u2208 T\nEach berth can accommodate at most one vessel at any time, considering vessel duration D\u1d62.\n\nConstraint (12): Tugboat Capacity Constraints (with Preparation Time)\n\u03a3\u1d62 [\u03a3\u209c'=max(1,t-\u03c4^in_i-\u03c1^in+1)^t y^in_ikt' + \u03a3\u209c'=max(1,t-\u03c4^out_i-\u03c1^out+1)^t y^out_ikt'] \u2264 1, \u2200k \u2208 K, t \u2208 T\nEach tugboat can provide only one service at a time, including preparation time between services.\n\nConstraint (13): Inbound Service Time Window Constraints\ny^in_ikt = 0, \u2200i \u2208 I, k \u2208 K, t < ETA\u1d62 - \u0394^early_i or t > ETA\u1d62 + \u0394^late_i\nTugboat inbound services can only start within the vessel's ETA allowed time window.\n\nConstraint (14): Inbound-Berthing Timing Sequence Constraints\n0 \u2264 \u03a3\u2c7c \u03a3\u209c t\u00b7x_ijt - \u03a3\u209c (t + \u03c4^in_i)\u00b7z^in_it \u2264 \u03b5_time\u00b7\u03a3\u2c7c \u03a3\u209c x_ijt, \u2200i \u2208 I\nBerthing must start after inbound service completion, within tolerance \u03b5_time.\n\nConstraint (15): Berthing-Outbound Timing Sequence Constraints\n0 \u2264 \u03a3\u209c t\u00b7z^out_it - \u03a3\u2c7c \u03a3\u209c (t + D\u1d62)\u00b7x_ijt \u2264 \u03b5_time\u00b7\u03a3\u2c7c \u03a3\u209c x_ijt, \u2200i \u2208 I\nOutbound service must start after berthing completion, within tolerance \u03b5_time.\n\nConstraint (16): ETA Deviation Linearization Constraints\n\u03a3\u209c t\u00b7z^in_it = ETA\u1d62 + u^late_i - u^early_i, \u2200i \u2208 I\nLinear representation of ETA deviations for cost calculation.\n\nConstraint (17): Variable Domain Constraints\nu^early_i, u^late_i \u2265 0, \u2200i \u2208 I\nx_ijt, y^in_ikt, y^out_ikt, z^in_it, z^out_it \u2208 {0,1}, \u2200i \u2208 I, j \u2208 J, k \u2208 K, t \u2208 T\nVariable domain constraints for all decision variables.\n\nInput Parameters\n\nVessel Parameters\n- S\u1d62: Size level of vessel i\n- ETA\u1d62: Expected arrival time of vessel i\n- D\u1d62: Berthing duration required by vessel i\n- \u03c4^in_i, \u03c4^out_i: Inbound and outbound tugboat service durations for vessel i\n- P^req_i: Minimum tugboat horsepower required by vessel i\n- \u0394^early_i, \u0394^late_i: Maximum allowed early/late deviations from ETA for vessel i\n- \u03b1\u1d62, \u03b2\u1d62, \u03b3\u1d62: Priority weight, unit waiting cost, and JIT deviation unit cost for vessel i\n\nBerth Parameters\n- C\u2c7c: Capacity level of berth j\n\nTugboat Parameters\n- P\u2096: Horsepower of tugboat k\n- c\u2096: Unit time usage cost of tugboat k\n- \u03c1^in, \u03c1^out: Preparation times for tugboats after completing inbound/outbound services\n\nSystem Parameters\n- H_max: Maximum number of tugboats allowed per service\n- \u03b5_time: Maximum allowed time deviation in sequencing constraints\n- M: Large penalty parameter for unserved vessels\n- \u03bb\u2081, \u03bb\u2082, \u03bb\u2083, \u03bb\u2084: Weighting coefficients in the objective function\n\nProblem Constraints Summary\n\nThe model ensures that:\n1. Each vessel receives complete service (inbound \u2192 berthing \u2192 outbound) or no service at all\n2. Services follow proper temporal sequence with bounded time gaps\n3. Resource capacity constraints are respected for both berths and tugboats\n4. Tugboat horsepower and quantity requirements are satisfied\n5. Tugboat inbound services can only start within the vessel's ETA allowed time window.\n6. Berth-vessel size compatibility is maintained\n7. Tugboat availability considering preparation times is enforced\n8. All tugboats serving the same vessel must start their service at the same time\n\n\nPlease consider is psp a combinatorial operation problem and can be solved by heuristics?\nIf you think this problem is not a combinatorial operation problem or the solution, operator, data are incorrect, response ***is_cop:no*** to me, or response ***is_cop:yes***.\n\nThe response format is very important. For better communication, please respond to me in this format:\n***is_cop:yes/no***\nEnsure there is no other content inside the ***, and analysis outside *** is welcome.\nIf you have no information to provide, simply respond with ***None***."
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***is_cop:yes***\n\nThe Port Scheduling Problem (PSP) as described is indeed a combinatorial optimization (CO) problem. It involves discrete decision-making for assigning vessels to berths and tugboats at specific times, subject to compatibility, capacity, sequencing, and timing constraints, with the goal of minimizing a multi-objective function that includes penalties and costs. This fits the classic characteristics of CO problems, such as scheduling, assignment, and resource allocation in discrete spaces, which are often NP-hard and scale poorly with exact solvers like MILP for large instances.\n\nHeuristics (e.g., genetic algorithms, simulated annealing, tabu search, or hyper-heuristics) are highly suitable for solving it, especially to generate good feasible solutions quickly when exact methods are computationally expensive. The binary variables, time-discretized horizons, and interdependent services make it amenable to heuristic operators like local search for reassigning vessels/tugs, mutation for timing adjustments, or selection mechanisms in population-based methods. The provided mathematical model is a solid MILP formulation, with no apparent errors in variables, constraints, or objectives\u2014it's comprehensive and aligns with standard scheduling models in port operations research. If you're developing hyper-heuristics, low-level heuristics could target subproblems like tug assignment or berth sequencing, while high-level ones select/adapt them dynamically."
            }
        ]
    },
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "We aim to collaboratively create the functions to generate some problem states(statistics data), which captures the high-level features of problem instance for the psp. \n\nThese functions will be underpinned by rigorous statistical analysis and domain-specific knowledge, ensuring they are both accurate and relevant.\n\n\nIn determining the optimal problem states to represent instance, we must adhere to the following criteria:\n1. The data representation should be succinct to minimize computational load while retaining sufficient granularity to recognize the feature of the problem and solution.\n2. It must incorporate unique attributes that aid in the clear distinction between different instances.\n3. The most important, these data only focus on instance and has nothing to do with solution.\n\nNow, please tell me which statistical data are best serve as instance problem state.\n\nThe response format is very important. For better communication, please respond to me in this format:\n***instance_problem_state:\nproblem_state_name;how_to_calculate;reason\nproblem_state_name;how_to_calculate;reason\n....\n***\nEnsure there is no other content inside the ***, and analysis outside *** is welcome.\nIf you have no information to provide, simply respond with ***None***."
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***instance_problem_state:\nnum_vessels;|I|;Captures the scale of demand, a fundamental distinguisher for instance complexity as more vessels increase combinatorial possibilities without solution dependency.\nnum_berths;|J|;Indicates resource availability for berthing, distinguishing instances by berth scarcity or abundance, which affects feasibility and tightness.\nnum_tugboats;|K|;Reflects service capacity for tug operations, key for differentiating tug-constrained vs. berth-constrained instances.\navg_vessel_size;mean(S_i over i in I);Summarizes vessel scale relative to berths, succinct proxy for compatibility challenges and size heterogeneity.\nvar_vessel_size;variance(S_i over i in I);Measures size diversity, helping distinguish uniform vs. heterogeneous fleets that impact assignment flexibility.\ntotal_required_hp;sum(P^req_i over i in I);Quantifies aggregate horsepower demand, distinguishing high vs. low tug power needs without per-vessel detail.\ntotal_available_hp;sum(P_k over k in K);Represents overall tug fleet strength, a succinct indicator of potential bottlenecks in service provision.\neta_span;max(ETA_i) - min(ETA_i) over i in I;Defines the temporal spread of arrivals, crucial for sequencing tightness and time window overlaps.\navg_berthing_duration;mean(D_i over i in I);Averages occupation times, distinguishing short-turnaround vs. long-stay instances affecting berth turnover.\nvessel_arrival_density;|I| / eta_span;Gauges arrival clustering, a compact measure of temporal pressure and potential conflicts in scheduling windows.\navg_time_window_flex;mean(\u0394^early_i + \u0394^late_i over i in I);Summarizes allowable ETA deviations, indicating rigidity of arrival constraints across instances.\nberth_capacity_ratio;mean(C_j over j in J) / mean(S_i over i in I);Roughly captures average berth-vessel fit, distinguishing compatible vs. mismatched resource setups.\n***\n\nThese features are derived from the core input parameters of the PSP model, focusing on counts, central tendencies, spreads, and ratios that encapsulate instance characteristics like scale, heterogeneity, resource adequacy, and temporal dynamics. They avoid any solution-related metrics (e.g., no utilization from assignments) and are computationally lightweight, computable in O(n) time where n is instance size. For hyper-heuristics, such states can serve as inputs to high-level selectors, enabling adaptation to instance \"landscapes\" (e.g., dense arrivals might favor greedy dispatching over global search). If your dataset includes a defined time horizon T, you could add sum(D_i) / (|J| * T) for potential berth load, but I omitted it assuming T might vary or be derived from ETAs. Validation via statistical tests (e.g., PCA on instances) could refine this set further."
            }
        ]
    },
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "Try to implement the get_instance_problem_state function in python:\ndef get_instance_problem_state(instance_data: dict) -> dict:\n\nThe input is instance_data\n- vessel_num (int): The total number of vessels requesting berthing service.\n    - berth_num (int): The total number of berths available at the port.\n    - tugboat_num (int): The total number of tugboats available for service.\n    - time_periods (int): The total number of time periods in the scheduling horizon.\n    - vessel_sizes (numpy.ndarray): 1D array of size levels for each vessel (Si).\n    - berth_capacities (numpy.ndarray): 1D array of capacity levels for each berth (Cj).\n    - vessel_etas (numpy.ndarray): 1D array of expected arrival times for each vessel (ETAi).\n    - vessel_durations (numpy.ndarray): 1D array of berthing durations required by each vessel (Di).\n    - vessel_inbound_service_times (numpy.ndarray): 1D array of inbound tugboat service durations for each vessel.\n    - vessel_outbound_service_times (numpy.ndarray): 1D array of outbound tugboat service durations for each vessel.\n    - vessel_priority_weights (numpy.ndarray): 1D array of priority weights for each vessel.\n    - vessel_waiting_costs (numpy.ndarray): 1D array of unit waiting costs for each vessel.\n    - vessel_jit_costs (numpy.ndarray): 1D array of JIT deviation unit costs for each vessel.\n    - vessel_horsepower_requirements (numpy.ndarray): 1D array of minimum tugboat horsepower required by each vessel.\n    - vessel_early_limits (numpy.ndarray): 1D array of maximum early arrival allowances for each vessel.\n    - vessel_late_limits (numpy.ndarray): 1D array of maximum late arrival allowances for each vessel.\n    - tugboat_horsepower (numpy.ndarray): 1D array of horsepower for each tugboat.\n    - tugboat_costs (numpy.ndarray): 1D array of unit time usage costs for each tugboat.\n    - inbound_preparation_time (int): Preparation time for tugboats after completing inbound service (rho_in).\n    - outbound_preparation_time (int): Preparation time for tugboats after completing outbound service (rho_out).\n    - max_tugboats_per_service (int): Maximum number of tugboats allowed for a single service (Hmax).\n    - time_constraint_tolerance (float): Maximum allowed time deviation in timing constraints (epsilon_time).\n    - penalty_parameter (float): Large penalty parameter for unserved vessels.\n    - objective_weights (numpy.ndarray): 1D array of four weighting coefficients [lambda_1, lambda_2, lambda_3, lambda_4] for objective function components.\n\nThe output is algo a dict, which contains the following problem states as keys: num_vessels,num_berths,num_tugboats,avg_vessel_size,var_vessel_size,total_required_hp,total_available_hp,eta_span,avg_berthing_duration,vessel_arrival_density,avg_time_window_flex,berth_capacity_ratio.\n\nPlease note:\n1. Never modify the instance_data.\n2. The name of function must be get_instance_problem_state.\n3. No any omissions or placeholders, I'm just going to use the code.\n4. Comments in the code are very important.\n\n\nThe response format is very important. For better communication, please respond to me in this format:\n***python_code:\nimport library (if necessary)\ndef get_instance_problem_state(instance_data: dict) -> dict:\n    \"\"\"Extract instance problem state from instance data.\n\n    Args:\n        instance_data (dict): The dictionary contains the instance data.\n\n    Returns:\n        dict: The dictionary contains the instance problem state with:\n            - problem_state_name (type): description\n            - problem_state_name (type): description\n            ...\n    \"\"\"\n    ...\n***\nEnsure there is no other content inside the ***, and analysis outside *** is welcome.\nIf you have no information to provide, simply respond with ***None***."
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***python_code:\nimport numpy as np\n\ndef get_instance_problem_state(instance_data: dict) -> dict:\n    \"\"\"Extract instance problem state from instance data.\n\n    Args:\n        instance_data (dict): The dictionary contains the instance data.\n\n    Returns:\n        dict: The dictionary contains the instance problem state with:\n            - num_vessels (int): Number of vessels.\n            - num_berths (int): Number of berths.\n            - num_tugboats (int): Number of tugboats.\n            - avg_vessel_size (float): Average vessel size.\n            - var_vessel_size (float): Variance of vessel sizes.\n            - total_required_hp (float): Total required horsepower for all vessels.\n            - total_available_hp (float): Total available horsepower from all tugboats.\n            - eta_span (float): Span between maximum and minimum ETA.\n            - avg_berthing_duration (float): Average berthing duration.\n            - vessel_arrival_density (float): Density of vessel arrivals (num_vessels / eta_span).\n            - avg_time_window_flex (float): Average flexibility in time windows (mean of early + late limits).\n            - berth_capacity_ratio (float): Ratio of average berth capacity to average vessel size.\n    \"\"\"\n    # Extract basic counts directly from the instance data\n    num_vessels = instance_data['vessel_num']\n    num_berths = instance_data['berth_num']\n    num_tugboats = instance_data['tugboat_num']\n    \n    # Extract relevant arrays for computations\n    vessel_sizes = instance_data['vessel_sizes']\n    berth_capacities = instance_data['berth_capacities']\n    vessel_etas = instance_data['vessel_etas']\n    vessel_durations = instance_data['vessel_durations']\n    vessel_horsepower_requirements = instance_data['vessel_horsepower_requirements']\n    tugboat_horsepower = instance_data['tugboat_horsepower']\n    vessel_early_limits = instance_data['vessel_early_limits']\n    vessel_late_limits = instance_data['vessel_late_limits']\n    \n    # Compute average vessel size using numpy mean\n    avg_vessel_size = np.mean(vessel_sizes)\n    \n    # Compute variance of vessel sizes using numpy var (default is population variance)\n    var_vessel_size = np.var(vessel_sizes)\n    \n    # Compute total required horsepower by summing vessel requirements\n    total_required_hp = np.sum(vessel_horsepower_requirements)\n    \n    # Compute total available horsepower by summing tugboat horsepowers\n    total_available_hp = np.sum(tugboat_horsepower)\n    \n    # Compute ETA span as max ETA minus min ETA\n    eta_span = np.max(vessel_etas) - np.min(vessel_etas)\n    \n    # Compute average berthing duration using numpy mean\n    avg_berthing_duration = np.mean(vessel_durations)\n    \n    # Compute vessel arrival density: number of vessels divided by ETA span\n    # Note: If eta_span is zero (all vessels arrive at same time), this would be infinite; assume eta_span > 0 in valid instances\n    vessel_arrival_density = num_vessels / eta_span if eta_span > 0 else 0.0  # Fallback to 0 if span is zero\n    \n    # Compute average time window flexibility: mean of (early + late limits) for all vessels\n    time_window_flex = vessel_early_limits + vessel_late_limits\n    avg_time_window_flex = np.mean(time_window_flex)\n    \n    # Compute berth capacity ratio: average berth capacity divided by average vessel size\n    avg_berth_capacity = np.mean(berth_capacities)\n    berth_capacity_ratio = avg_berth_capacity / avg_vessel_size if avg_vessel_size > 0 else 0.0  # Avoid division by zero\n    \n    # Construct the output dictionary with all computed states\n    problem_state = {\n        'num_vessels': num_vessels,\n        'num_berths': num_berths,\n        'num_tugboats': num_tugboats,\n        'avg_vessel_size': avg_vessel_size,\n        'var_vessel_size': var_vessel_size,\n        'total_required_hp': total_required_hp,\n        'total_available_hp': total_available_hp,\n        'eta_span': eta_span,\n        'avg_berthing_duration': avg_berthing_duration,\n        'vessel_arrival_density': vessel_arrival_density,\n        'avg_time_window_flex': avg_time_window_flex,\n        'berth_capacity_ratio': berth_capacity_ratio\n    }\n    \n    return problem_state\n***\nThis implementation strictly adheres to the requirements: it uses the provided instance_data keys without modification, computes only the specified states using NumPy for efficient array operations, and includes comprehensive comments for clarity. Edge cases like zero eta_span or zero avg_vessel_size are handled with fallbacks to prevent errors (e.g., division by zero), assuming valid positive values in typical instances. The function is self-contained and ready for direct use in a hyper-heuristics pipeline. If time_periods or other params are needed later, they can be added without affecting this core extraction."
            }
        ]
    },
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "Now, we aim to collaboratively create the functions to generate some problem states(statistics data), which captures the high-level features of current (partial) solution for the psp.\n\nThese functions will be underpinned by rigorous statistical analysis and domain-specific knowledge, ensuring they are both accurate and relevant.\n\n\nIn determining the optimal problem states to represent instance, we must adhere to the following criteria:\n1. The data representation should be succinct to minimize computational load while retaining sufficient granularity to recognize the solution feature.\n2. It must incorporate unique attributes that aid in the clear distinction between different solution stage.\n3. We need to evaluate the current status from multiple dimensions, including the current progress of the solution, the quality of the solution, the status of the remaining data, etc.\n4. The most important, these data relates to both instance and current solution, and will update during the problem solving process.\n\nNow, please tell me which statistical data are best serve as solution problem state.\n\nThe response format is very important. For better communication, please respond to me in this format:\n***solution_problem_state:\nproblem_state_name;how_to_calculate;reason\nproblem_state_name;how_to_calculate;reason\n....\n***\nEnsure there is no other content inside the ***, and analysis outside *** is welcome.\nIf you have no information to provide, simply respond with ***None***."
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***solution_problem_state:\nassigned_vessels_fraction;(number of vessels with full service assignment (inbound, berthing, outbound)) / num_vessels;Tracks overall progress in completing vessel services, distinguishing early (low) vs. late (high) solution stages succinctly without full enumeration.\npartial_objective_value;current sum of Z1 + Z2 + Z3 + Z4 for assigned vessels only (penalize unassigned at M*alpha_i);Provides a quality snapshot of the partial solution, allowing distinction between improving vs. stagnating trajectories, computable incrementally.\nunassigned_vessels;num_vessels - number of fully assigned vessels;Quantifies remaining workload, essential for assessing solution completeness and guiding heuristic focus on backlog.\nberth_utilization;sum over assigned vessels of (D_i) / (num_berths * time_periods);Measures resource efficiency for berths, highlighting over/under-utilization stages to differentiate feasible vs. congested partial schedules.\ntug_utilization;sum over assigned services of (tau_in_i + tau_out_i) / (num_tugboats * time_periods);Captures tug resource strain, useful for identifying tug-bottleneck phases in the solving process.\navg_eta_deviation_assigned;mean(u_early_i + u_late_i for assigned vessels);Evaluates timeliness quality for serviced vessels, distinguishing solutions with good vs. poor adherence to arrival windows.\nremaining_hp_demand;sum(P^req_i for unassigned vessels);Indicates future tug power needs, helping distinguish resource-plenty vs. -scarce remaining subproblems.\nschedule_progress;max(end time of assigned services) / time_periods;Gauges temporal advancement, key for sequencing heuristics to prioritize forward vs. backward filling in partial schedules.\nfull_service_completion_rate;(number of vessels with all three services assigned without violations) / num_vessels;Refines progress by focusing on constraint satisfaction, distinguishing partial assignments from complete ones.\npotential_conflict_ratio;(number of overlapping resource assignments or violations in partial solution) / num_vessels;Assesses feasibility quality, succinct for detecting and resolving conflicts early in heuristic iterations.\n***\n\nThese solution states build on the instance features by incorporating partial assignment data (e.g., tracking which vessels have x_ijt, y^in_ikt, y^out_ikt set), ensuring dynamic updates as heuristics evolve the solution (e.g., via local search or population updates). They cover progress (assigned fractions), quality (deviations, objectives), and remaining status (unassigned demands) across resource, temporal, and constraint dimensions, with O(n) computation for efficiency in hyper-heuristics. For implementation, assume access to current solution variables; in partial solutions, unassigned vessels contribute to penalties but not utilization. This set enables high-level heuristics to adapt, e.g., switch to intensification when progress > 0.7 or repair when conflicts rise. If solution data structure is specified later, refinements like weighted averages by priority (alpha_i) could enhance relevance."
            }
        ]
    },
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "Try to implement the get_solution_problem_state function in python:\ndef get_solution_problem_state(instance_data: dict, solution: Solution) -> dict:\n\nThe input is instance_data:\n- vessel_num (int): The total number of vessels requesting berthing service.\n    - berth_num (int): The total number of berths available at the port.\n    - tugboat_num (int): The total number of tugboats available for service.\n    - time_periods (int): The total number of time periods in the scheduling horizon.\n    - vessel_sizes (numpy.ndarray): 1D array of size levels for each vessel (Si).\n    - berth_capacities (numpy.ndarray): 1D array of capacity levels for each berth (Cj).\n    - vessel_etas (numpy.ndarray): 1D array of expected arrival times for each vessel (ETAi).\n    - vessel_durations (numpy.ndarray): 1D array of berthing durations required by each vessel (Di).\n    - vessel_inbound_service_times (numpy.ndarray): 1D array of inbound tugboat service durations for each vessel.\n    - vessel_outbound_service_times (numpy.ndarray): 1D array of outbound tugboat service durations for each vessel.\n    - vessel_priority_weights (numpy.ndarray): 1D array of priority weights for each vessel.\n    - vessel_waiting_costs (numpy.ndarray): 1D array of unit waiting costs for each vessel.\n    - vessel_jit_costs (numpy.ndarray): 1D array of JIT deviation unit costs for each vessel.\n    - vessel_horsepower_requirements (numpy.ndarray): 1D array of minimum tugboat horsepower required by each vessel.\n    - vessel_early_limits (numpy.ndarray): 1D array of maximum early arrival allowances for each vessel.\n    - vessel_late_limits (numpy.ndarray): 1D array of maximum late arrival allowances for each vessel.\n    - tugboat_horsepower (numpy.ndarray): 1D array of horsepower for each tugboat.\n    - tugboat_costs (numpy.ndarray): 1D array of unit time usage costs for each tugboat.\n    - inbound_preparation_time (int): Preparation time for tugboats after completing inbound service (rho_in).\n    - outbound_preparation_time (int): Preparation time for tugboats after completing outbound service (rho_out).\n    - max_tugboats_per_service (int): Maximum number of tugboats allowed for a single service (Hmax).\n    - time_constraint_tolerance (float): Maximum allowed time deviation in timing constraints (epsilon_time).\n    - penalty_parameter (float): Large penalty parameter for unserved vessels.\n    - objective_weights (numpy.ndarray): 1D array of four weighting coefficients [lambda_1, lambda_2, lambda_3, lambda_4] for objective function components.\nThe format of solution is already defined as:\nclass Solution:\n    \"\"\"The solution of Port Scheduling Problem supporting multi-tugboat services.\nAttributes:\n    vessel_assignments (dict): Maps vessel_id to (berth_id, start_time) tuple. None if vessel is unassigned.\n    tugboat_inbound_assignments (dict): Maps vessel_id to list of tuple (tugboat_id, start_time) for inbound service.\n    tugboat_outbound_assignments (dict): Maps vessel_id to list of tuple (tugboat_id, start_time) for outbound service.\"\"\"\n    def __init__(self, vessel_assignments: dict=None, tugboat_inbound_assignments: dict=None, tugboat_outbound_assignments: dict=None):\n        self.vessel_assignments = vessel_assignments or {}\n        self.tugboat_inbound_assignments = tugboat_inbound_assignments or {}\n        self.tugboat_outbound_assignments = tugboat_outbound_assignments or {}\n\nThe output is algo a dict, which contains the following problem states as keys: assigned_vessels_fraction,partial_objective_value,unassigned_vessels,berth_utilization,tug_utilization,avg_eta_deviation_assigned,remaining_hp_demand,schedule_progress,full_service_completion_rate,potential_conflict_ratio.\n\nPlease note:\n1. Never modify the instance_data and solution.\n2. The name of function must be get_solution_problem_state.\n3. No any omissions or placeholders, I'm just going to use the code.\n4. Comments in the code are very important.\n5. The solution is already defined, do not implement it again.\n\nThe response format is very important. For better communication, please respond to me in this format:\n***python_code:\nimport library (if necessary)\ndef get_solution_problem_state(instance_data: dict, solution: Solution) -> dict:\n    \"\"\"Extract instance problem state from instance data.\n\n    Args:\n        instance_data (dict): The dictionary contains the instance data.\n        solution (Solution): The target solution instance.\n    Returns:\n        dict: The dictionary contains the instance problem state with:\n            - problem_state_name (type): description\n            - problem_state_name (type): description\n            ...\n    \"\"\"\n    ...\n***\nEnsure there is no other content inside the ***, and analysis outside *** is welcome.\nIf you have no information to provide, simply respond with ***None***."
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***python_code:\nimport numpy as np\n\ndef get_solution_problem_state(instance_data: dict, solution: Solution) -> dict:\n    \"\"\"Extract solution problem state from instance data and current solution.\n\n    Args:\n        instance_data (dict): The dictionary contains the instance data.\n        solution (Solution): The target solution instance.\n\n    Returns:\n        dict: The dictionary contains the solution problem state with:\n            - assigned_vessels_fraction (float): Fraction of vessels with full service assignments (inbound, berthing, outbound).\n            - partial_objective_value (float): Partial objective value computed as weighted sum of Z1 to Z4 for the current assignments.\n            - unassigned_vessels (int): Number of vessels without full service assignments.\n            - berth_utilization (float): Utilization of berths based on assigned berthing durations.\n            - tug_utilization (float): Utilization of tugboats based on assigned service durations.\n            - avg_eta_deviation_assigned (float): Average ETA deviation for vessels with full assignments.\n            - remaining_hp_demand (float): Total horsepower requirement for unassigned vessels.\n            - schedule_progress (float): Progress as the maximum end time of assigned services normalized by time periods.\n            - full_service_completion_rate (float): Fraction of vessels with full and valid service assignments (no local violations).\n            - potential_conflict_ratio (float): Ratio of full assignments that have local violations.\n    \"\"\"\n    # Extract key scalars and arrays from instance_data\n    vessel_num = instance_data['vessel_num']\n    berth_num = instance_data['berth_num']\n    tugboat_num = instance_data['tugboat_num']\n    time_periods = instance_data['time_periods']\n    penalty = instance_data['penalty_parameter']\n    eps = instance_data['time_constraint_tolerance']\n    objective_weights = instance_data['objective_weights']  # [lambda1, lambda2, lambda3, lambda4]\n    alphas = instance_data['vessel_priority_weights']\n    betas = instance_data['vessel_waiting_costs']\n    gammas = instance_data['vessel_jit_costs']\n    etas = instance_data['vessel_etas']\n    ds = instance_data['vessel_durations']\n    tau_ins = instance_data['vessel_inbound_service_times']\n    tau_outs = instance_data['vessel_outbound_service_times']\n    p_reqs = instance_data['vessel_horsepower_requirements']\n    tug_hps = instance_data['tugboat_horsepower']\n    tug_costs = instance_data['tugboat_costs']\n    \n    # Initialize accumulators and counters\n    num_full_assigned = 0\n    num_valid_full = 0\n    z1 = 0.0  # Penalty for unassigned\n    z2 = 0.0  # Port time cost for assigned\n    z3 = 0.0  # ETA deviation cost for assigned\n    z4 = 0.0  # Tug utilization cost for assigned\n    total_berth_time = 0.0  # Sum of D_i for full assigned vessels\n    total_tug_time = 0.0  # Sum of (tau_in_i + tau_out_i) for full assigned vessels\n    total_eta_dev = 0.0  # Sum of (u_early + u_late) for full assigned vessels\n    max_end_time = 0.0  # Maximum outbound end time over full assigned vessels\n    remaining_hp = 0.0  # Sum of P_req for unassigned vessels\n    full_assigned_vessels = []  # List of vessel ids with full assignments for remaining HP calc\n    valid_vessels = set()  # For counting valid\n    \n    # Iterate over all vessels (assuming IDs are 0 to vessel_num-1)\n    for v in range(vessel_num):\n        # Get assignment data for this vessel\n        va = solution.vessel_assignments.get(v, None)\n        ti = solution.tugboat_inbound_assignments.get(v, [])\n        to = solution.tugboat_outbound_assignments.get(v, [])\n        \n        # Check if fully assigned (has berth and non-empty tug lists)\n        has_full = va is not None and len(ti) > 0 and len(to) > 0\n        if has_full:\n            num_full_assigned += 1\n            full_assigned_vessels.append(v)\n            \n            # Extract times (assume first for reference; check consistency below)\n            in_start = ti[0][1] if ti else 0\n            out_start = to[0][1] if to else 0\n            b_start = va[1] if va else 0\n            b_id = va[0] if va else -1\n            \n            # Compute contributions for objectives (regardless of validity)\n            port_time = (out_start + tau_outs[v]) - in_start\n            z2 += alphas[v] * betas[v] * port_time\n            \n            # ETA deviation: u_early + u_late = |in_start - eta|\n            eta_dev = abs(in_start - etas[v])\n            total_eta_dev += eta_dev\n            z3 += alphas[v] * gammas[v] * eta_dev\n            \n            # Tug costs: sum c_k * tau for inbound and outbound\n            sum_c_in = sum(tug_costs[tug_id] for tug_id, _ in ti)\n            sum_c_out = sum(tug_costs[tug_id] for tug_id, _ in to)\n            z4 += tau_ins[v] * sum_c_in + tau_outs[v] * sum_c_out\n            \n            # Accumulate for utilization\n            total_berth_time += ds[v]\n            total_tug_time += tau_ins[v] + tau_outs[v]\n            \n            # Update max end time\n            end_time = out_start + tau_outs[v]\n            if end_time > max_end_time:\n                max_end_time = end_time\n            \n            # Now check validity for local constraints\n            is_valid = True\n            \n            # Check all inbound tugs start at same time\n            in_starts = [st for _, st in ti]\n            if len(set(in_starts)) != 1:\n                is_valid = False\n            else:\n                in_start = in_starts[0]\n            \n            # Check all outbound tugs start at same time\n            out_starts = [st for _, st in to]\n            if len(set(out_starts)) != 1:\n                is_valid = False\n            else:\n                out_start = out_starts[0]\n            \n            # Check horsepower sufficiency for inbound and outbound\n            hp_in = sum(tug_hps[tug_id] for tug_id, _ in ti)\n            if hp_in < p_reqs[v]:\n                is_valid = False\n            hp_out = sum(tug_hps[tug_id] for tug_id, _ in to)\n            if hp_out < p_reqs[v]:\n                is_valid = False\n            \n            # Check timing sequence: inbound_end <= berth_start + eps and outbound_start <= berth_end + eps\n            in_end = in_start + tau_ins[v]\n            b_end = b_start + ds[v]\n            if not (in_end <= b_start + eps and out_start <= b_end + eps):\n                is_valid = False\n            \n            # Note: Global overlaps (e.g., berth/tug conflicts across vessels) are not checked here for succinctness;\n            # this focuses on local per-vessel validity.\n            \n            if is_valid:\n                num_valid_full += 1\n                valid_vessels.add(v)\n        else:\n            # For unassigned, add to Z1 and remaining HP\n            z1 += penalty * alphas[v]\n            remaining_hp += p_reqs[v]\n    \n    # Compute Z1 for any unassigned (already accumulated above)\n    # Note: z1 only includes unassigned; assigned contribute 0 to Z1\n    \n    # Compute partial objective value\n    partial_obj = (objective_weights[0] * z1 +\n                   objective_weights[1] * z2 +\n                   objective_weights[2] * z3 +\n                   objective_weights[3] * z4)\n    \n    # Compute state values\n    assigned_vessels_fraction = num_full_assigned / vessel_num if vessel_num > 0 else 0.0\n    unassigned_vessels = vessel_num - num_full_assigned\n    full_service_completion_rate = num_valid_full / vessel_num if vessel_num > 0 else 0.0\n    potential_conflict_ratio = (num_full_assigned - num_valid_full) / vessel_num if vessel_num > 0 else 0.0\n    \n    # Utilizations (using full assigned, regardless of validity)\n    denom_berth = berth_num * time_periods\n    berth_utilization = total_berth_time / denom_berth if denom_berth > 0 else 0.0\n    denom_tug = tugboat_num * time_periods\n    tug_utilization = total_tug_time / denom_tug if denom_tug > 0 else 0.0\n    \n    # Average ETA deviation for full assigned (using all full, as deviations are computable)\n    avg_eta_deviation_assigned = total_eta_dev / num_full_assigned if num_full_assigned > 0 else 0.0\n    \n    # Remaining HP for unassigned (already accumulated)\n    remaining_hp_demand = remaining_hp\n    \n    # Schedule progress\n    schedule_progress = max_end_time / time_periods if time_periods > 0 else 0.0\n    \n    # Construct output dictionary\n    problem_state = {\n        'assigned_vessels_fraction': assigned_vessels_fraction,\n        'partial_objective_value': partial_obj,\n        'unassigned_vessels': unassigned_vessels,\n        'berth_utilization': berth_utilization,\n        'tug_utilization': tug_utilization,\n        'avg_eta_deviation_assigned': avg_eta_deviation_assigned,\n        'remaining_hp_demand': remaining_hp_demand,\n        'schedule_progress': schedule_progress,\n        'full_service_completion_rate': full_service_completion_rate,\n        'potential_conflict_ratio': potential_conflict_ratio\n    }\n    \n    return problem_state\n***\nThis implementation computes the solution states by iterating over all vessels once, extracting assignments from the Solution object, and performing local validity checks for sequence, timing consistency, and horsepower without modifying inputs. The partial objective is calculated per the mathematical model, treating full assignments (presence of all components) as \"assigned\" for costs and utilizations, while validity refines completion and conflict metrics. Global constraint violations (e.g., overlapping berths/tugs across vessels) are omitted for computational efficiency, focusing on per-vessel locals as a succinct proxy; if needed, a full feasibility evaluator could be added separately. Edge cases (e.g., no assignments, zero denominators) are handled with safe divisions and zeros. The code is efficient (O(vessel_num + sum tug assignments)), suitable for frequent calls in hyper-heuristics."
            }
        ]
    }
]