[
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "I am working on Hyper-heuristics for Combinatorial Operation (CO) problem.\n\nCurrently, I am working on psp problem:\nPort Scheduling Problem (PSP) - Mathematical Model Description\n\nProblem Overview\n\nThe Port Scheduling Problem (PSP) involves optimal allocation of vessels to berths with coordinated tugboat services. The system manages multiple berths with different capacity levels, multiple tugboats with varying horsepower capabilities, and multiple vessels with specific requirements and time constraints.\n\nKey Problem Characteristics\n\nEach vessel must receive three sequential services if allocated:\n1. Inbound tugboat service - to guide vessel to berth\n2. Berthing service - vessel occupies berth for cargo operations\n3. Outbound tugboat service - to guide vessel away from berth\n\nThe services must be properly sequenced and temporally connected within allowable time tolerances. Vessels that cannot receive complete service are penalized heavily.\n\nMathematical Model Formulation\n\nDecision Variables\n- x_ijt \u2208 {0,1}: vessel i starts berthing at berth j at time t (only if berth capacity C\u2c7c \u2265 vessel size S\u1d62)\n- y^in_ikt \u2208 {0,1}: tugboat k starts inbound service for vessel i at time t\n- y^out_ikt \u2208 {0,1}: tugboat k starts outbound service for vessel i at time t\n- z^in_it \u2208 {0,1}: auxiliary variable indicating vessel i starts inbound tugboat service at time t\n- z^out_it \u2208 {0,1}: auxiliary variable indicating vessel i starts outbound tugboat service at time t\n- u^early_i \u2265 0: early deviation from ETA for vessel i\n- u^late_i \u2265 0: late deviation from ETA for vessel i\n\nObjective Function\nMinimize: \u03bb\u2081Z\u2081 + \u03bb\u2082Z\u2082 + \u03bb\u2083Z\u2083 + \u03bb\u2084Z\u2084\n\nWhere:\n- Z\u2081 = \u03a3\u1d62 M\u00b7\u03b1\u1d62\u00b7(1 - \u03a3\u2c7c \u03a3\u209c x_ijt) [Unserved vessel penalty]\n- Z\u2082 = \u03a3\u1d62 \u03b1\u1d62\u00b7\u03b2\u1d62\u00b7[\u03a3\u209c (t + \u03c4^out_i)\u00b7z^out_it - \u03a3\u209c t\u00b7z^in_it] [Total port time cost]\n- Z\u2083 = \u03a3\u1d62 \u03b1\u1d62\u00b7\u03b3\u1d62\u00b7(u^early_i + u^late_i) [ETA deviation cost]\n- Z\u2084 = \u03a3\u2096 \u03a3\u1d62 \u03a3\u209c c\u2096\u00b7(\u03c4^in_i\u00b7y^in_ikt + \u03c4^out_i\u00b7y^out_ikt) [Tugboat utilization cost]\n\nComplete Constraint Set\n\nConstraint (1): Vessel Assignment Constraints\n\u03a3\u2c7c \u03a3\u209c x_ijt \u2264 1, \u2200i \u2208 I\nEach vessel can be assigned at most once.\n\nConstraint (2): Vessel-Berth Compatibility Constraints\nx_ijt = 0, \u2200i \u2208 I, j \u2208 J, t \u2208 T : C\u2c7c < S\u1d62\nVessels can only be assigned to berths with sufficient capacity.\n\nConstraint (3): Inbound Tugboat Service Coupling\n\u03a3\u209c z^in_it = \u03a3\u2c7c \u03a3\u209c x_ijt, \u2200i \u2208 I\nIf a vessel is assigned to any berth, it must receive inbound tugboat service exactly once.\n\nConstraint (4): Outbound Tugboat Service Coupling\n\u03a3\u209c z^out_it = \u03a3\u2c7c \u03a3\u209c x_ijt, \u2200i \u2208 I\nIf a vessel is assigned to any berth, it must receive outbound tugboat service exactly once.\n\nConstraint (5): Tugboat Horsepower Constraints for Inbound\n\u03a3\u2096 P\u2096\u00b7y^in_ikt \u2265 P^req_i\u00b7z^in_it, \u2200i \u2208 I, t \u2208 T\nAssigned tugboats must provide sufficient total horsepower for inbound service.\n\nConstraint (6): Tugboat Horsepower Constraints for Outbound\n\u03a3\u2096 P\u2096\u00b7y^out_ikt \u2265 P^req_i\u00b7z^out_it, \u2200i \u2208 I, t \u2208 T\nAssigned tugboats must provide sufficient total horsepower for outbound service.\n\nConstraint (7): Tugboat Quantity Limits for Inbound\n\u03a3\u2096 y^in_ikt \u2264 H_max\u00b7z^in_it, \u2200i \u2208 I, t \u2208 T\nMaximum number of tugboats per inbound service is limited to H_max.\n\nConstraint (8): Tugboat Quantity Limits for Outbound\n\u03a3\u2096 y^out_ikt \u2264 H_max\u00b7z^out_it, \u2200i \u2208 I, t \u2208 T\nMaximum number of tugboats per outbound service is limited to H_max.\n\nConstraint (9): Auxiliary Variable Definition for Inbound\nz^in_it \u2264 \u03a3\u2096 y^in_ikt, \u2200i \u2208 I, t \u2208 T\nAuxiliary variables for inbound service are properly linked to tugboat assignment variables.\nAdditional requirement: All tugboats serving the same vessel for inbound service must start at the same time.\n\nConstraint (10): Auxiliary Variable Definition for Outbound\nz^out_it \u2264 \u03a3\u2096 y^out_ikt, \u2200i \u2208 I, t \u2208 T\nAuxiliary variables for outbound service are properly linked to tugboat assignment variables.\nAdditional requirement: All tugboats serving the same vessel for outbound service must start at the same time.\n\nConstraint (11): Berth Capacity Constraints\n\u03a3\u1d62 \u03a3\u209c'=max(1,t-D\u1d62+1)^t x_ijt' \u2264 1, \u2200j \u2208 J, t \u2208 T\nEach berth can accommodate at most one vessel at any time, considering vessel duration D\u1d62.\n\nConstraint (12): Tugboat Capacity Constraints (with Preparation Time)\n\u03a3\u1d62 [\u03a3\u209c'=max(1,t-\u03c4^in_i-\u03c1^in+1)^t y^in_ikt' + \u03a3\u209c'=max(1,t-\u03c4^out_i-\u03c1^out+1)^t y^out_ikt'] \u2264 1, \u2200k \u2208 K, t \u2208 T\nEach tugboat can provide only one service at a time, including preparation time between services.\n\nConstraint (13): Inbound Service Time Window Constraints\ny^in_ikt = 0, \u2200i \u2208 I, k \u2208 K, t < ETA\u1d62 - \u0394^early_i or t > ETA\u1d62 + \u0394^late_i\nTugboat inbound services can only start within the vessel's ETA allowed time window.\n\nConstraint (14): Inbound-Berthing Timing Sequence Constraints\n0 \u2264 \u03a3\u2c7c \u03a3\u209c t\u00b7x_ijt - \u03a3\u209c (t + \u03c4^in_i)\u00b7z^in_it \u2264 \u03b5_time\u00b7\u03a3\u2c7c \u03a3\u209c x_ijt, \u2200i \u2208 I\nBerthing must start after inbound service completion, within tolerance \u03b5_time.\n\nConstraint (15): Berthing-Outbound Timing Sequence Constraints\n0 \u2264 \u03a3\u209c t\u00b7z^out_it - \u03a3\u2c7c \u03a3\u209c (t + D\u1d62)\u00b7x_ijt \u2264 \u03b5_time\u00b7\u03a3\u2c7c \u03a3\u209c x_ijt, \u2200i \u2208 I\nOutbound service must start after berthing completion, within tolerance \u03b5_time.\n\nConstraint (16): ETA Deviation Linearization Constraints\n\u03a3\u209c t\u00b7z^in_it = ETA\u1d62 + u^late_i - u^early_i, \u2200i \u2208 I\nLinear representation of ETA deviations for cost calculation.\n\nConstraint (17): Variable Domain Constraints\nu^early_i, u^late_i \u2265 0, \u2200i \u2208 I\nx_ijt, y^in_ikt, y^out_ikt, z^in_it, z^out_it \u2208 {0,1}, \u2200i \u2208 I, j \u2208 J, k \u2208 K, t \u2208 T\nVariable domain constraints for all decision variables.\n\nInput Parameters\n\nVessel Parameters\n- S\u1d62: Size level of vessel i\n- ETA\u1d62: Expected arrival time of vessel i\n- D\u1d62: Berthing duration required by vessel i\n- \u03c4^in_i, \u03c4^out_i: Inbound and outbound tugboat service durations for vessel i\n- P^req_i: Minimum tugboat horsepower required by vessel i\n- \u0394^early_i, \u0394^late_i: Maximum allowed early/late deviations from ETA for vessel i\n- \u03b1\u1d62, \u03b2\u1d62, \u03b3\u1d62: Priority weight, unit waiting cost, and JIT deviation unit cost for vessel i\n\nBerth Parameters\n- C\u2c7c: Capacity level of berth j\n\nTugboat Parameters\n- P\u2096: Horsepower of tugboat k\n- c\u2096: Unit time usage cost of tugboat k\n- \u03c1^in, \u03c1^out: Preparation times for tugboats after completing inbound/outbound services\n\nSystem Parameters\n- H_max: Maximum number of tugboats allowed per service\n- \u03b5_time: Maximum allowed time deviation in sequencing constraints\n- M: Large penalty parameter for unserved vessels\n- \u03bb\u2081, \u03bb\u2082, \u03bb\u2083, \u03bb\u2084: Weighting coefficients in the objective function\n\nProblem Constraints Summary\n\nThe model ensures that:\n1. Each vessel receives complete service (inbound \u2192 berthing \u2192 outbound) or no service at all\n2. Services follow proper temporal sequence with bounded time gaps\n3. Resource capacity constraints are respected for both berths and tugboats\n4. Tugboat horsepower and quantity requirements are satisfied\n5. Tugboat inbound services can only start within the vessel's ETA allowed time window.\n6. Berth-vessel size compatibility is maintained\n7. Tugboat availability considering preparation times is enforced\n8. All tugboats serving the same vessel must start their service at the same time\n\n\nPlease consider is psp a combinatorial operation problem and can be solved by heuristics?\nIf you think this problem is not a combinatorial operation problem or the solution, operator, data are incorrect, response ***is_cop:no*** to me, or response ***is_cop:yes***.\n\nThe response format is very important. For better communication, please respond to me in this format:\n***is_cop:yes/no***\nEnsure there is no other content inside the ***, and analysis outside *** is welcome.\nIf you have no information to provide, simply respond with ***None***."
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***is_cop:yes***\n\nThe Port Scheduling Problem (PSP) as described is indeed a combinatorial optimization (CO) problem. It involves discrete decision-making for assigning vessels to berths and tugboats at specific times, subject to compatibility, capacity, sequencing, and timing constraints, with the goal of minimizing a multi-objective function that includes penalties and costs. This fits the classic characteristics of CO problems, such as scheduling, assignment, and resource allocation in discrete spaces, which are often NP-hard and scale poorly with exact solvers like MILP for large instances.\n\nHeuristics (e.g., genetic algorithms, simulated annealing, tabu search, or hyper-heuristics) are highly suitable for solving it, especially to generate good feasible solutions quickly when exact methods are computationally expensive. The binary variables, time-discretized horizons, and interdependent services make it amenable to heuristic operators like local search for reassigning vessels/tugs, mutation for timing adjustments, or selection mechanisms in population-based methods. The provided mathematical model is a solid MILP formulation, with no apparent errors in variables, constraints, or objectives\u2014it's comprehensive and aligns with standard scheduling models in port operations research. If you're developing hyper-heuristics, low-level heuristics could target subproblems like tug assignment or berth sequencing, while high-level ones select/adapt them dynamically."
            }
        ]
    },
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "We aim to collaboratively create the functions to generate some problem states(statistics data), which captures the high-level features of problem instance for the psp. \n\nThese functions will be underpinned by rigorous statistical analysis and domain-specific knowledge, ensuring they are both accurate and relevant.\n\n\nIn determining the optimal problem states to represent instance, we must adhere to the following criteria:\n1. The data representation should be succinct to minimize computational load while retaining sufficient granularity to recognize the feature of the problem and solution.\n2. It must incorporate unique attributes that aid in the clear distinction between different instances.\n3. The most important, these data only focus on instance and has nothing to do with solution.\n\nNow, please tell me which statistical data are best serve as instance problem state.\n\nThe response format is very important. For better communication, please respond to me in this format:\n***instance_problem_state:\nproblem_state_name;how_to_calculate;reason\nproblem_state_name;how_to_calculate;reason\n....\n***\nEnsure there is no other content inside the ***, and analysis outside *** is welcome.\nIf you have no information to provide, simply respond with ***None***."
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***instance_problem_state:\nnum_vessels;|I|;Captures the scale of demand, a fundamental distinguisher for instance complexity as more vessels increase combinatorial possibilities without solution dependency.\nnum_berths;|J|;Indicates resource availability for berthing, distinguishing instances by berth scarcity or abundance, which affects feasibility and tightness.\nnum_tugboats;|K|;Reflects service capacity for tug operations, key for differentiating tug-constrained vs. berth-constrained instances.\navg_vessel_size;mean(S_i over i in I);Summarizes vessel scale relative to berths, succinct proxy for compatibility challenges and size heterogeneity.\nvar_vessel_size;variance(S_i over i in I);Measures size diversity, helping distinguish uniform vs. heterogeneous fleets that impact assignment flexibility.\ntotal_required_hp;sum(P^req_i over i in I);Quantifies aggregate horsepower demand, distinguishing high vs. low tug power needs without per-vessel detail.\ntotal_available_hp;sum(P_k over k in K);Represents overall tug fleet strength, a succinct indicator of potential bottlenecks in service provision.\neta_span;max(ETA_i) - min(ETA_i) over i in I;Defines the temporal spread of arrivals, crucial for sequencing tightness and time window overlaps.\navg_berthing_duration;mean(D_i over i in I);Averages occupation times, distinguishing short-turnaround vs. long-stay instances affecting berth turnover.\nvessel_arrival_density;|I| / eta_span;Gauges arrival clustering, a compact measure of temporal pressure and potential conflicts in scheduling windows.\navg_time_window_flex;mean(\u0394^early_i + \u0394^late_i over i in I);Summarizes allowable ETA deviations, indicating rigidity of arrival constraints across instances.\nberth_capacity_ratio;mean(C_j over j in J) / mean(S_i over i in I);Roughly captures average berth-vessel fit, distinguishing compatible vs. mismatched resource setups.\n***\n\nThese features are derived from the core input parameters of the PSP model, focusing on counts, central tendencies, spreads, and ratios that encapsulate instance characteristics like scale, heterogeneity, resource adequacy, and temporal dynamics. They avoid any solution-related metrics (e.g., no utilization from assignments) and are computationally lightweight, computable in O(n) time where n is instance size. For hyper-heuristics, such states can serve as inputs to high-level selectors, enabling adaptation to instance \"landscapes\" (e.g., dense arrivals might favor greedy dispatching over global search). If your dataset includes a defined time horizon T, you could add sum(D_i) / (|J| * T) for potential berth load, but I omitted it assuming T might vary or be derived from ETAs. Validation via statistical tests (e.g., PCA on instances) could refine this set further."
            }
        ]
    },
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "Try to implement the get_instance_problem_state function in python:\ndef get_instance_problem_state(instance_data: dict) -> dict:\n\nThe input is instance_data\n- vessel_num (int): The total number of vessels requesting berthing service.\n    - berth_num (int): The total number of berths available at the port.\n    - tugboat_num (int): The total number of tugboats available for service.\n    - time_periods (int): The total number of time periods in the scheduling horizon.\n    - vessel_sizes (numpy.ndarray): 1D array of size levels for each vessel (Si).\n    - berth_capacities (numpy.ndarray): 1D array of capacity levels for each berth (Cj).\n    - vessel_etas (numpy.ndarray): 1D array of expected arrival times for each vessel (ETAi).\n    - vessel_durations (numpy.ndarray): 1D array of berthing durations required by each vessel (Di).\n    - vessel_inbound_service_times (numpy.ndarray): 1D array of inbound tugboat service durations for each vessel.\n    - vessel_outbound_service_times (numpy.ndarray): 1D array of outbound tugboat service durations for each vessel.\n    - vessel_priority_weights (numpy.ndarray): 1D array of priority weights for each vessel.\n    - vessel_waiting_costs (numpy.ndarray): 1D array of unit waiting costs for each vessel.\n    - vessel_jit_costs (numpy.ndarray): 1D array of JIT deviation unit costs for each vessel.\n    - vessel_horsepower_requirements (numpy.ndarray): 1D array of minimum tugboat horsepower required by each vessel.\n    - vessel_early_limits (numpy.ndarray): 1D array of maximum early arrival allowances for each vessel.\n    - vessel_late_limits (numpy.ndarray): 1D array of maximum late arrival allowances for each vessel.\n    - tugboat_horsepower (numpy.ndarray): 1D array of horsepower for each tugboat.\n    - tugboat_costs (numpy.ndarray): 1D array of unit time usage costs for each tugboat.\n    - inbound_preparation_time (int): Preparation time for tugboats after completing inbound service (rho_in).\n    - outbound_preparation_time (int): Preparation time for tugboats after completing outbound service (rho_out).\n    - max_tugboats_per_service (int): Maximum number of tugboats allowed for a single service (Hmax).\n    - time_constraint_tolerance (float): Maximum allowed time deviation in timing constraints (epsilon_time).\n    - penalty_parameter (float): Large penalty parameter for unserved vessels.\n    - objective_weights (numpy.ndarray): 1D array of four weighting coefficients [lambda_1, lambda_2, lambda_3, lambda_4] for objective function components.\n\nThe output is algo a dict, which contains the following problem states as keys: num_vessels,num_berths,num_tugboats,avg_vessel_size,var_vessel_size,total_required_hp,total_available_hp,eta_span,avg_berthing_duration,vessel_arrival_density,avg_time_window_flex,berth_capacity_ratio.\n\nPlease note:\n1. Never modify the instance_data.\n2. The name of function must be get_instance_problem_state.\n3. No any omissions or placeholders, I'm just going to use the code.\n4. Comments in the code are very important.\n\n\nThe response format is very important. For better communication, please respond to me in this format:\n***python_code:\nimport library (if necessary)\ndef get_instance_problem_state(instance_data: dict) -> dict:\n    \"\"\"Extract instance problem state from instance data.\n\n    Args:\n        instance_data (dict): The dictionary contains the instance data.\n\n    Returns:\n        dict: The dictionary contains the instance problem state with:\n            - problem_state_name (type): description\n            - problem_state_name (type): description\n            ...\n    \"\"\"\n    ...\n***\nEnsure there is no other content inside the ***, and analysis outside *** is welcome.\nIf you have no information to provide, simply respond with ***None***."
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***python_code:\nimport numpy as np\n\ndef get_instance_problem_state(instance_data: dict) -> dict:\n    \"\"\"Extract instance problem state from instance data.\n\n    Args:\n        instance_data (dict): The dictionary contains the instance data.\n\n    Returns:\n        dict: The dictionary contains the instance problem state with:\n            - num_vessels (int): Number of vessels.\n            - num_berths (int): Number of berths.\n            - num_tugboats (int): Number of tugboats.\n            - avg_vessel_size (float): Average vessel size.\n            - var_vessel_size (float): Variance of vessel sizes.\n            - total_required_hp (float): Total required horsepower for all vessels.\n            - total_available_hp (float): Total available horsepower from all tugboats.\n            - eta_span (float): Span between maximum and minimum ETA.\n            - avg_berthing_duration (float): Average berthing duration.\n            - vessel_arrival_density (float): Density of vessel arrivals (num_vessels / eta_span).\n            - avg_time_window_flex (float): Average flexibility in time windows (mean of early + late limits).\n            - berth_capacity_ratio (float): Ratio of average berth capacity to average vessel size.\n    \"\"\"\n    # Extract basic counts directly from the instance data\n    num_vessels = instance_data['vessel_num']\n    num_berths = instance_data['berth_num']\n    num_tugboats = instance_data['tugboat_num']\n    \n    # Extract relevant arrays for computations\n    vessel_sizes = instance_data['vessel_sizes']\n    berth_capacities = instance_data['berth_capacities']\n    vessel_etas = instance_data['vessel_etas']\n    vessel_durations = instance_data['vessel_durations']\n    vessel_horsepower_requirements = instance_data['vessel_horsepower_requirements']\n    tugboat_horsepower = instance_data['tugboat_horsepower']\n    vessel_early_limits = instance_data['vessel_early_limits']\n    vessel_late_limits = instance_data['vessel_late_limits']\n    \n    # Compute average vessel size using numpy mean\n    avg_vessel_size = np.mean(vessel_sizes)\n    \n    # Compute variance of vessel sizes using numpy var (default is population variance)\n    var_vessel_size = np.var(vessel_sizes)\n    \n    # Compute total required horsepower by summing vessel requirements\n    total_required_hp = np.sum(vessel_horsepower_requirements)\n    \n    # Compute total available horsepower by summing tugboat horsepowers\n    total_available_hp = np.sum(tugboat_horsepower)\n    \n    # Compute ETA span as max ETA minus min ETA\n    eta_span = np.max(vessel_etas) - np.min(vessel_etas)\n    \n    # Compute average berthing duration using numpy mean\n    avg_berthing_duration = np.mean(vessel_durations)\n    \n    # Compute vessel arrival density: number of vessels divided by ETA span\n    # Note: If eta_span is zero (all vessels arrive at same time), this would be infinite; assume eta_span > 0 in valid instances\n    vessel_arrival_density = num_vessels / eta_span if eta_span > 0 else 0.0  # Fallback to 0 if span is zero\n    \n    # Compute average time window flexibility: mean of (early + late limits) for all vessels\n    time_window_flex = vessel_early_limits + vessel_late_limits\n    avg_time_window_flex = np.mean(time_window_flex)\n    \n    # Compute berth capacity ratio: average berth capacity divided by average vessel size\n    avg_berth_capacity = np.mean(berth_capacities)\n    berth_capacity_ratio = avg_berth_capacity / avg_vessel_size if avg_vessel_size > 0 else 0.0  # Avoid division by zero\n    \n    # Construct the output dictionary with all computed states\n    problem_state = {\n        'num_vessels': num_vessels,\n        'num_berths': num_berths,\n        'num_tugboats': num_tugboats,\n        'avg_vessel_size': avg_vessel_size,\n        'var_vessel_size': var_vessel_size,\n        'total_required_hp': total_required_hp,\n        'total_available_hp': total_available_hp,\n        'eta_span': eta_span,\n        'avg_berthing_duration': avg_berthing_duration,\n        'vessel_arrival_density': vessel_arrival_density,\n        'avg_time_window_flex': avg_time_window_flex,\n        'berth_capacity_ratio': berth_capacity_ratio\n    }\n    \n    return problem_state\n***\nThis implementation strictly adheres to the requirements: it uses the provided instance_data keys without modification, computes only the specified states using NumPy for efficient array operations, and includes comprehensive comments for clarity. Edge cases like zero eta_span or zero avg_vessel_size are handled with fallbacks to prevent errors (e.g., division by zero), assuming valid positive values in typical instances. The function is self-contained and ready for direct use in a hyper-heuristics pipeline. If time_periods or other params are needed later, they can be added without affecting this core extraction."
            }
        ]
    }
]