# This file is generated by generate_problem_state.py.

from src.problems.psp.components import Solution


import numpy as np

def get_instance_problem_state(instance_data: dict) -> dict:
    """Extract instance problem state from instance data.

    Args:
        instance_data (dict): The dictionary contains the instance data.

    Returns:
        dict: The dictionary contains the instance problem state with:
            - num_vessels (int): Number of vessels.
            - num_berths (int): Number of berths.
            - num_tugboats (int): Number of tugboats.
            - avg_vessel_size (float): Average vessel size.
            - var_vessel_size (float): Variance of vessel sizes.
            - total_required_hp (float): Total required horsepower for all vessels.
            - total_available_hp (float): Total available horsepower from all tugboats.
            - eta_span (float): Span between maximum and minimum ETA.
            - avg_berthing_duration (float): Average berthing duration.
            - vessel_arrival_density (float): Density of vessel arrivals (num_vessels / eta_span).
            - avg_time_window_flex (float): Average flexibility in time windows (mean of early + late limits).
            - berth_capacity_ratio (float): Ratio of average berth capacity to average vessel size.
    """
    # Extract basic counts directly from the instance data
    num_vessels = instance_data['vessel_num']
    num_berths = instance_data['berth_num']
    num_tugboats = instance_data['tugboat_num']
    
    # Extract relevant arrays for computations
    vessel_sizes = instance_data['vessel_sizes']
    berth_capacities = instance_data['berth_capacities']
    vessel_etas = instance_data['vessel_etas']
    vessel_durations = instance_data['vessel_durations']
    vessel_horsepower_requirements = instance_data['vessel_horsepower_requirements']
    tugboat_horsepower = instance_data['tugboat_horsepower']
    vessel_early_limits = instance_data['vessel_early_limits']
    vessel_late_limits = instance_data['vessel_late_limits']
    
    # Compute average vessel size using numpy mean
    avg_vessel_size = np.mean(vessel_sizes)
    
    # Compute variance of vessel sizes using numpy var (default is population variance)
    var_vessel_size = np.var(vessel_sizes)
    
    # Compute total required horsepower by summing vessel requirements
    total_required_hp = np.sum(vessel_horsepower_requirements)
    
    # Compute total available horsepower by summing tugboat horsepowers
    total_available_hp = np.sum(tugboat_horsepower)
    
    # Compute ETA span as max ETA minus min ETA
    eta_span = np.max(vessel_etas) - np.min(vessel_etas)
    
    # Compute average berthing duration using numpy mean
    avg_berthing_duration = np.mean(vessel_durations)
    
    # Compute vessel arrival density: number of vessels divided by ETA span
    # Note: If eta_span is zero (all vessels arrive at same time), this would be infinite; assume eta_span > 0 in valid instances
    vessel_arrival_density = num_vessels / eta_span if eta_span > 0 else 0.0  # Fallback to 0 if span is zero
    
    # Compute average time window flexibility: mean of (early + late limits) for all vessels
    time_window_flex = vessel_early_limits + vessel_late_limits
    avg_time_window_flex = np.mean(time_window_flex)
    
    # Compute berth capacity ratio: average berth capacity divided by average vessel size
    avg_berth_capacity = np.mean(berth_capacities)
    berth_capacity_ratio = avg_berth_capacity / avg_vessel_size if avg_vessel_size > 0 else 0.0  # Avoid division by zero
    
    # Construct the output dictionary with all computed states
    problem_state = {
        'num_vessels': num_vessels,
        'num_berths': num_berths,
        'num_tugboats': num_tugboats,
        'avg_vessel_size': avg_vessel_size,
        'var_vessel_size': var_vessel_size,
        'total_required_hp': total_required_hp,
        'total_available_hp': total_available_hp,
        'eta_span': eta_span,
        'avg_berthing_duration': avg_berthing_duration,
        'vessel_arrival_density': vessel_arrival_density,
        'avg_time_window_flex': avg_time_window_flex,
        'berth_capacity_ratio': berth_capacity_ratio
    }
    
    return problem_state

from src.problems.psp.components import Solution
import numpy as np

def get_solution_problem_state(instance_data: dict, solution: Solution) -> dict:
    """Extract solution problem state from instance data and current solution.

    Args:
        instance_data (dict): The dictionary contains the instance data.
        solution (Solution): The target solution instance.

    Returns:
        dict: The dictionary contains the solution problem state with:
            - assigned_vessels_fraction (float): Fraction of vessels with full service assignments (inbound, berthing, outbound).
            - partial_objective_value (float): Partial objective value computed as weighted sum of Z1 to Z4 for the current assignments.
            - unassigned_vessels (int): Number of vessels without full service assignments.
            - berth_utilization (float): Utilization of berths based on assigned berthing durations.
            - tug_utilization (float): Utilization of tugboats based on assigned service durations.
            - avg_eta_deviation_assigned (float): Average ETA deviation for vessels with full assignments.
            - remaining_hp_demand (float): Total horsepower requirement for unassigned vessels.
            - schedule_progress (float): Progress as the maximum end time of assigned services normalized by time periods.
            - full_service_completion_rate (float): Fraction of vessels with full and valid service assignments (no local violations).
            - potential_conflict_ratio (float): Ratio of full assignments that have local violations.
    """
    # Extract key scalars and arrays from instance_data
    vessel_num = instance_data['vessel_num']
    berth_num = instance_data['berth_num']
    tugboat_num = instance_data['tugboat_num']
    time_periods = instance_data['time_periods']
    penalty = instance_data['penalty_parameter']
    eps = instance_data['time_constraint_tolerance']
    objective_weights = instance_data['objective_weights']  # [lambda1, lambda2, lambda3, lambda4]
    alphas = instance_data['vessel_priority_weights']
    betas = instance_data['vessel_waiting_costs']
    gammas = instance_data['vessel_jit_costs']
    etas = instance_data['vessel_etas']
    ds = instance_data['vessel_durations']
    tau_ins = instance_data['vessel_inbound_service_times']
    tau_outs = instance_data['vessel_outbound_service_times']
    p_reqs = instance_data['vessel_horsepower_requirements']
    tug_hps = instance_data['tugboat_horsepower']
    tug_costs = instance_data['tugboat_costs']
    
    # Initialize accumulators and counters
    num_full_assigned = 0
    num_valid_full = 0
    z1 = 0.0  # Penalty for unassigned
    z2 = 0.0  # Port time cost for assigned
    z3 = 0.0  # ETA deviation cost for assigned
    z4 = 0.0  # Tug utilization cost for assigned
    total_berth_time = 0.0  # Sum of D_i for full assigned vessels
    total_tug_time = 0.0  # Sum of (tau_in_i + tau_out_i) for full assigned vessels
    total_eta_dev = 0.0  # Sum of (u_early + u_late) for full assigned vessels
    max_end_time = 0.0  # Maximum outbound end time over full assigned vessels
    remaining_hp = 0.0  # Sum of P_req for unassigned vessels
    full_assigned_vessels = []  # List of vessel ids with full assignments for remaining HP calc
    valid_vessels = set()  # For counting valid
    
    # Iterate over all vessels (assuming IDs are 0 to vessel_num-1)
    for v in range(vessel_num):
        # Get assignment data for this vessel
        va = solution.vessel_assignments.get(v, None)
        ti = solution.tugboat_inbound_assignments.get(v, [])
        to = solution.tugboat_outbound_assignments.get(v, [])
        
        # Check if fully assigned (has berth and non-empty tug lists)
        has_full = va is not None and len(ti) > 0 and len(to) > 0
        if has_full:
            num_full_assigned += 1
            full_assigned_vessels.append(v)
            
            # Extract times (assume first for reference; check consistency below)
            in_start = ti[0][1] if ti else 0
            out_start = to[0][1] if to else 0
            b_start = va[1] if va else 0
            b_id = va[0] if va else -1
            
            # Compute contributions for objectives (regardless of validity)
            port_time = (out_start + tau_outs[v]) - in_start
            z2 += alphas[v] * betas[v] * port_time
            
            # ETA deviation: u_early + u_late = |in_start - eta|
            eta_dev = abs(in_start - etas[v])
            total_eta_dev += eta_dev
            z3 += alphas[v] * gammas[v] * eta_dev
            
            # Tug costs: sum c_k * tau for inbound and outbound
            sum_c_in = sum(tug_costs[tug_id] for tug_id, _ in ti)
            sum_c_out = sum(tug_costs[tug_id] for tug_id, _ in to)
            z4 += tau_ins[v] * sum_c_in + tau_outs[v] * sum_c_out
            
            # Accumulate for utilization
            total_berth_time += ds[v]
            total_tug_time += tau_ins[v] + tau_outs[v]
            
            # Update max end time
            end_time = out_start + tau_outs[v]
            if end_time > max_end_time:
                max_end_time = end_time
            
            # Now check validity for local constraints
            is_valid = True
            
            # Check all inbound tugs start at same time
            in_starts = [st for _, st in ti]
            if len(set(in_starts)) != 1:
                is_valid = False
            else:
                in_start = in_starts[0]
            
            # Check all outbound tugs start at same time
            out_starts = [st for _, st in to]
            if len(set(out_starts)) != 1:
                is_valid = False
            else:
                out_start = out_starts[0]
            
            # Check horsepower sufficiency for inbound and outbound
            hp_in = sum(tug_hps[tug_id] for tug_id, _ in ti)
            if hp_in < p_reqs[v]:
                is_valid = False
            hp_out = sum(tug_hps[tug_id] for tug_id, _ in to)
            if hp_out < p_reqs[v]:
                is_valid = False
            
            # Check timing sequence: inbound_end <= berth_start + eps and outbound_start <= berth_end + eps
            in_end = in_start + tau_ins[v]
            b_end = b_start + ds[v]
            if not (in_end <= b_start + eps and out_start <= b_end + eps):
                is_valid = False
            
            # Note: Global overlaps (e.g., berth/tug conflicts across vessels) are not checked here for succinctness;
            # this focuses on local per-vessel validity.
            
            if is_valid:
                num_valid_full += 1
                valid_vessels.add(v)
        else:
            # For unassigned, add to Z1 and remaining HP
            z1 += penalty * alphas[v]
            remaining_hp += p_reqs[v]
    
    # Compute Z1 for any unassigned (already accumulated above)
    # Note: z1 only includes unassigned; assigned contribute 0 to Z1
    
    # Compute partial objective value
    partial_obj = (objective_weights[0] * z1 +
                   objective_weights[1] * z2 +
                   objective_weights[2] * z3 +
                   objective_weights[3] * z4)
    
    # Compute state values
    assigned_vessels_fraction = num_full_assigned / vessel_num if vessel_num > 0 else 0.0
    unassigned_vessels = vessel_num - num_full_assigned
    full_service_completion_rate = num_valid_full / vessel_num if vessel_num > 0 else 0.0
    potential_conflict_ratio = (num_full_assigned - num_valid_full) / vessel_num if vessel_num > 0 else 0.0
    
    # Utilizations (using full assigned, regardless of validity)
    denom_berth = berth_num * time_periods
    berth_utilization = total_berth_time / denom_berth if denom_berth > 0 else 0.0
    denom_tug = tugboat_num * time_periods
    tug_utilization = total_tug_time / denom_tug if denom_tug > 0 else 0.0
    
    # Average ETA deviation for full assigned (using all full, as deviations are computable)
    avg_eta_deviation_assigned = total_eta_dev / num_full_assigned if num_full_assigned > 0 else 0.0
    
    # Remaining HP for unassigned (already accumulated)
    remaining_hp_demand = remaining_hp
    
    # Schedule progress
    schedule_progress = max_end_time / time_periods if time_periods > 0 else 0.0
    
    # Construct output dictionary
    problem_state = {
        'assigned_vessels_fraction': assigned_vessels_fraction,
        'partial_objective_value': partial_obj,
        'unassigned_vessels': unassigned_vessels,
        'berth_utilization': berth_utilization,
        'tug_utilization': tug_utilization,
        'avg_eta_deviation_assigned': avg_eta_deviation_assigned,
        'remaining_hp_demand': remaining_hp_demand,
        'schedule_progress': schedule_progress,
        'full_service_completion_rate': full_service_completion_rate,
        'potential_conflict_ratio': potential_conflict_ratio
    }
    
    return problem_state

def get_observation_problem_state(solution_problem_state: dict) -> dict:
    """Extract core problem state as observation from solution problem state.

    Args:
        solution_problem_state (dict): The dictionary contains the solution problem state.

    Returns:
        dict: The dictionary contains the core observation problem states with:
            - assigned_vessels_fraction (float): Fraction of vessels with full service assignments.
            - partial_objective_value (float): Partial objective value of the current solution.
            - unassigned_vessels (int): Number of unassigned vessels.
            - berth_utilization (float): Utilization level of berths.
            - tug_utilization (float): Utilization level of tugboats.
            - avg_eta_deviation_assigned (float): Average ETA deviation for assigned vessels.
            - remaining_hp_demand (float): Remaining horsepower demand for unassigned vessels.
            - schedule_progress (float): Progress of the schedule based on maximum end time.
    """
    # Extract the specified keys directly from the input dictionary without any modifications
    # This creates a filtered view of the solution state focused on core observation metrics
    observation_state = {
        'assigned_vessels_fraction': solution_problem_state['assigned_vessels_fraction'],
        'partial_objective_value': solution_problem_state['partial_objective_value'],
        'unassigned_vessels': solution_problem_state['unassigned_vessels'],
        'berth_utilization': solution_problem_state['berth_utilization'],
        'tug_utilization': solution_problem_state['tug_utilization'],
        'avg_eta_deviation_assigned': solution_problem_state['avg_eta_deviation_assigned'],
        'remaining_hp_demand': solution_problem_state['remaining_hp_demand'],
        'schedule_progress': solution_problem_state['schedule_progress']
    }
    
    return observation_state