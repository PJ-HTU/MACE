[
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "I am working on Hyper-heuristics for Combinatorial Operation (CO) problem.\n\nCurrently, I am working on psp problem:\nPort Scheduling Problem (PSP) - Mathematical Model Description\n\nProblem Overview\n\nThe Port Scheduling Problem (PSP) involves optimal allocation of vessels to berths with coordinated tugboat services. The system manages multiple berths with different capacity levels, multiple tugboats with varying horsepower capabilities, and multiple vessels with specific requirements and time constraints.\n\nKey Problem Characteristics\n\nEach vessel must receive three sequential services if allocated:\n1. Inbound tugboat service - to guide vessel to berth\n2. Berthing service - vessel occupies berth for cargo operations\n3. Outbound tugboat service - to guide vessel away from berth\n\nThe services must be properly sequenced and temporally connected within allowable time tolerances. Vessels that cannot receive complete service are penalized heavily.\n\nMathematical Model Formulation\n\nDecision Variables\n- x_ijt \u2208 {0,1}: vessel i starts berthing at berth j at time t (only if berth capacity C\u2c7c \u2265 vessel size S\u1d62)\n- y^in_ikt \u2208 {0,1}: tugboat k starts inbound service for vessel i at time t\n- y^out_ikt \u2208 {0,1}: tugboat k starts outbound service for vessel i at time t\n- z^in_it \u2208 {0,1}: auxiliary variable indicating vessel i starts inbound tugboat service at time t\n- z^out_it \u2208 {0,1}: auxiliary variable indicating vessel i starts outbound tugboat service at time t\n- u^early_i \u2265 0: early deviation from ETA for vessel i\n- u^late_i \u2265 0: late deviation from ETA for vessel i\n\nObjective Function\nMinimize: \u03bb\u2081Z\u2081 + \u03bb\u2082Z\u2082 + \u03bb\u2083Z\u2083 + \u03bb\u2084Z\u2084\n\nWhere:\n- Z\u2081 = \u03a3\u1d62 M\u00b7\u03b1\u1d62\u00b7(1 - \u03a3\u2c7c \u03a3\u209c x_ijt) [Unserved vessel penalty]\n- Z\u2082 = \u03a3\u1d62 \u03b1\u1d62\u00b7\u03b2\u1d62\u00b7[\u03a3\u209c (t + \u03c4^out_i)\u00b7z^out_it - \u03a3\u209c t\u00b7z^in_it] [Total port time cost]\n- Z\u2083 = \u03a3\u1d62 \u03b1\u1d62\u00b7\u03b3\u1d62\u00b7(u^early_i + u^late_i) [ETA deviation cost]\n- Z\u2084 = \u03a3\u2096 \u03a3\u1d62 \u03a3\u209c c\u2096\u00b7(\u03c4^in_i\u00b7y^in_ikt + \u03c4^out_i\u00b7y^out_ikt) [Tugboat utilization cost]\n\nComplete Constraint Set\n\nConstraint (1): Vessel Assignment Constraints\n\u03a3\u2c7c \u03a3\u209c x_ijt \u2264 1, \u2200i \u2208 I\nEach vessel can be assigned at most once.\n\nConstraint (2): Vessel-Berth Compatibility Constraints\nx_ijt = 0, \u2200i \u2208 I, j \u2208 J, t \u2208 T : C\u2c7c < S\u1d62\nVessels can only be assigned to berths with sufficient capacity.\n\nConstraint (3): Inbound Tugboat Service Coupling\n\u03a3\u209c z^in_it = \u03a3\u2c7c \u03a3\u209c x_ijt, \u2200i \u2208 I\nIf a vessel is assigned to any berth, it must receive inbound tugboat service exactly once.\n\nConstraint (4): Outbound Tugboat Service Coupling\n\u03a3\u209c z^out_it = \u03a3\u2c7c \u03a3\u209c x_ijt, \u2200i \u2208 I\nIf a vessel is assigned to any berth, it must receive outbound tugboat service exactly once.\n\nConstraint (5): Tugboat Horsepower Constraints for Inbound\n\u03a3\u2096 P\u2096\u00b7y^in_ikt \u2265 P^req_i\u00b7z^in_it, \u2200i \u2208 I, t \u2208 T\nAssigned tugboats must provide sufficient total horsepower for inbound service.\n\nConstraint (6): Tugboat Horsepower Constraints for Outbound\n\u03a3\u2096 P\u2096\u00b7y^out_ikt \u2265 P^req_i\u00b7z^out_it, \u2200i \u2208 I, t \u2208 T\nAssigned tugboats must provide sufficient total horsepower for outbound service.\n\nConstraint (7): Tugboat Quantity Limits for Inbound\n\u03a3\u2096 y^in_ikt \u2264 H_max\u00b7z^in_it, \u2200i \u2208 I, t \u2208 T\nMaximum number of tugboats per inbound service is limited to H_max.\n\nConstraint (8): Tugboat Quantity Limits for Outbound\n\u03a3\u2096 y^out_ikt \u2264 H_max\u00b7z^out_it, \u2200i \u2208 I, t \u2208 T\nMaximum number of tugboats per outbound service is limited to H_max.\n\nConstraint (9): Auxiliary Variable Definition for Inbound\nz^in_it \u2264 \u03a3\u2096 y^in_ikt, \u2200i \u2208 I, t \u2208 T\nAuxiliary variables for inbound service are properly linked to tugboat assignment variables.\nAdditional requirement: All tugboats serving the same vessel for inbound service must start at the same time.\n\nConstraint (10): Auxiliary Variable Definition for Outbound\nz^out_it \u2264 \u03a3\u2096 y^out_ikt, \u2200i \u2208 I, t \u2208 T\nAuxiliary variables for outbound service are properly linked to tugboat assignment variables.\nAdditional requirement: All tugboats serving the same vessel for outbound service must start at the same time.\n\nConstraint (11): Berth Capacity Constraints\n\u03a3\u1d62 \u03a3\u209c'=max(1,t-D\u1d62+1)^t x_ijt' \u2264 1, \u2200j \u2208 J, t \u2208 T\nEach berth can accommodate at most one vessel at any time, considering vessel duration D\u1d62.\n\nConstraint (12): Tugboat Capacity Constraints (with Preparation Time)\n\u03a3\u1d62 [\u03a3\u209c'=max(1,t-\u03c4^in_i-\u03c1^in+1)^t y^in_ikt' + \u03a3\u209c'=max(1,t-\u03c4^out_i-\u03c1^out+1)^t y^out_ikt'] \u2264 1, \u2200k \u2208 K, t \u2208 T\nEach tugboat can provide only one service at a time, including preparation time between services.\n\nConstraint (13): Inbound Service Time Window Constraints\ny^in_ikt = 0, \u2200i \u2208 I, k \u2208 K, t < ETA\u1d62 - \u0394^early_i or t > ETA\u1d62 + \u0394^late_i\nTugboat inbound services can only start within the vessel's ETA allowed time window.\n\nConstraint (14): Inbound-Berthing Timing Sequence Constraints\n0 \u2264 \u03a3\u2c7c \u03a3\u209c t\u00b7x_ijt - \u03a3\u209c (t + \u03c4^in_i)\u00b7z^in_it \u2264 \u03b5_time\u00b7\u03a3\u2c7c \u03a3\u209c x_ijt, \u2200i \u2208 I\nBerthing must start after inbound service completion, within tolerance \u03b5_time.\n\nConstraint (15): Berthing-Outbound Timing Sequence Constraints\n0 \u2264 \u03a3\u209c t\u00b7z^out_it - \u03a3\u2c7c \u03a3\u209c (t + D\u1d62)\u00b7x_ijt \u2264 \u03b5_time\u00b7\u03a3\u2c7c \u03a3\u209c x_ijt, \u2200i \u2208 I\nOutbound service must start after berthing completion, within tolerance \u03b5_time.\n\nConstraint (16): ETA Deviation Linearization Constraints\n\u03a3\u209c t\u00b7z^in_it = ETA\u1d62 + u^late_i - u^early_i, \u2200i \u2208 I\nLinear representation of ETA deviations for cost calculation.\n\nConstraint (17): Variable Domain Constraints\nu^early_i, u^late_i \u2265 0, \u2200i \u2208 I\nx_ijt, y^in_ikt, y^out_ikt, z^in_it, z^out_it \u2208 {0,1}, \u2200i \u2208 I, j \u2208 J, k \u2208 K, t \u2208 T\nVariable domain constraints for all decision variables.\n\nInput Parameters\n\nVessel Parameters\n- S\u1d62: Size level of vessel i\n- ETA\u1d62: Expected arrival time of vessel i\n- D\u1d62: Berthing duration required by vessel i\n- \u03c4^in_i, \u03c4^out_i: Inbound and outbound tugboat service durations for vessel i\n- P^req_i: Minimum tugboat horsepower required by vessel i\n- \u0394^early_i, \u0394^late_i: Maximum allowed early/late deviations from ETA for vessel i\n- \u03b1\u1d62, \u03b2\u1d62, \u03b3\u1d62: Priority weight, unit waiting cost, and JIT deviation unit cost for vessel i\n\nBerth Parameters\n- C\u2c7c: Capacity level of berth j\n\nTugboat Parameters\n- P\u2096: Horsepower of tugboat k\n- c\u2096: Unit time usage cost of tugboat k\n- \u03c1^in, \u03c1^out: Preparation times for tugboats after completing inbound/outbound services\n\nSystem Parameters\n- H_max: Maximum number of tugboats allowed per service\n- \u03b5_time: Maximum allowed time deviation in sequencing constraints\n- M: Large penalty parameter for unserved vessels\n- \u03bb\u2081, \u03bb\u2082, \u03bb\u2083, \u03bb\u2084: Weighting coefficients in the objective function\n\nProblem Constraints Summary\n\nThe model ensures that:\n1. Each vessel receives complete service (inbound \u2192 berthing \u2192 outbound) or no service at all\n2. Services follow proper temporal sequence with bounded time gaps\n3. Resource capacity constraints are respected for both berths and tugboats\n4. Tugboat horsepower and quantity requirements are satisfied\n5. Tugboat inbound services can only start within the vessel's ETA allowed time window.\n6. Berth-vessel size compatibility is maintained\n7. Tugboat availability considering preparation times is enforced\n8. All tugboats serving the same vessel must start their service at the same time\n\nTo support different heuristic algorithms, I build the Solution and Operator framework.\nThe Solution is designed as:\nclass Solution:\n    \"\"\"The solution of Port Scheduling Problem supporting multi-tugboat services.\nAttributes:\n    vessel_assignments (dict): Maps vessel_id to (berth_id, start_time) tuple. None if vessel is unassigned.\n    tugboat_inbound_assignments (dict): Maps vessel_id to list of tuple (tugboat_id, start_time) for inbound service.\n    tugboat_outbound_assignments (dict): Maps vessel_id to list of tuple (tugboat_id, start_time) for outbound service.\"\"\"\n    def __init__(self, vessel_assignments: dict=None, tugboat_inbound_assignments: dict=None, tugboat_outbound_assignments: dict=None):\n        self.vessel_assignments = vessel_assignments or {}\n        self.tugboat_inbound_assignments = tugboat_inbound_assignments or {}\n        self.tugboat_outbound_assignments = tugboat_outbound_assignments or {}\nOperator servers as a mechanism to modify solution, which enables the application of heuristic algorithms.\u00a0\nTo support heuristic algorithm, we have build the following operators:\nclass CompleteVesselAssignmentOperator(BaseOperator):\n    \"\"\"Assign a vessel to berth with complete multi-tugboat services and feasibility validation.\"\"\"\n    def __init__(self, vessel_id: int, berth_id: int, start_time: int, inbound_tugboats: List[Tuple[int, int]], outbound_tugboats: List[Tuple[int, int]]):\n        self.vessel_id = vessel_id\n        self.berth_id = berth_id\n        self.start_time = start_time\n        self.inbound_tugboats = inbound_tugboats\n        self.outbound_tugboats = outbound_tugboats\n    def run(self, solution: Solution) -> Solution:\n        if not self.inbound_tugboats or not self.outbound_tugboats:\n            return copy.deepcopy(solution)\n        if len(self.inbound_tugboats) > 1:\n            inbound_times = [start_time for _, start_time in self.inbound_tugboats]\n            if len(set(inbound_times)) > 1:\n                return copy.deepcopy(solution)\n        if len(self.outbound_tugboats) > 1:\n            outbound_times = [start_time for _, start_time in self.outbound_tugboats]\n            if len(set(outbound_times)) > 1:\n                return copy.deepcopy(solution)\n        new_vessel_assignments = copy.deepcopy(solution.vessel_assignments)\n        new_tugboat_inbound = copy.deepcopy(solution.tugboat_inbound_assignments)\n        new_tugboat_outbound = copy.deepcopy(solution.tugboat_outbound_assignments)\n        new_vessel_assignments[self.vessel_id] = (self.berth_id, self.start_time)\n        new_tugboat_inbound[self.vessel_id] = copy.deepcopy(self.inbound_tugboats)\n        new_tugboat_outbound[self.vessel_id] = copy.deepcopy(self.outbound_tugboats)\n        return Solution(vessel_assignments=new_vessel_assignments, tugboat_inbound_assignments=new_tugboat_inbound, tugboat_outbound_assignments=new_tugboat_outbound)\nclass UnassignVesselOperator(BaseOperator):\n    \"\"\"Remove assignment for a vessel.\"\"\"\n    def __init__(self, vessel_id: int):\n        self.vessel_id = vessel_id\n    def run(self, solution: Solution) -> Solution:\n        new_vessel_assignments = copy.deepcopy(solution.vessel_assignments)\n        new_tugboat_inbound = copy.deepcopy(solution.tugboat_inbound_assignments)\n        new_tugboat_outbound = copy.deepcopy(solution.tugboat_outbound_assignments)\n        new_vessel_assignments[self.vessel_id] = None\n        new_tugboat_inbound[self.vessel_id] = []\n        new_tugboat_outbound[self.vessel_id] = []\n        return Solution(vessel_assignments=new_vessel_assignments, tugboat_inbound_assignments=new_tugboat_inbound, tugboat_outbound_assignments=new_tugboat_outbound)\n\nIn pursuit of augmenting our heuristic algorithmic suite, we require the following standardized heuristic function signature:\ndef heuristic(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[TargetOperatorType, dict]:\nThe inputs are:\nproblem_state (dict): A dictionary containing the problem state information, organized into five categories of keys:\n1. Input Data:\n    - vessel_num (int): The total number of vessels requesting berthing service.\n    - berth_num (int): The total number of berths available at the port.\n    - tugboat_num (int): The total number of tugboats available for service.\n    - time_periods (int): The total number of time periods in the scheduling horizon.\n    - vessel_sizes (numpy.ndarray): 1D array of size levels for each vessel (Si).\n    - berth_capacities (numpy.ndarray): 1D array of capacity levels for each berth (Cj).\n    - vessel_etas (numpy.ndarray): 1D array of expected arrival times for each vessel (ETAi).\n    - vessel_durations (numpy.ndarray): 1D array of berthing durations required by each vessel (Di).\n    - vessel_inbound_service_times (numpy.ndarray): 1D array of inbound tugboat service durations for each vessel.\n    - vessel_outbound_service_times (numpy.ndarray): 1D array of outbound tugboat service durations for each vessel.\n    - vessel_priority_weights (numpy.ndarray): 1D array of priority weights for each vessel.\n    - vessel_waiting_costs (numpy.ndarray): 1D array of unit waiting costs for each vessel.\n    - vessel_jit_costs (numpy.ndarray): 1D array of JIT deviation unit costs for each vessel.\n    - vessel_horsepower_requirements (numpy.ndarray): 1D array of minimum tugboat horsepower required by each vessel.\n    - vessel_early_limits (numpy.ndarray): 1D array of maximum early arrival allowances for each vessel.\n    - vessel_late_limits (numpy.ndarray): 1D array of maximum late arrival allowances for each vessel.\n    - tugboat_horsepower (numpy.ndarray): 1D array of horsepower for each tugboat.\n    - tugboat_costs (numpy.ndarray): 1D array of unit time usage costs for each tugboat.\n    - inbound_preparation_time (int): Preparation time for tugboats after completing inbound service (rho_in).\n    - outbound_preparation_time (int): Preparation time for tugboats after completing outbound service (rho_out).\n    - max_tugboats_per_service (int): Maximum number of tugboats allowed for a single service (Hmax).\n    - time_constraint_tolerance (float): Maximum allowed time deviation in timing constraints (epsilon_time).\n    - penalty_parameter (float): Large penalty parameter for unserved vessels.\n    - objective_weights (numpy.ndarray): 1D array of four weighting coefficients [lambda_1, lambda_2, lambda_3, lambda_4] for objective function components.\n2. Current Solution:\n    - current_solution (Solution): Current solution instance.\n    - total_scheduling_cost (float): The total scheduling cost of the current solution.\n3. Helper Functions (these Functions may help you to generation the following heuristic):\n    - get_problem_state (callable): def get_problem_state(solution: Solution) -> dict: The function to get the complete problem state for given solution without modifying it. Returns a dictionary containing state information.\n    - validation_solution (callable): def validation_solution(solution: Solution = None) -> bool: The function to check whether the solution is valid according to all mathematical model constraints. If solution is None, checks current solution. Returns True if valid, False otherwise.\n    - get_unassigned_vessels (callable): def get_unassigned_vessels(solution: Solution = None) -> list[int]: Get list of vessel IDs that have not been assigned to any berth. If solution is None, uses current solution. Returns list of integers representing unassigned vessel IDs (range 0 to vessel_num-1).\n    - get_vessel_time_window (callable): def get_vessel_time_window(vessel_id: int) -> tuple[int, int]: Get the feasible time window (earliest_start, latest_start) for vessel's inbound service considering ETA and early/late limits. Returns tuple of two integers representing the valid start time range.\n    - get_compatible_berths (callable): def get_compatible_berths(vessel_id: int) -> list[int]: Get list of berth IDs that can serve the vessel based on capacity level compatibility (berth_capacity >= vessel_size). Returns list of integers representing compatible berth IDs (range 0 to berth_num-1).\n    - is_berth_available (callable): def is_berth_available(berth_id: int, start_time: int, duration: int, solution: Solution = None) -> bool: Check if a berth is free during the specified time period [start_time, start_time + duration) without conflicts with existing assignments. If solution is None, uses current solution. Returns True if available, False if conflicted.\n    - is_tugboat_available (callable): def is_tugboat_available(tugboat_id: int, start_time: int, duration: int, prep_time: int = 0, solution: Solution = None) -> bool: Check if a tugboat is free during the specified service period [start_time, start_time + duration + prep_time) including preparation time. If solution is None, uses current solution. Returns True if available, False if conflicted.\n    - find_tugboat_combination (callable): def find_tugboat_combination(vessel_id: int, start_time: int, service_type: str, solution: Solution = None) -> tuple: Find a tugboat combination with sufficient horsepower for the service using greedy selection. The service_type parameter accepts 'inbound' or 'outbound'. Uses greedy strategy sorting tugboats by horsepower descending to minimize the number of tugboats needed. If greedy fails, performs exhaustive search to find any valid combination. Returns (selected_tugboats, total_cost) where selected_tugboats is a list of (tugboat_id, start_time) tuples, or (None, 0) if no valid combination found that meets horsepower requirements within tugboat quantity limits.\n    - find_feasible_assignments (callable): def find_feasible_assignments(vessel_id: int, max_results: int = 3, solution: Solution = None) -> list[dict]: Find a feasible complete assignment (berth + multi-tugboat services) for a vessel using ETA-centered heuristic search. Tries candidate inbound times near ETA (ETA \u00b1 {0,1,2,3,4}) in order of proximity to ETA. Uses tight scheduling with berth starting immediately after inbound service and outbound starting immediately after berthing. Returns immediately upon finding the first valid assignment. Returns list containing at most one dictionary with: {'berth_id': int, 'start_time': int, 'inbound_tugboats': list[tuple[int, int]], 'outbound_tugboats': list[tuple[int, int]], 'total_cost': float}. The tugboat lists contain multiple tuples of (tugboat_id, start_time) representing tugboat combinations that meet horsepower requirements. All timing constraints and horsepower constraints are properly handled. Returns empty list if no feasible assignment found.\n    - calculate_assignment_cost (callable): def calculate_assignment_cost(vessel_id: int, berth_id: int, start_time: int, inbound_tugboats: list, outbound_tugboats: list) -> float: Calculate the total cost for a specific vessel assignment including port time cost (Z2), ETA deviation cost (Z3), and tugboat utilization cost (Z4). The inbound_tugboats and outbound_tugboats parameters are lists of (tugboat_id, start_time) tuples representing multi-tugboat combinations. Returns float representing the assignment cost, or float('inf') if assignment is invalid.\n4. Instance Statistics (these Instance Statistics may help you to generation the following heuristic):\n   - num_vessels (int): Number of vessels.\n    - num_berths (int): Number of berths.\n    - num_tugboats (int): Number of tugboats.\n    - avg_vessel_size (float): Average vessel size.\n    - var_vessel_size (float): Variance of vessel sizes.\n    - total_required_hp (float): Total required horsepower for all vessels.\n    - total_available_hp (float): Total available horsepower from all tugboats.\n    - eta_span (float): Span between maximum and minimum ETA.\n    - avg_berthing_duration (float): Average berthing duration.\n    - vessel_arrival_density (float): Density of vessel arrivals (num_vessels / eta_span).\n    - avg_time_window_flex (float): Average flexibility in time windows (mean of early + late limits).\n    - berth_capacity_ratio (float): Ratio of average berth capacity to average vessel size.\n5. Current Solution Statistics (these Solution Statistics may help you to generation the following heuristic):\n    - assigned_vessels_fraction (float): Fraction of vessels with full service assignments (inbound, berthing, outbound).\n    - partial_objective_value (float): Partial objective value computed as weighted sum of Z1 to Z4 for the current assignments.\n    - unassigned_vessels (int): Number of vessels without full service assignments.\n    - berth_utilization (float): Utilization of berths based on assigned berthing durations.\n    - tug_utilization (float): Utilization of tugboats based on assigned service durations.\n    - avg_eta_deviation_assigned (float): Average ETA deviation for vessels with full assignments.\n    - remaining_hp_demand (float): Total horsepower requirement for unassigned vessels.\n    - schedule_progress (float): Progress as the maximum end time of assigned services normalized by time periods.\n    - full_service_completion_rate (float): Fraction of vessels with full and valid service assignments (no local violations).\n    - potential_conflict_ratio (float): Ratio of full assignments that have local violations.\nalgorithm_data(dict): Algorithm data contains the data that necessary for some algorithms.\nOther hyper-parameters in kwargs.\nThe outputs includes the operator that must be an instance of a predefined target operator type and updated algorithm dict, which contains new information for future work for both this or other algorithm.\n\nPlease consider is psp a combinatorial operation problem and can be solved by heuristics?\nIf you think this problem is not a combinatorial operation problem or the solution, operator, data are incorrect, response ***is_cop:no*** to me, or response ***is_cop:yes***.\n\nThe response format is very important. For better communication, please respond to me in this format:\n***is_cop:yes/no***\nEnsure there is no other content inside the ***, and analysis outside *** is welcome.\nIf you have no information to provide, simply respond with ***None***."
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***is_cop:yes***\n\nThe Port Scheduling Problem (PSP) is indeed a classic example of a combinatorial optimization (CO) problem. It involves discrete decision-making\u2014such as assigning vessels to specific berths at discrete times, selecting combinations of tugboats for inbound/outbound services, and ensuring feasibility under constraints like capacity, horsepower requirements, timing sequences, and resource availability. The objective is to minimize a multi-component cost function (penalties for unserved vessels, port time, ETA deviations, and tugboat usage), which aligns with CO characteristics: a finite search space of feasible combinations, NP-hard complexity due to scheduling and resource allocation interdependencies, and the need for optimization over exponential possibilities.\n\nHeuristics (and hyper-heuristics) are well-suited for solving PSP, as exact methods (e.g., MILP solvers) may be intractable for realistic instances with large time horizons, multiple vessels, berths, and tugboats. Your framework supports this effectively: the Solution class encapsulates the state (assignments for vessels and tugboats), operators like CompleteVesselAssignmentOperator and UnassignVesselOperator enable local search/modifications, and the provided helper functions (e.g., find_tugboat_combination, find_feasible_assignments) facilitate greedy, nearest-neighbor, or metaheuristic approaches. The heuristic signature allows generating targeted operators (e.g., for assigning unserved vessels or resolving conflicts) while updating algorithm data for iterative improvement, making it extensible for methods like genetic algorithms, simulated annealing, or hyper-heuristic selection.\n\nPotential enhancements: Consider adding operators for swapping assignments between vessels or adjusting timings to handle dynamic densities (using instance stats like vessel_arrival_density). Validation via the mathematical constraints ensures heuristic-generated solutions remain feasible or quantifiable in terms of violations. Overall, the setup is solid and correctly oriented toward CO heuristics."
            }
        ]
    },
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "I need your help to design different 5 basic heuristics for the psp problem.\n\n## Heuristic Requirements:\n1. **Constructive Nature**: Each heuristic must be constructive (or constructive followed by improvement), and build solutions step-by-step from scratch.\n\n2. **Diversity**: The 5 heuristics should represent different strategies to ensure diversity in solution approaches.\n\nThe problem will work on following data.\nPlease try to understand the data and generate based on them, especially setting the default value for hyper-parameters:\nAll data is possible\n\nThe response format is very important. For better communication, please respond to me in this format:\n***heuristic:\nheuristic_name: only text description\nheuristic_name: only text description\n....\n***\nEnsure there is no other content (including blank lines) inside the ***, and analysis outside *** is welcome.\nIf you have no information to provide, simply respond with ***None***."
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***heuristic:\nEarliest Arrival First (EAF): Sort unassigned vessels by increasing ETA; for each vessel in order, use find_feasible_assignments to select the earliest available assignment within its time window, preferring the compatible berth with highest remaining capacity; apply CompleteVesselAssignmentOperator to add the assignment if feasible, tracking total cost.\nLargest Vessel First (LVF): Prioritize unassigned vessels by decreasing vessel size (S_i); for each, identify compatible berths via get_compatible_berths, then use find_tugboat_combination for inbound/outbound at the median of the vessel's time window; assign to the berth with lowest current utilization using is_berth_available, applying the operator only if all resources (tugboats via is_tugboat_available) are free.\nCost-Minimizing Greedy (CMG): Iterate over unassigned vessels in random order; for each, generate up to 5 candidate assignments via find_feasible_assignments, compute costs with calculate_assignment_cost, and select the one with minimal marginal cost increase to total_scheduling_cost; apply CompleteVesselAssignmentOperator for the best, updating solution statistics.\nRandomized Sequential (RS): Randomly permute all vessel IDs; sequentially attempt assignments starting from an empty solution; for each vessel, sample 3 random start times within get_vessel_time_window, check berth/tugboat availability, and use find_tugboat_combination; apply operator for the first feasible option found, defaulting to unassign if none.\nUtilization-Balanced (UB): Sort vessels by decreasing priority weight (\u03b1_i); for each, select the compatible berth with the lowest current utilization (from berth_utilization stat); center the start time on ETA, adjust by up to avg_time_window_flex to fit availability; find tugboat combos minimizing tug_utilization impact, apply operator if validation_solution passes post-assignment.\n***\n\nThese heuristics are designed to be constructive, starting from an empty solution (all vessels unassigned) and iteratively building by applying CompleteVesselAssignmentOperator (or UnassignVesselOperator implicitly for failures). Diversity comes from prioritization (ETA, size, cost, random, priority/utilization), selection criteria (earliest, median/random, cost-min, balanced), and use of helpers like find_feasible_assignments for feasibility. Default hyperparameters: max_results=3 in find_feasible_assignments, up to 5 candidates in CMG, sample size=3 in RS; all leverage instance stats (e.g., avg_time_window_flex=mean(\u0394^early_i + \u0394^late_i)) for robustness. An improvement phase could follow each by re-running on unassigned vessels, but kept basic as per requirements. For implementation, TargetOperatorType would be CompleteVesselAssignmentOperator or UnassignVesselOperator, with algorithm_data updated to include iteration count or partial costs."
            }
        ]
    },
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "Based on previous discuss, we get the heuristic Utilization-Balanced (UB):\n Sort vessels by decreasing priority weight (\u03b1_i); for each, select the compatible berth with the lowest current utilization (from berth_utilization stat); center the start time on ETA, adjust by up to avg_time_window_flex to fit availability; find tugboat combos minimizing tug_utilization impact, apply operator if validation_solution passes post-assignment..\n\nNow please implement it in python function utilization_balanced_ub_eb0a.\n\nTo implement this heuristic function in python, please note:\n1. We can assume that Solution and all Operators are imported.\n2. The operator type must be defined previously, do not create a new one in your code.\n3. Never modify the data in problem_state.\n4. All hyper parameters in kwargs should be set a default value.\n5. Any reasonable partial solution may be used as input, such as an empty solution.\n6. Comments in the code are very important. They must clearly explain which hyper-parameters are required by the algorithm (i.e., the parameters in **kwargs), how the algorithm proceeds, and under what circumstances it will not return any operator or will return an empty operator. We hope that people can understand the principles and workflow of the algorithm clearly just by reading the comments, without needing to look at the code.\n7. The name of function must be utilization_balanced_ub_eb0a. The TargetOperatorType should be replaced by real returned operator type.\n8. No any omissions or placeholders, I'm just going to use the code.\n9. For the algorithm to update the algorithm_data, do not modify directly \"algorithm_data[\"abc\"] = 123\", we should return operator, {\"abc\": 123}.For algorithm that do not update them, just return operator, {}\n10. For the circumstances that algorithm return empty operator, please return None, {}.\n11. Do not forget to check whether the content is empty when calculating the min/max/average/std/..., such as when using min([distance[node][other] for other in nodes if other != node]).\n12. Make the result must be valid.\n13. Do not forget the input problem_state:\nproblem_state (dict): A dictionary containing the problem state information, organized into five categories of keys:\n1. Input Data:\n    - vessel_num (int): The total number of vessels requesting berthing service.\n    - berth_num (int): The total number of berths available at the port.\n    - tugboat_num (int): The total number of tugboats available for service.\n    - time_periods (int): The total number of time periods in the scheduling horizon.\n    - vessel_sizes (numpy.ndarray): 1D array of size levels for each vessel (Si).\n    - berth_capacities (numpy.ndarray): 1D array of capacity levels for each berth (Cj).\n    - vessel_etas (numpy.ndarray): 1D array of expected arrival times for each vessel (ETAi).\n    - vessel_durations (numpy.ndarray): 1D array of berthing durations required by each vessel (Di).\n    - vessel_inbound_service_times (numpy.ndarray): 1D array of inbound tugboat service durations for each vessel.\n    - vessel_outbound_service_times (numpy.ndarray): 1D array of outbound tugboat service durations for each vessel.\n    - vessel_priority_weights (numpy.ndarray): 1D array of priority weights for each vessel.\n    - vessel_waiting_costs (numpy.ndarray): 1D array of unit waiting costs for each vessel.\n    - vessel_jit_costs (numpy.ndarray): 1D array of JIT deviation unit costs for each vessel.\n    - vessel_horsepower_requirements (numpy.ndarray): 1D array of minimum tugboat horsepower required by each vessel.\n    - vessel_early_limits (numpy.ndarray): 1D array of maximum early arrival allowances for each vessel.\n    - vessel_late_limits (numpy.ndarray): 1D array of maximum late arrival allowances for each vessel.\n    - tugboat_horsepower (numpy.ndarray): 1D array of horsepower for each tugboat.\n    - tugboat_costs (numpy.ndarray): 1D array of unit time usage costs for each tugboat.\n    - inbound_preparation_time (int): Preparation time for tugboats after completing inbound service (rho_in).\n    - outbound_preparation_time (int): Preparation time for tugboats after completing outbound service (rho_out).\n    - max_tugboats_per_service (int): Maximum number of tugboats allowed for a single service (Hmax).\n    - time_constraint_tolerance (float): Maximum allowed time deviation in timing constraints (epsilon_time).\n    - penalty_parameter (float): Large penalty parameter for unserved vessels.\n    - objective_weights (numpy.ndarray): 1D array of four weighting coefficients [lambda_1, lambda_2, lambda_3, lambda_4] for objective function components.\n2. Current Solution:\n    - current_solution (Solution): Current solution instance.\n    - total_scheduling_cost (float): The total scheduling cost of the current solution.\n3. Helper Functions (these Functions may help you to generation the following heuristic):\n    - get_problem_state (callable): def get_problem_state(solution: Solution) -> dict: The function to get the complete problem state for given solution without modifying it. Returns a dictionary containing state information.\n    - validation_solution (callable): def validation_solution(solution: Solution = None) -> bool: The function to check whether the solution is valid according to all mathematical model constraints. If solution is None, checks current solution. Returns True if valid, False otherwise.\n    - get_unassigned_vessels (callable): def get_unassigned_vessels(solution: Solution = None) -> list[int]: Get list of vessel IDs that have not been assigned to any berth. If solution is None, uses current solution. Returns list of integers representing unassigned vessel IDs (range 0 to vessel_num-1).\n    - get_vessel_time_window (callable): def get_vessel_time_window(vessel_id: int) -> tuple[int, int]: Get the feasible time window (earliest_start, latest_start) for vessel's inbound service considering ETA and early/late limits. Returns tuple of two integers representing the valid start time range.\n    - get_compatible_berths (callable): def get_compatible_berths(vessel_id: int) -> list[int]: Get list of berth IDs that can serve the vessel based on capacity level compatibility (berth_capacity >= vessel_size). Returns list of integers representing compatible berth IDs (range 0 to berth_num-1).\n    - is_berth_available (callable): def is_berth_available(berth_id: int, start_time: int, duration: int, solution: Solution = None) -> bool: Check if a berth is free during the specified time period [start_time, start_time + duration) without conflicts with existing assignments. If solution is None, uses current solution. Returns True if available, False if conflicted.\n    - is_tugboat_available (callable): def is_tugboat_available(tugboat_id: int, start_time: int, duration: int, prep_time: int = 0, solution: Solution = None) -> bool: Check if a tugboat is free during the specified service period [start_time, start_time + duration + prep_time) including preparation time. If solution is None, uses current solution. Returns True if available, False if conflicted.\n    - find_tugboat_combination (callable): def find_tugboat_combination(vessel_id: int, start_time: int, service_type: str, solution: Solution = None) -> tuple: Find a tugboat combination with sufficient horsepower for the service using greedy selection. The service_type parameter accepts 'inbound' or 'outbound'. Uses greedy strategy sorting tugboats by horsepower descending to minimize the number of tugboats needed. If greedy fails, performs exhaustive search to find any valid combination. Returns (selected_tugboats, total_cost) where selected_tugboats is a list of (tugboat_id, start_time) tuples, or (None, 0) if no valid combination found that meets horsepower requirements within tugboat quantity limits.\n    - find_feasible_assignments (callable): def find_feasible_assignments(vessel_id: int, max_results: int = 3, solution: Solution = None) -> list[dict]: Find a feasible complete assignment (berth + multi-tugboat services) for a vessel using ETA-centered heuristic search. Tries candidate inbound times near ETA (ETA \u00b1 {0,1,2,3,4}) in order of proximity to ETA. Uses tight scheduling with berth starting immediately after inbound service and outbound starting immediately after berthing. Returns immediately upon finding the first valid assignment. Returns list containing at most one dictionary with: {'berth_id': int, 'start_time': int, 'inbound_tugboats': list[tuple[int, int]], 'outbound_tugboats': list[tuple[int, int]], 'total_cost': float}. The tugboat lists contain multiple tuples of (tugboat_id, start_time) representing tugboat combinations that meet horsepower requirements. All timing constraints and horsepower constraints are properly handled. Returns empty list if no feasible assignment found.\n    - calculate_assignment_cost (callable): def calculate_assignment_cost(vessel_id: int, berth_id: int, start_time: int, inbound_tugboats: list, outbound_tugboats: list) -> float: Calculate the total cost for a specific vessel assignment including port time cost (Z2), ETA deviation cost (Z3), and tugboat utilization cost (Z4). The inbound_tugboats and outbound_tugboats parameters are lists of (tugboat_id, start_time) tuples representing multi-tugboat combinations. Returns float representing the assignment cost, or float('inf') if assignment is invalid.\n4. Instance Statistics (these Instance Statistics may help you to generation the following heuristic):\n   - num_vessels (int): Number of vessels.\n    - num_berths (int): Number of berths.\n    - num_tugboats (int): Number of tugboats.\n    - avg_vessel_size (float): Average vessel size.\n    - var_vessel_size (float): Variance of vessel sizes.\n    - total_required_hp (float): Total required horsepower for all vessels.\n    - total_available_hp (float): Total available horsepower from all tugboats.\n    - eta_span (float): Span between maximum and minimum ETA.\n    - avg_berthing_duration (float): Average berthing duration.\n    - vessel_arrival_density (float): Density of vessel arrivals (num_vessels / eta_span).\n    - avg_time_window_flex (float): Average flexibility in time windows (mean of early + late limits).\n    - berth_capacity_ratio (float): Ratio of average berth capacity to average vessel size.\n5. Current Solution Statistics (these Solution Statistics may help you to generation the following heuristic):\n    - assigned_vessels_fraction (float): Fraction of vessels with full service assignments (inbound, berthing, outbound).\n    - partial_objective_value (float): Partial objective value computed as weighted sum of Z1 to Z4 for the current assignments.\n    - unassigned_vessels (int): Number of vessels without full service assignments.\n    - berth_utilization (float): Utilization of berths based on assigned berthing durations.\n    - tug_utilization (float): Utilization of tugboats based on assigned service durations.\n    - avg_eta_deviation_assigned (float): Average ETA deviation for vessels with full assignments.\n    - remaining_hp_demand (float): Total horsepower requirement for unassigned vessels.\n    - schedule_progress (float): Progress as the maximum end time of assigned services normalized by time periods.\n    - full_service_completion_rate (float): Fraction of vessels with full and valid service assignments (no local violations).\n    - potential_conflict_ratio (float): Ratio of full assignments that have local violations.\n\nFor psp problem, take about following:\n1. Consider partial solution as input where some vessels may be unassigned.\n2. When calculating costs, consider all four components: unserved vessel penalties, port time costs, ETA deviation costs, and tugboat utilization costs.\n3. Make the result must be valid. \n\nThe problem will work on following data.\nPlease try to understand the data and generate based on them, especially setting the default value for hyper-parameters:\nAll data is possible\n\nThe response format is very important. For better communication, please respond to me in this format:\n***python_code:\nfrom src.problems.psp.components import *\nimport other_library (if necessary)\ndef utilization_balanced_ub_eb0a(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[TargetOperatorType, dict]:\n    \"\"\" Description for this heuristic algorithm.\n\n    Args:\n        problem_state (dict): The dictionary contains the problem state.. In this algorithm, the following items are necessary:\n            - necessary_key (value type): description\n            - necessary_key (value type): description\n            ...\n        (Optional and can be omitted if no algorithm data) algorithm_data (dict): The algorithm dictionary for current algorithm only. In this algorithm, the following items are necessary:\n            - necessary_key (value type): description\n            - necessary_key (value type): description\n            ...\n        (Optional and can be omitted if no hyper parameters data) introduction for hyper parameters in kwargs if used.\n\n    Returns:\n        Description of this operator.\n        Description of updated algorithm data.\n\n        ...\n    \"\"\"\nEnsure there is no other content inside the ***, ,and analysis outside *** is welcome.\nIf you have no information to provide, simply respond with ***None***.\n"
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***python_code:\nfrom src.problems.psp.components import *\nimport numpy as np\nimport copy\n\ndef utilization_balanced_ub_eb0a(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[CompleteVesselAssignmentOperator, dict]:\n    \"\"\"\n    Utilization-Balanced (UB) Heuristic: A constructive heuristic that prioritizes unassigned vessels by decreasing priority weight (\u03b1_i) and attempts to assign the highest-priority vessel to a compatible berth with the lowest current utilization. The inbound service start time is centered on the vessel's ETA and adjusted within the average time window flexibility to find a feasible slot. Tugboat combinations are found using the provided helper to minimize the number of tugs (indirectly balancing utilization by efficiency), with availability checks ensuring no conflicts. The assignment is applied only if the post-assignment solution validates fully. This heuristic builds incrementally on partial solutions by assigning one vessel per invocation, promoting balanced resource use across berths and tugs.\n\n    Hyper-parameters in kwargs (with defaults):\n    - max_time_adjust (int, default=5): Maximum number of time adjustments around ETA (i.e., candidates = ETA \u00b1 max_time_adjust, clipped to time window).\n    - time_step (int, default=1): Step size for generating candidate inbound times around ETA.\n    - min_tug_util_threshold (float, default=0.8): Skip tug combinations if any selected tug's current utilization exceeds this threshold (to minimize impact on heavily used tugs).\n\n    Args:\n        problem_state (dict): The dictionary contains the problem state. In this algorithm, the following items are necessary:\n            - current_solution (Solution): Current partial solution instance to build upon.\n            - vessel_num (int): Total number of vessels.\n            - time_periods (int): Total scheduling horizon in time units.\n            - vessel_priority_weights (numpy.ndarray): Priority weights \u03b1_i for sorting vessels.\n            - vessel_etas (numpy.ndarray): Expected arrival times ETA_i for centering start times.\n            - vessel_sizes (numpy.ndarray): Vessel sizes S_i for compatibility.\n            - vessel_durations (numpy.ndarray): Berthing durations D_i for availability checks.\n            - vessel_inbound_service_times (numpy.ndarray): Inbound service durations \u03c4^in_i.\n            - vessel_outbound_service_times (numpy.ndarray): Outbound service durations \u03c4^out_i.\n            - vessel_horsepower_requirements (numpy.ndarray): Required HP P^req_i for tug selection.\n            - berth_capacities (numpy.ndarray): Berth capacities C_j for compatibility.\n            - tugboat_horsepower (numpy.ndarray): Tugboat HP P_k.\n            - tugboat_costs (numpy.ndarray): Tugboat costs c_k (unused directly but available).\n            - inbound_preparation_time (int): Prep time \u03c1^in after inbound.\n            - outbound_preparation_time (int): Prep time \u03c1^out after outbound.\n            - max_tugboats_per_service (int): H_max limit per service.\n            - avg_time_window_flex (float): Average flexibility for time adjustments.\n            - get_unassigned_vessels (callable): To get list of unassigned vessel IDs.\n            - get_vessel_time_window (callable): To get [earliest, latest] for inbound.\n            - get_compatible_berths (callable): Compatible berths for vessel.\n            - is_berth_available (callable): Berth availability check.\n            - is_tugboat_available (callable): Tugboat availability check.\n            - find_tugboat_combination (callable): To find tug combos for services.\n            - validation_solution (callable): To validate post-assignment feasibility.\n        algorithm_data (dict): Not used in this heuristic (empty dict expected).\n        **kwargs: Hyper-parameters as described above.\n\n    Returns:\n        CompleteVesselAssignmentOperator: Operator to assign the highest-priority unassigned vessel to a balanced berth/time/tug setup if feasible and valid post-assignment; None if no unassigned vessels or no feasible assignment found for the top vessel.\n        dict: Empty dict {} as no algorithm data is updated by this heuristic.\n    \"\"\"\n    # Hyper-parameter defaults\n    max_time_adjust = kwargs.get('max_time_adjust', 5)\n    time_step = kwargs.get('time_step', 1)\n    min_tug_util_threshold = kwargs.get('min_tug_util_threshold', 0.8)\n\n    # Extract necessary data from problem_state (never modify originals)\n    current_solution = problem_state['current_solution']\n    vessel_priority_weights = problem_state['vessel_priority_weights']\n    vessel_etas = problem_state['vessel_etas']\n    vessel_sizes = problem_state['vessel_sizes']\n    vessel_durations = problem_state['vessel_durations']\n    vessel_inbound_service_times = problem_state['vessel_inbound_service_times']\n    vessel_outbound_service_times = problem_state['vessel_outbound_service_times']\n    vessel_horsepower_requirements = problem_state['vessel_horsepower_requirements']\n    berth_capacities = problem_state['berth_capacities']\n    tugboat_horsepower = problem_state['tugboat_horsepower']\n    inbound_preparation_time = problem_state['inbound_preparation_time']\n    outbound_preparation_time = problem_state['outbound_preparation_time']\n    max_tugboats_per_service = problem_state['max_tugboats_per_service']\n    time_periods = problem_state['time_periods']\n    avg_time_window_flex = problem_state['avg_time_window_flex']\n\n    # Helper functions from problem_state (assumed available)\n    get_unassigned_vessels = problem_state['get_unassigned_vessels']\n    get_vessel_time_window = problem_state['get_vessel_time_window']\n    get_compatible_berths = problem_state['get_compatible_berths']\n    is_berth_available = problem_state['is_berth_available']\n    is_tugboat_available = problem_state['is_tugboat_available']\n    find_tugboat_combination = problem_state['find_tugboat_combination']\n    validation_solution = problem_state['validation_solution']\n\n    # Step 1: Get and sort unassigned vessels by decreasing priority weight (\u03b1_i)\n    unassigned_vessels = get_unassigned_vessels(current_solution)\n    if not unassigned_vessels:\n        # No unassigned vessels: nothing to do, return empty\n        return None, {}\n\n    # Sort by decreasing priority; take the highest priority one (process one vessel per invocation for incremental construction)\n    sorted_unassigned = sorted(unassigned_vessels, key=lambda i: -vessel_priority_weights[i])\n    vessel_id = sorted_unassigned[0]  # Focus on top priority vessel\n\n    # Step 2: Get compatible berths\n    compatible_berths = get_compatible_berths(vessel_id)\n    if not compatible_berths:\n        # No compatible berths: cannot assign, return empty\n        return None, {}\n\n    # Step 3: Compute current per-berth utilization (occupied time / time_periods)\n    # Utilization: for each berth, sum D_i of assigned vessels to it (no overlaps due to constraints)\n    berth_occupied = np.zeros(len(berth_capacities))\n    for assigned_vessel, (b_id, start_t) in current_solution.vessel_assignments.items():\n        if assigned_vessel != vessel_id and start_t is not None:  # Exclude self if partially assigned (but unassigned, so safe)\n            berth_occupied[b_id] += vessel_durations[assigned_vessel]\n    berth_utilizations = berth_occupied / time_periods if time_periods > 0 else np.zeros(len(berth_occupied))\n\n    # Select compatible berth with lowest utilization (tie-break by smallest ID)\n    valid_berths = [(b, berth_utilizations[b]) for b in compatible_berths]\n    if not valid_berths:\n        return None, {}\n    selected_berth_id = min(valid_berths, key=lambda x: (x[1], x[0]))[0]  # min util, then min ID\n\n    # Step 4: Compute per-tug utilization for tug selection (to check threshold later)\n    # For each tug, sum (service_duration + prep) over all its assignments (inbound + outbound)\n    tug_occupied = np.zeros(len(tugboat_horsepower))\n    for v, inbound_list in current_solution.tugboat_inbound_assignments.items():\n        for (k, t) in inbound_list:\n            if t is not None:\n                tug_occupied[k] += vessel_inbound_service_times[v] + inbound_preparation_time\n    for v, outbound_list in current_solution.tugboat_outbound_assignments.items():\n        for (k, t) in outbound_list:\n            if t is not None:\n                tug_occupied[k] += vessel_outbound_service_times[v] + outbound_preparation_time\n    tug_utilizations = tug_occupied / time_periods if time_periods > 0 else np.zeros(len(tug_occupied))\n\n    # Step 5: Generate candidate inbound times centered on ETA, adjusted up to flex\n    eta = vessel_etas[vessel_id]\n    time_window = get_vessel_time_window(vessel_id)\n    earliest_inbound, latest_inbound = time_window\n    max_adjust = min(max_time_adjust, int(avg_time_window_flex))  # Cap by avg flex\n\n    # Candidates: around ETA, step by time_step, within window\n    candidate_inbounds = []\n    for delta in range(-max_adjust, max_adjust + 1, time_step):\n        cand_time = max(earliest_inbound, min(latest_inbound, eta + delta))\n        if cand_time not in candidate_inbounds:  # Avoid duplicates\n            candidate_inbounds.append(cand_time)\n    # Sort candidates by proximity to ETA (minimize deviation)\n    candidate_inbounds.sort(key=lambda t: abs(t - eta))\n\n    # Step 6: For each candidate inbound time, try to find feasible tight schedule\n    best_operator = None\n    for inbound_time in candidate_inbounds:\n        # Compute derived times (tight sequencing: no extra tolerance beyond epsilon, but check availability)\n        inbound_duration = vessel_inbound_service_times[vessel_id]\n        berthing_start = inbound_time + inbound_duration  # Start berthing right after inbound\n        berthing_duration = vessel_durations[vessel_id]\n        if berthing_start + berthing_duration > time_periods:\n            continue  # Exceeds horizon\n\n        outbound_start = berthing_start + berthing_duration  # Start outbound right after berthing\n        outbound_duration = vessel_outbound_service_times[vessel_id]\n\n        # Check berth availability for [berthing_start, berthing_start + berthing_duration)\n        if not is_berth_available(selected_berth_id, berthing_start, berthing_duration, current_solution):\n            continue\n\n        # Find inbound tug combination (greedy minimizes number, balancing load indirectly)\n        inbound_tugs, _ = find_tugboat_combination(vessel_id, inbound_time, 'inbound', current_solution)\n        if inbound_tugs is None or len(inbound_tugs) > max_tugboats_per_service:\n            continue\n        # Verify all inbound tugs available and util threshold\n        inbound_feasible = True\n        for k, t in inbound_tugs:\n            if t != inbound_time or not is_tugboat_available(k, inbound_time, inbound_duration, inbound_preparation_time, current_solution):\n                inbound_feasible = False\n                break\n            if tug_utilizations[k] > min_tug_util_threshold:\n                inbound_feasible = False\n                break\n        if not inbound_feasible:\n            continue\n\n        # Find outbound tug combination\n        outbound_tugs, _ = find_tugboat_combination(vessel_id, outbound_start, 'outbound', current_solution)\n        if outbound_tugs is None or len(outbound_tugs) > max_tugboats_per_service:\n            continue\n        # Verify all outbound tugs available and util threshold\n        outbound_feasible = True\n        for k, t in outbound_tugs:\n            if t != outbound_start or not is_tugboat_available(k, outbound_start, outbound_duration, outbound_preparation_time, current_solution):\n                outbound_feasible = False\n                break\n            if tug_utilizations[k] > min_tug_util_threshold:\n                outbound_feasible = False\n                break\n        if not outbound_feasible:\n            continue\n\n        # All checks passed: create operator for berthing start (note: tugs have their start times)\n        operator = CompleteVesselAssignmentOperator(\n            vessel_id=vessel_id,\n            berth_id=selected_berth_id,\n            start_time=berthing_start,  # Berthing start time\n            inbound_tugboats=inbound_tugs,\n            outbound_tugboats=outbound_tugs\n        )\n\n        # Step 7: Validate the temporary solution (ensures full feasibility including sequences, costs, etc.)\n        temp_solution = operator.run(copy.deepcopy(current_solution))  # Deep copy to avoid modifying original\n        if validation_solution(temp_solution):\n            # Valid: return this operator (constructive addition)\n            return operator, {}\n        # Else, continue to next candidate (in case of global violations)\n\n    # No feasible/valid assignment found for this vessel: return empty (try next invocation or vessel)\n    return None, {}\n***\n\nThis implementation follows the UB heuristic precisely: prioritizes by \u03b1_i, selects lowest-util berth (computed dynamically), centers on ETA with flex-based adjustments (default max_adjust=5 steps), uses find_tugboat_combination for efficient (minimal tugs) combos while enforcing low-util threshold on selected tugs (to minimize impact), and validates fully post-assignment. It handles partial solutions by building on current_solution, processes one vessel per call for iterative use in hyper-heuristics, and considers all objective components implicitly via validation (which checks constraints tied to Z1-Z4). If time_periods=0, utils=0 to avoid div/0. Costs aren't explicitly recalculated here (validation ensures validity, and total_scheduling_cost can be updated externally), but feasibility includes timing/ETA/penalty aspects. For empty unassigned or no compatibles, returns None,{}. The tug selection balances by avoiding high-util tugs and minimal count."
            }
        ]
    },
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "To verify whether the code is correct, we conducted a smoke test.\nThis is the test data:\nnum_vessels:100\nnum_berths:15\nnum_tugboats:30\navg_vessel_size:3.58\nvar_vessel_size:1.16\ntotal_required_hp:346107\ntotal_available_hp:80275\neta_span:15\navg_berthing_duration:2.25\nvessel_arrival_density:6.67\navg_time_window_flex:3.7\nberth_capacity_ratio:1.01\n\nWhile executing utilization_balanced_ub_eb0a with the given dataset, the program encountered an error and crashed. The following error message was displayed:\nTraceback (most recent call last):\n  File \"C:\\Users\\gongh\\HeurAgenix-tsp\\HeurAgenix-main\\src\\problems\\base\\env.py\", line 104, in run_heuristic\n    operator, delta = heuristic(\n                      ^^^^^^^^^^\n  File \"<string>\", line 97, in utilization_balanced_ub_eb0a\nTypeError: cannot unpack non-iterable NoneType object\n\n\nPlease try to fix it.\n\nThe response format is very important. For better communication, please respond to me in this format:\n1. If you think this heuristic can not be implemented, respond to me ***python_code:None*** and we will stop this generation.\n2. If you can fix up this issues, please respond to me in this format:\n***python_code:\nfrom src.problems.psp.components import *\nimport other_library (if necessary)\ndef utilization_balanced_ub_eb0a(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[TargetOperatorType, dict]:\n    \"\"\" Description for this heuristic algorithm.\n\n    Args:\n        problem_state (dict): The dictionary contains the problem state.. In this algorithm, the following items are necessary:\n            - necessary_key (value type): description\n            - necessary_key (value type): description\n            ...\n        (Optional and can be omitted if no algorithm data) algorithm_data (dict): The algorithm dictionary for current algorithm only. In this algorithm, the following items are necessary:\n            - necessary_key (value type): description\n            - necessary_key (value type): description\n            ...\n        (Optional and can be omitted if no hyper parameters data) introduction for hyper parameters in kwargs if used.\n\n    Returns:\n        Description of this operator.\n        Description of updated algorithm data.\n\n        ...\n    \"\"\"\nEnsure there is no other content inside the ***, and analysis outside *** is welcome.\nIf you have no information to provide, simply respond with ***None***.\n"
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***python_code:\nfrom src.problems.psp.components import *\nimport numpy as np\nimport copy\n\ndef utilization_balanced_ub_eb0a(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[CompleteVesselAssignmentOperator, dict]:\n    \"\"\"\n    Utilization-Balanced (UB) Heuristic: A constructive heuristic that prioritizes unassigned vessels by decreasing priority weight (\u03b1_i) and attempts to assign the highest-priority vessel to a compatible berth with the lowest current utilization. The inbound service start time is centered on the vessel's ETA and adjusted within the average time window flexibility to find a feasible slot. Tugboat combinations are found using the provided helper to minimize the number of tugs (indirectly balancing utilization by efficiency), with availability checks ensuring no conflicts. The assignment is applied only if the post-assignment solution validates fully. This heuristic builds incrementally on partial solutions by assigning one vessel per invocation, promoting balanced resource use across berths and tugs.\n\n    Hyper-parameters in kwargs (with defaults):\n    - max_time_adjust (int, default=5): Maximum number of time adjustments around ETA (i.e., candidates = ETA \u00b1 max_time_adjust, clipped to time window).\n    - time_step (int, default=1): Step size for generating candidate inbound times around ETA.\n    - min_tug_util_threshold (float, default=0.8): Skip tug combinations if any selected tug's current utilization exceeds this threshold (to minimize impact on heavily used tugs).\n\n    Args:\n        problem_state (dict): The dictionary contains the problem state. In this algorithm, the following items are necessary:\n            - current_solution (Solution): Current partial solution instance to build upon.\n            - vessel_num (int): Total number of vessels.\n            - time_periods (int): Total scheduling horizon in time units.\n            - vessel_priority_weights (numpy.ndarray): Priority weights \u03b1_i for sorting vessels.\n            - vessel_etas (numpy.ndarray): Expected arrival times ETA_i for centering start times.\n            - vessel_sizes (numpy.ndarray): Vessel sizes S_i for compatibility.\n            - vessel_durations (numpy.ndarray): Berthing durations D_i for availability checks.\n            - vessel_inbound_service_times (numpy.ndarray): Inbound service durations \u03c4^in_i.\n            - vessel_outbound_service_times (numpy.ndarray): Outbound service durations \u03c4^out_i.\n            - vessel_horsepower_requirements (numpy.ndarray): Required HP P^req_i for tug selection.\n            - berth_capacities (numpy.ndarray): Berth capacities C_j for compatibility.\n            - tugboat_horsepower (numpy.ndarray): Tugboat HP P_k.\n            - tugboat_costs (numpy.ndarray): Tugboat costs c_k (unused directly but available).\n            - inbound_preparation_time (int): Prep time \u03c1^in after inbound.\n            - outbound_preparation_time (int): Prep time \u03c1^out after outbound.\n            - max_tugboats_per_service (int): H_max limit per service.\n            - avg_time_window_flex (float): Average flexibility for time adjustments.\n            - get_unassigned_vessels (callable): To get list of unassigned vessel IDs.\n            - get_vessel_time_window (callable): To get [earliest, latest] for inbound.\n            - get_compatible_berths (callable): Compatible berths for vessel.\n            - is_berth_available (callable): Berth availability check.\n            - is_tugboat_available (callable): Tugboat availability check.\n            - find_tugboat_combination (callable): To find tug combos for services.\n            - validation_solution (callable): To validate post-assignment feasibility.\n        algorithm_data (dict): Not used in this heuristic (empty dict expected).\n        **kwargs: Hyper-parameters as described above.\n\n    Returns:\n        CompleteVesselAssignmentOperator: Operator to assign the highest-priority unassigned vessel to a balanced berth/time/tug setup if feasible and valid post-assignment; None if no unassigned vessels or no feasible assignment found for the top vessel.\n        dict: Empty dict {} as no algorithm data is updated by this heuristic.\n    \"\"\"\n    # Hyper-parameter defaults\n    max_time_adjust = kwargs.get('max_time_adjust', 5)\n    time_step = kwargs.get('time_step', 1)\n    min_tug_util_threshold = kwargs.get('min_tug_util_threshold', 0.8)\n\n    # Extract necessary data from problem_state (never modify originals)\n    current_solution = problem_state['current_solution']\n    vessel_priority_weights = problem_state['vessel_priority_weights']\n    vessel_etas = problem_state['vessel_etas']\n    vessel_sizes = problem_state['vessel_sizes']\n    vessel_durations = problem_state['vessel_durations']\n    vessel_inbound_service_times = problem_state['vessel_inbound_service_times']\n    vessel_outbound_service_times = problem_state['vessel_outbound_service_times']\n    vessel_horsepower_requirements = problem_state['vessel_horsepower_requirements']\n    berth_capacities = problem_state['berth_capacities']\n    tugboat_horsepower = problem_state['tugboat_horsepower']\n    inbound_preparation_time = problem_state['inbound_preparation_time']\n    outbound_preparation_time = problem_state['outbound_preparation_time']\n    max_tugboats_per_service = problem_state['max_tugboats_per_service']\n    time_periods = problem_state['time_periods']\n    avg_time_window_flex = problem_state['avg_time_window_flex']\n\n    # Helper functions from problem_state (assumed available)\n    get_unassigned_vessels = problem_state['get_unassigned_vessels']\n    get_vessel_time_window = problem_state['get_vessel_time_window']\n    get_compatible_berths = problem_state['get_compatible_berths']\n    is_berth_available = problem_state['is_berth_available']\n    is_tugboat_available = problem_state['is_tugboat_available']\n    find_tugboat_combination = problem_state['find_tugboat_combination']\n    validation_solution = problem_state['validation_solution']\n\n    # Step 1: Get and sort unassigned vessels by decreasing priority weight (\u03b1_i)\n    unassigned_vessels = get_unassigned_vessels(current_solution)\n    if not unassigned_vessels:\n        # No unassigned vessels: nothing to do, return empty\n        return None, {}\n\n    # Sort by decreasing priority; take the highest priority one (process one vessel per invocation for incremental construction)\n    sorted_unassigned = sorted(unassigned_vessels, key=lambda i: -vessel_priority_weights[i])\n    vessel_id = sorted_unassigned[0]  # Focus on top priority vessel\n\n    # Step 2: Get compatible berths\n    compatible_berths = get_compatible_berths(vessel_id)\n    if not compatible_berths:\n        # No compatible berths: cannot assign, return empty\n        return None, {}\n\n    # Step 3: Compute current per-berth utilization (occupied time / time_periods)\n    # Utilization: for each berth, sum D_i of assigned vessels to it (no overlaps due to constraints)\n    berth_occupied = np.zeros(len(berth_capacities))\n    for assigned_vessel, (b_id, start_t) in current_solution.vessel_assignments.items():\n        if assigned_vessel != vessel_id and start_t is not None:  # Exclude self if partially assigned (but unassigned, so safe)\n            berth_occupied[b_id] += vessel_durations[assigned_vessel]\n    berth_utilizations = berth_occupied / time_periods if time_periods > 0 else np.zeros(len(berth_occupied))\n\n    # Select compatible berth with lowest utilization (tie-break by smallest ID)\n    valid_berths = [(b, berth_utilizations[b]) for b in compatible_berths]\n    if not valid_berths:\n        return None, {}\n    selected_berth_id = min(valid_berths, key=lambda x: (x[1], x[0]))[0]  # min util, then min ID\n\n    # Step 4: Compute per-tug utilization for tug selection (to check threshold later)\n    # For each tug, sum (service_duration + prep) over all its assignments (inbound + outbound)\n    tug_occupied = np.zeros(len(tugboat_horsepower))\n    for v, inbound_list in current_solution.tugboat_inbound_assignments.items():\n        for (k, t) in inbound_list:\n            if t is not None:\n                tug_occupied[k] += vessel_inbound_service_times[v] + inbound_preparation_time\n    for v, outbound_list in current_solution.tugboat_outbound_assignments.items():\n        for (k, t) in outbound_list:\n            if t is not None:\n                tug_occupied[k] += vessel_outbound_service_times[v] + outbound_preparation_time\n    tug_utilizations = tug_occupied / time_periods if time_periods > 0 else np.zeros(len(tug_occupied))\n\n    # Step 5: Generate candidate inbound times centered on ETA, adjusted up to flex\n    eta = vessel_etas[vessel_id]\n    time_window = get_vessel_time_window(vessel_id)\n    earliest_inbound, latest_inbound = time_window\n    max_adjust = min(max_time_adjust, int(avg_time_window_flex))  # Cap by avg flex\n\n    # Candidates: around ETA, step by time_step, within window\n    candidate_inbounds = []\n    for delta in range(-max_adjust, max_adjust + 1, time_step):\n        cand_time = max(earliest_inbound, min(latest_inbound, eta + delta))\n        if cand_time not in candidate_inbounds:  # Avoid duplicates\n            candidate_inbounds.append(cand_time)\n    # Sort candidates by proximity to ETA (minimize deviation)\n    candidate_inbounds.sort(key=lambda t: abs(t - eta))\n\n    # Step 6: For each candidate inbound time, try to find feasible tight schedule\n    best_operator = None\n    for inbound_time in candidate_inbounds:\n        # Compute derived times (tight sequencing: no extra tolerance beyond epsilon, but check availability)\n        inbound_duration = vessel_inbound_service_times[vessel_id]\n        berthing_start = inbound_time + inbound_duration  # Start berthing right after inbound\n        berthing_duration = vessel_durations[vessel_id]\n        if berthing_start + berthing_duration > time_periods:\n            continue  # Exceeds horizon\n\n        outbound_start = berthing_start + berthing_duration  # Start outbound right after berthing\n        outbound_duration = vessel_outbound_service_times[vessel_id]\n\n        # Check berth availability for [berthing_start, berthing_start + berthing_duration)\n        if not is_berth_available(selected_berth_id, berthing_start, berthing_duration, current_solution):\n            continue\n\n        # Find inbound tug combination (greedy minimizes number, balancing load indirectly)\n        inbound_result = find_tugboat_combination(vessel_id, inbound_time, 'inbound', current_solution)\n        inbound_tugs = inbound_result[0] if inbound_result else None\n        if inbound_tugs is None or len(inbound_tugs) > max_tugboats_per_service:\n            continue\n        # Verify all inbound tugs available and util threshold\n        inbound_feasible = True\n        for k, t in inbound_tugs:\n            if t != inbound_time or not is_tugboat_available(k, inbound_time, inbound_duration, inbound_preparation_time, current_solution):\n                inbound_feasible = False\n                break\n            if tug_utilizations[k] > min_tug_util_threshold:\n                inbound_feasible = False\n                break\n        if not inbound_feasible:\n            continue\n\n        # Find outbound tug combination\n        outbound_result = find_tugboat_combination(vessel_id, outbound_start, 'outbound', current_solution)\n        outbound_tugs = outbound_result[0] if outbound_result else None\n        if outbound_tugs is None or len(outbound_tugs) > max_tugboats_per_service:\n            continue\n        # Verify all outbound tugs available and util threshold\n        outbound_feasible = True\n        for k, t in outbound_tugs:\n            if t != outbound_start or not is_tugboat_available(k, outbound_start, outbound_duration, outbound_preparation_time, current_solution):\n                outbound_feasible = False\n                break\n            if tug_utilizations[k] > min_tug_util_threshold:\n                outbound_feasible = False\n                break\n        if not outbound_feasible:\n            continue\n\n        # All checks passed: create operator for berthing start (note: tugs have their start times)\n        operator = CompleteVesselAssignmentOperator(\n            vessel_id=vessel_id,\n            berth_id=selected_berth_id,\n            start_time=berthing_start,  # Berthing start time\n            inbound_tugboats=inbound_tugs,\n            outbound_tugboats=outbound_tugs\n        )\n\n        # Step 7: Validate the temporary solution (ensures full feasibility including sequences, costs, etc.)\n        temp_solution = operator.run(copy.deepcopy(current_solution))  # Deep copy to avoid modifying original\n        if validation_solution(temp_solution):\n            # Valid: return this operator (constructive addition)\n            return operator, {}\n        # Else, continue to next candidate (in case of global violations)\n\n    # No feasible/valid assignment found for this vessel: return empty (try next invocation or vessel)\n    return None, {}\n***\n\nThe error was caused by attempting to call `len(inbound_tugs)` when `inbound_tugs` was `None` (returned by `find_tugboat_combination` if no valid combination found), as the `or` operator does not short-circuit in a way that prevents the evaluation of the second condition when the first is falsy. To fix this, I changed the unpacking to assign the full result tuple first (e.g., `inbound_result = find_tugboat_combination(...)`) and then extract `inbound_tugs = inbound_result[0] if inbound_result else None`, ensuring safe handling. The condition `if inbound_tugs is None or len(inbound_tugs) > max_tugboats_per_service:` now explicitly checks `is None` first, which short-circuits the `or` properly since `is None` (True) skips the `len()` call. The same fix applies to the outbound combination. This prevents the TypeError while maintaining the logic. The rest of the code remains unchanged, as it handles partial solutions, validates fully (covering all Z1-Z4 via constraints), and returns valid results or None appropriately. With the test data's tight constraints (e.g., high HP demand vs. availability), it may often return None, but won't crash."
            }
        ]
    },
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "To verify whether the code is correct, we conducted a smoke test.\nThis is the test data:\nnum_vessels:100\nnum_berths:15\nnum_tugboats:30\navg_vessel_size:3.58\nvar_vessel_size:1.16\ntotal_required_hp:346107\ntotal_available_hp:80275\neta_span:15\navg_berthing_duration:2.25\nvessel_arrival_density:6.67\navg_time_window_flex:3.7\nberth_capacity_ratio:1.01\n\nWhile executing utilization_balanced_ub_eb0a with the given dataset, the program encountered an error and crashed. The following error message was displayed:\nTraceback (most recent call last):\n  File \"C:\\Users\\gongh\\HeurAgenix-tsp\\HeurAgenix-main\\src\\problems\\base\\env.py\", line 104, in run_heuristic\n    operator, delta = heuristic(\n                      ^^^^^^^^^^\n  File \"<string>\", line 97, in utilization_balanced_ub_eb0a\nTypeError: cannot unpack non-iterable NoneType object\n\n\nPlease try to fix it.\n\nThe response format is very important. For better communication, please respond to me in this format:\n1. If you think this heuristic can not be implemented, respond to me ***python_code:None*** and we will stop this generation.\n2. If you can fix up this issues, please respond to me in this format:\n***python_code:\nfrom src.problems.psp.components import *\nimport other_library (if necessary)\ndef utilization_balanced_ub_eb0a(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[TargetOperatorType, dict]:\n    \"\"\" Description for this heuristic algorithm.\n\n    Args:\n        problem_state (dict): The dictionary contains the problem state.. In this algorithm, the following items are necessary:\n            - necessary_key (value type): description\n            - necessary_key (value type): description\n            ...\n        (Optional and can be omitted if no algorithm data) algorithm_data (dict): The algorithm dictionary for current algorithm only. In this algorithm, the following items are necessary:\n            - necessary_key (value type): description\n            - necessary_key (value type): description\n            ...\n        (Optional and can be omitted if no hyper parameters data) introduction for hyper parameters in kwargs if used.\n\n    Returns:\n        Description of this operator.\n        Description of updated algorithm data.\n\n        ...\n    \"\"\"\nEnsure there is no other content inside the ***, and analysis outside *** is welcome.\nIf you have no information to provide, simply respond with ***None***.\n"
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***python_code:\nfrom src.problems.psp.components import *\nimport numpy as np\nimport copy\n\ndef utilization_balanced_ub_eb0a(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[CompleteVesselAssignmentOperator, dict]:\n    \"\"\"\n    Utilization-Balanced (UB) Heuristic: A constructive heuristic that prioritizes unassigned vessels by decreasing priority weight (\u03b1_i) and attempts to assign the highest-priority vessel to a compatible berth with the lowest current utilization. The inbound service start time is centered on the vessel's ETA and adjusted within the average time window flexibility to find a feasible slot. Tugboat combinations are found using the provided helper to minimize the number of tugs (indirectly balancing utilization by efficiency), with availability checks ensuring no conflicts. The assignment is applied only if the post-assignment solution validates fully. This heuristic builds incrementally on partial solutions by assigning one vessel per invocation, promoting balanced resource use across berths and tugs.\n\n    Hyper-parameters in kwargs (with defaults):\n    - max_time_adjust (int, default=5): Maximum number of time adjustments around ETA (i.e., candidates = ETA \u00b1 max_time_adjust, clipped to time window).\n    - time_step (int, default=1): Step size for generating candidate inbound times around ETA.\n    - min_tug_util_threshold (float, default=0.8): Skip tug combinations if any selected tug's current utilization exceeds this threshold (to minimize impact on heavily used tugs).\n\n    Args:\n        problem_state (dict): The dictionary contains the problem state. In this algorithm, the following items are necessary:\n            - current_solution (Solution): Current partial solution instance to build upon.\n            - vessel_num (int): Total number of vessels.\n            - time_periods (int): Total scheduling horizon in time units.\n            - vessel_priority_weights (numpy.ndarray): Priority weights \u03b1_i for sorting vessels.\n            - vessel_etas (numpy.ndarray): Expected arrival times ETA_i for centering start times.\n            - vessel_sizes (numpy.ndarray): Vessel sizes S_i for compatibility.\n            - vessel_durations (numpy.ndarray): Berthing durations D_i for availability checks.\n            - vessel_inbound_service_times (numpy.ndarray): Inbound service durations \u03c4^in_i.\n            - vessel_outbound_service_times (numpy.ndarray): Outbound service durations \u03c4^out_i.\n            - vessel_horsepower_requirements (numpy.ndarray): Required HP P^req_i for tug selection.\n            - berth_capacities (numpy.ndarray): Berth capacities C_j for compatibility.\n            - tugboat_horsepower (numpy.ndarray): Tugboat HP P_k.\n            - tugboat_costs (numpy.ndarray): Tugboat costs c_k (unused directly but available).\n            - inbound_preparation_time (int): Prep time \u03c1^in after inbound.\n            - outbound_preparation_time (int): Prep time \u03c1^out after outbound.\n            - max_tugboats_per_service (int): H_max limit per service.\n            - avg_time_window_flex (float): Average flexibility for time adjustments.\n            - get_unassigned_vessels (callable): To get list of unassigned vessel IDs.\n            - get_vessel_time_window (callable): To get [earliest, latest] for inbound.\n            - get_compatible_berths (callable): Compatible berths for vessel.\n            - is_berth_available (callable): Berth availability check.\n            - is_tugboat_available (callable): Tugboat availability check.\n            - find_tugboat_combination (callable): To find tug combos for services.\n            - validation_solution (callable): To validate post-assignment feasibility.\n        algorithm_data (dict): Not used in this heuristic (empty dict expected).\n        **kwargs: Hyper-parameters as described above.\n\n    Returns:\n        CompleteVesselAssignmentOperator: Operator to assign the highest-priority unassigned vessel to a balanced berth/time/tug setup if feasible and valid post-assignment; None if no unassigned vessels or no feasible assignment found for the top vessel.\n        dict: Empty dict {} as no algorithm data is updated by this heuristic.\n    \"\"\"\n    # Hyper-parameter defaults\n    max_time_adjust = kwargs.get('max_time_adjust', 5)\n    time_step = kwargs.get('time_step', 1)\n    min_tug_util_threshold = kwargs.get('min_tug_util_threshold', 0.8)\n\n    # Extract necessary data from problem_state (never modify originals)\n    current_solution = problem_state['current_solution']\n    vessel_priority_weights = problem_state['vessel_priority_weights']\n    vessel_etas = problem_state['vessel_etas']\n    vessel_sizes = problem_state['vessel_sizes']\n    vessel_durations = problem_state['vessel_durations']\n    vessel_inbound_service_times = problem_state['vessel_inbound_service_times']\n    vessel_outbound_service_times = problem_state['vessel_outbound_service_times']\n    vessel_horsepower_requirements = problem_state['vessel_horsepower_requirements']\n    berth_capacities = problem_state['berth_capacities']\n    tugboat_horsepower = problem_state['tugboat_horsepower']\n    inbound_preparation_time = problem_state['inbound_preparation_time']\n    outbound_preparation_time = problem_state['outbound_preparation_time']\n    max_tugboats_per_service = problem_state['max_tugboats_per_service']\n    time_periods = problem_state['time_periods']\n    avg_time_window_flex = problem_state['avg_time_window_flex']\n\n    # Helper functions from problem_state (assumed available)\n    get_unassigned_vessels = problem_state['get_unassigned_vessels']\n    get_vessel_time_window = problem_state['get_vessel_time_window']\n    get_compatible_berths = problem_state['get_compatible_berths']\n    is_berth_available = problem_state['is_berth_available']\n    is_tugboat_available = problem_state['is_tugboat_available']\n    find_tugboat_combination = problem_state['find_tugboat_combination']\n    validation_solution = problem_state['validation_solution']\n\n    # Step 1: Get and sort unassigned vessels by decreasing priority weight (\u03b1_i)\n    unassigned_vessels = get_unassigned_vessels(current_solution)\n    if not unassigned_vessels:\n        # No unassigned vessels: nothing to do, return empty\n        return None, {}\n\n    # Sort by decreasing priority; take the highest priority one (process one vessel per invocation for incremental construction)\n    sorted_unassigned = sorted(unassigned_vessels, key=lambda i: -vessel_priority_weights[i])\n    vessel_id = sorted_unassigned[0]  # Focus on top priority vessel\n\n    # Step 2: Get compatible berths\n    compatible_berths = get_compatible_berths(vessel_id)\n    if not compatible_berths:\n        # No compatible berths: cannot assign, return empty\n        return None, {}\n\n    # Step 3: Compute current per-berth utilization (occupied time / time_periods)\n    # Utilization: for each berth, sum D_i of assigned vessels to it (no overlaps due to constraints)\n    berth_occupied = np.zeros(len(berth_capacities))\n    for assigned_vessel, (b_id, start_t) in current_solution.vessel_assignments.items():\n        if assigned_vessel != vessel_id and start_t is not None:  # Exclude self if partially assigned (but unassigned, so safe)\n            berth_occupied[b_id] += vessel_durations[assigned_vessel]\n    berth_utilizations = berth_occupied / time_periods if time_periods > 0 else np.zeros(len(berth_occupied))\n\n    # Select compatible berth with lowest utilization (tie-break by smallest ID)\n    valid_berths = [(b, berth_utilizations[b]) for b in compatible_berths]\n    if not valid_berths:\n        return None, {}\n    selected_berth_id = min(valid_berths, key=lambda x: (x[1], x[0]))[0]  # min util, then min ID\n\n    # Step 4: Compute per-tug utilization for tug selection (to check threshold later)\n    # For each tug, sum (service_duration + prep) over all its assignments (inbound + outbound)\n    tug_occupied = np.zeros(len(tugboat_horsepower))\n    for v, inbound_list in current_solution.tugboat_inbound_assignments.items():\n        for (k, t) in inbound_list:\n            if t is not None:\n                tug_occupied[k] += vessel_inbound_service_times[v] + inbound_preparation_time\n    for v, outbound_list in current_solution.tugboat_outbound_assignments.items():\n        for (k, t) in outbound_list:\n            if t is not None:\n                tug_occupied[k] += vessel_outbound_service_times[v] + outbound_preparation_time\n    tug_utilizations = tug_occupied / time_periods if time_periods > 0 else np.zeros(len(tug_occupied))\n\n    # Step 5: Generate candidate inbound times centered on ETA, adjusted up to flex\n    eta = vessel_etas[vessel_id]\n    time_window = get_vessel_time_window(vessel_id)\n    # Robust check for invalid time window (prevent unpacking error if None or invalid)\n    if time_window is None or not isinstance(time_window, (list, tuple)) or len(time_window) != 2:\n        return None, {}\n    earliest_inbound, latest_inbound = time_window\n    if earliest_inbound > latest_inbound:\n        return None, {}\n    max_adjust = min(max_time_adjust, int(avg_time_window_flex))  # Cap by avg flex\n\n    # Candidates: around ETA, step by time_step, within window\n    candidate_inbounds = []\n    for delta in range(-max_adjust, max_adjust + 1, time_step):\n        cand_time = max(earliest_inbound, min(latest_inbound, eta + delta))\n        if cand_time not in candidate_inbounds:  # Avoid duplicates\n            candidate_inbounds.append(cand_time)\n    # Sort candidates by proximity to ETA (minimize deviation)\n    candidate_inbounds.sort(key=lambda t: abs(t - eta))\n    if not candidate_inbounds:\n        return None, {}\n\n    # Step 6: For each candidate inbound time, try to find feasible tight schedule\n    best_operator = None\n    for inbound_time in candidate_inbounds:\n        # Compute derived times (tight sequencing: no extra tolerance beyond epsilon, but check availability)\n        inbound_duration = vessel_inbound_service_times[vessel_id]\n        berthing_start = inbound_time + inbound_duration  # Start berthing right after inbound\n        berthing_duration = vessel_durations[vessel_id]\n        if berthing_start + berthing_duration > time_periods:\n            continue  # Exceeds horizon\n\n        outbound_start = berthing_start + berthing_duration  # Start outbound right after berthing\n        outbound_duration = vessel_outbound_service_times[vessel_id]\n\n        # Check berth availability for [berthing_start, berthing_start + berthing_duration)\n        if not is_berth_available(selected_berth_id, berthing_start, berthing_duration, current_solution):\n            continue\n\n        # Find inbound tug combination (greedy minimizes number, balancing load indirectly)\n        inbound_result = find_tugboat_combination(vessel_id, inbound_time, 'inbound', current_solution)\n        # Robust handling: ensure result is tuple\n        if not isinstance(inbound_result, (list, tuple)) or len(inbound_result) != 2:\n            continue\n        inbound_tugs, _ = inbound_result\n        if inbound_tugs is None or len(inbound_tugs) > max_tugboats_per_service:\n            continue\n        # Verify all inbound tugs available and util threshold\n        inbound_feasible = True\n        for k, t in inbound_tugs:\n            if t != inbound_time or not is_tugboat_available(k, inbound_time, inbound_duration, inbound_preparation_time, current_solution):\n                inbound_feasible = False\n                break\n            if tug_utilizations[k] > min_tug_util_threshold:\n                inbound_feasible = False\n                break\n        if not inbound_feasible:\n            continue\n\n        # Find outbound tug combination\n        outbound_result = find_tugboat_combination(vessel_id, outbound_start, 'outbound', current_solution)\n        # Robust handling: ensure result is tuple\n        if not isinstance(outbound_result, (list, tuple)) or len(outbound_result) != 2:\n            continue\n        outbound_tugs, _ = outbound_result\n        if outbound_tugs is None or len(outbound_tugs) > max_tugboats_per_service:\n            continue\n        # Verify all outbound tugs available and util threshold\n        outbound_feasible = True\n        for k, t in outbound_tugs:\n            if t != outbound_start or not is_tugboat_available(k, outbound_start, outbound_duration, outbound_preparation_time, current_solution):\n                outbound_feasible = False\n                break\n            if tug_utilizations[k] > min_tug_util_threshold:\n                outbound_feasible = False\n                break\n        if not outbound_feasible:\n            continue\n\n        # All checks passed: create operator for berthing start (note: tugs have their start times)\n        operator = CompleteVesselAssignmentOperator(\n            vessel_id=vessel_id,\n            berth_id=selected_berth_id,\n            start_time=berthing_start,  # Berthing start time\n            inbound_tugboats=inbound_tugs,\n            outbound_tugboats=outbound_tugs\n        )\n\n        # Step 7: Validate the temporary solution (ensures full feasibility including sequences, costs, etc.)\n        temp_solution = operator.run(copy.deepcopy(current_solution))  # Deep copy to avoid modifying original\n        if validation_solution(temp_solution):\n            # Valid: return this operator (constructive addition)\n            return operator, {}\n        # Else, continue to next candidate (in case of global violations)\n\n    # No feasible/valid assignment found for this vessel: return empty (try next invocation or vessel)\n    return None, {}\n***\n\nThe persistent error suggests that `get_vessel_time_window(vessel_id)` is returning `None` instead of a tuple in the test environment, causing the unpacking `earliest_inbound, latest_inbound = time_window` to fail with \"cannot unpack non-iterable NoneType object\". This could occur if the vessel's early/late limits make the window invalid (e.g., negative flexibility or data anomalies in the high-density test case). To fix, I've added a robust check immediately after fetching `time_window`: if it's `None` or not a valid 2-element iterable, or if `earliest > latest`, return `None, {}` early to skip invalid cases gracefully. Additionally, to cover potential issues with `find_tugboat_combination` (in case it unexpectedly returns `None` instead of `(None, 0)`), I've added checks to ensure the result is a 2-element tuple before unpacking, continuing to the next candidate if not. I've also checked for empty `candidate_inbounds` and return `None, {}` if no valid times generated. These safeguards prevent unpacking errors while preserving the heuristic's logic, ensuring the function always returns a tuple and handles edge cases from \"all data possible\" without crashing. The test data's mismatch in HP (demand >> supply) may lead"
            }
        ]
    },
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "To verify whether the code is correct, we conducted a smoke test.\nThis is the test data:\nnum_vessels:100\nnum_berths:15\nnum_tugboats:30\navg_vessel_size:3.58\nvar_vessel_size:1.16\ntotal_required_hp:346107\ntotal_available_hp:80275\neta_span:15\navg_berthing_duration:2.25\nvessel_arrival_density:6.67\navg_time_window_flex:3.7\nberth_capacity_ratio:1.01\n\nWhile executing utilization_balanced_ub_eb0a with the given dataset, the program encountered an error and crashed. The following error message was displayed:\nTraceback (most recent call last):\n  File \"C:\\Users\\gongh\\HeurAgenix-tsp\\HeurAgenix-main\\src\\problems\\base\\env.py\", line 104, in run_heuristic\n    operator, delta = heuristic(\n                      ^^^^^^^^^^\n  File \"<string>\", line 97, in utilization_balanced_ub_eb0a\nTypeError: cannot unpack non-iterable NoneType object\n\n\nPlease try to fix it.\n\nThe response format is very important. For better communication, please respond to me in this format:\n1. If you think this heuristic can not be implemented, respond to me ***python_code:None*** and we will stop this generation.\n2. If you can fix up this issues, please respond to me in this format:\n***python_code:\nfrom src.problems.psp.components import *\nimport other_library (if necessary)\ndef utilization_balanced_ub_eb0a(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[TargetOperatorType, dict]:\n    \"\"\" Description for this heuristic algorithm.\n\n    Args:\n        problem_state (dict): The dictionary contains the problem state.. In this algorithm, the following items are necessary:\n            - necessary_key (value type): description\n            - necessary_key (value type): description\n            ...\n        (Optional and can be omitted if no algorithm data) algorithm_data (dict): The algorithm dictionary for current algorithm only. In this algorithm, the following items are necessary:\n            - necessary_key (value type): description\n            - necessary_key (value type): description\n            ...\n        (Optional and can be omitted if no hyper parameters data) introduction for hyper parameters in kwargs if used.\n\n    Returns:\n        Description of this operator.\n        Description of updated algorithm data.\n\n        ...\n    \"\"\"\nEnsure there is no other content inside the ***, and analysis outside *** is welcome.\nIf you have no information to provide, simply respond with ***None***.\n"
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***python_code:\nfrom src.problems.psp.components import *\nimport numpy as np\nimport copy\n\ndef utilization_balanced_ub_eb0a(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[CompleteVesselAssignmentOperator, dict]:\n    \"\"\"\n    Utilization-Balanced (UB) Heuristic: A constructive heuristic that prioritizes unassigned vessels by decreasing priority weight (\u03b1_i) and attempts to assign the highest-priority vessel to a compatible berth with the lowest current utilization. The inbound service start time is centered on the vessel's ETA and adjusted within the average time window flexibility to find a feasible slot. Tugboat combinations are found using the provided helper to minimize the number of tugs (indirectly balancing utilization by efficiency), with availability checks ensuring no conflicts. The assignment is applied only if the post-assignment solution validates fully. This heuristic builds incrementally on partial solutions by assigning one vessel per invocation, promoting balanced resource use across berths and tugs.\n\n    Hyper-parameters in kwargs (with defaults):\n    - max_time_adjust (int, default=5): Maximum number of time adjustments around ETA (i.e., candidates = ETA \u00b1 max_time_adjust, clipped to time window).\n    - time_step (int, default=1): Step size for generating candidate inbound times around ETA.\n    - min_tug_util_threshold (float, default=0.8): Skip tug combinations if any selected tug's current utilization exceeds this threshold (to minimize impact on heavily used tugs).\n\n    Args:\n        problem_state (dict): The dictionary contains the problem state. In this algorithm, the following items are necessary:\n            - current_solution (Solution): Current partial solution instance to build upon.\n            - vessel_num (int): Total number of vessels.\n            - time_periods (int): Total scheduling horizon in time units.\n            - vessel_priority_weights (numpy.ndarray): Priority weights \u03b1_i for sorting vessels.\n            - vessel_etas (numpy.ndarray): Expected arrival times ETA_i for centering start times.\n            - vessel_sizes (numpy.ndarray): Vessel sizes S_i for compatibility.\n            - vessel_durations (numpy.ndarray): Berthing durations D_i for availability checks.\n            - vessel_inbound_service_times (numpy.ndarray): Inbound service durations \u03c4^in_i.\n            - vessel_outbound_service_times (numpy.ndarray): Outbound service durations \u03c4^out_i.\n            - vessel_horsepower_requirements (numpy.ndarray): Required HP P^req_i for tug selection.\n            - berth_capacities (numpy.ndarray): Berth capacities C_j for compatibility.\n            - tugboat_horsepower (numpy.ndarray): Tugboat HP P_k.\n            - tugboat_costs (numpy.ndarray): Tugboat costs c_k (unused directly but available).\n            - inbound_preparation_time (int): Prep time \u03c1^in after inbound.\n            - outbound_preparation_time (int): Prep time \u03c1^out after outbound.\n            - max_tugboats_per_service (int): H_max limit per service.\n            - avg_time_window_flex (float): Average flexibility for time adjustments.\n            - get_unassigned_vessels (callable): To get list of unassigned vessel IDs.\n            - get_vessel_time_window (callable): To get [earliest, latest] for inbound.\n            - get_compatible_berths (callable): Compatible berths for vessel.\n            - is_berth_available (callable): Berth availability check.\n            - is_tugboat_available (callable): Tugboat availability check.\n            - find_tugboat_combination (callable): To find tug combos for services.\n            - validation_solution (callable): To validate post-assignment feasibility.\n        algorithm_data (dict): Not used in this heuristic (empty dict expected).\n        **kwargs: Hyper-parameters as described above.\n\n    Returns:\n        CompleteVesselAssignmentOperator: Operator to assign the highest-priority unassigned vessel to a balanced berth/time/tug setup if feasible and valid post-assignment; None if no unassigned vessels or no feasible assignment found for the top vessel.\n        dict: Empty dict {} as no algorithm data is updated by this heuristic.\n    \"\"\"\n    # Hyper-parameter defaults\n    max_time_adjust = kwargs.get('max_time_adjust', 5)\n    time_step = kwargs.get('time_step', 1)\n    min_tug_util_threshold = kwargs.get('min_tug_util_threshold', 0.8)\n\n    # Extract necessary data from problem_state (never modify originals)\n    current_solution = problem_state['current_solution']\n    vessel_priority_weights = problem_state['vessel_priority_weights']\n    vessel_etas = problem_state['vessel_etas']\n    vessel_sizes = problem_state['vessel_sizes']\n    vessel_durations = problem_state['vessel_durations']\n    vessel_inbound_service_times = problem_state['vessel_inbound_service_times']\n    vessel_outbound_service_times = problem_state['vessel_outbound_service_times']\n    vessel_horsepower_requirements = problem_state['vessel_horsepower_requirements']\n    berth_capacities = problem_state['berth_capacities']\n    tugboat_horsepower = problem_state['tugboat_horsepower']\n    inbound_preparation_time = problem_state['inbound_preparation_time']\n    outbound_preparation_time = problem_state['outbound_preparation_time']\n    max_tugboats_per_service = problem_state['max_tugboats_per_service']\n    time_periods = problem_state['time_periods']\n    avg_time_window_flex = problem_state['avg_time_window_flex']\n\n    # Helper functions from problem_state (assumed available)\n    get_unassigned_vessels = problem_state['get_unassigned_vessels']\n    get_vessel_time_window = problem_state['get_vessel_time_window']\n    get_compatible_berths = problem_state['get_compatible_berths']\n    is_berth_available = problem_state['is_berth_available']\n    is_tugboat_available = problem_state['is_tugboat_available']\n    find_tugboat_combination = problem_state['find_tugboat_combination']\n    validation_solution = problem_state['validation_solution']\n\n    # Step 1: Get and sort unassigned vessels by decreasing priority weight (\u03b1_i)\n    unassigned_vessels_result = get_unassigned_vessels(current_solution)\n    if unassigned_vessels_result is None or not isinstance(unassigned_vessels_result, (list, tuple)):\n        return None, {}\n    unassigned_vessels = list(unassigned_vessels_result)\n    if not unassigned_vessels:\n        # No unassigned vessels: nothing to do, return empty\n        return None, {}\n\n    # Sort by decreasing priority; take the highest priority one (process one vessel per invocation for incremental construction)\n    if vessel_priority_weights is None or len(vessel_priority_weights) < max(unassigned_vessels) + 1:\n        return None, {}\n    sorted_unassigned = sorted(unassigned_vessels, key=lambda i: -vessel_priority_weights[i])\n    vessel_id = sorted_unassigned[0]  # Focus on top priority vessel\n\n    # Step 2: Get compatible berths\n    compatible_berths_result = get_compatible_berths(vessel_id)\n    if compatible_berths_result is None or not isinstance(compatible_berths_result, (list, tuple)):\n        return None, {}\n    compatible_berths = list(compatible_berths_result)\n    if not compatible_berths:\n        # No compatible berths: cannot assign, return empty\n        return None, {}\n\n    # Step 3: Compute current per-berth utilization (occupied time / time_periods)\n    # Utilization: for each berth, sum D_i of assigned vessels to it (no overlaps due to constraints)\n    if berth_capacities is None or not isinstance(berth_capacities, np.ndarray) or len(berth_capacities) == 0:\n        return None, {}\n    berth_occupied = np.zeros(len(berth_capacities))\n    if not hasattr(current_solution, 'vessel_assignments') or current_solution.vessel_assignments is None:\n        pass\n    else:\n        for assigned_vessel, assignment in current_solution.vessel_assignments.items():\n            if assignment is not None and assigned_vessel != vessel_id:\n                try:\n                    b_id, start_t = assignment\n                    if 0 <= b_id < len(berth_occupied) and start_t is not None:\n                        if 0 <= assigned_vessel < len(vessel_durations):\n                            berth_occupied[b_id] += vessel_durations[assigned_vessel]\n                except (ValueError, TypeError):\n                    continue  # Skip invalid assignments\n    berth_utilizations = berth_occupied / time_periods if time_periods > 0 else np.zeros(len(berth_occupied))\n\n    # Select compatible berth with lowest utilization (tie-break by smallest ID)\n    valid_berths = [(b, berth_utilizations[b]) for b in compatible_berths if 0 <= b < len(berth_utilizations)]\n    if not valid_berths:\n        return None, {}\n    selected_berth_id = min(valid_berths, key=lambda x: (x[1], x[0]))[0]  # min util, then min ID\n\n    # Step 4: Compute per-tug utilization for tug selection (to check threshold later)\n    # For each tug, sum (service_duration + prep) over all its assignments (inbound + outbound)\n    if tugboat_horsepower is None or not isinstance(tugboat_horsepower, np.ndarray) or len(tugboat_horsepower) == 0:\n        return None, {}\n    tug_occupied = np.zeros(len(tugboat_horsepower))\n    if not hasattr(current_solution, 'tugboat_inbound_assignments') or current_solution.tugboat_inbound_assignments is None:\n        pass\n    else:\n        for v, inbound_list in current_solution.tugboat_inbound_assignments.items():\n            if inbound_list is None or not isinstance(inbound_list, (list, tuple)):\n                continue\n            for tug_assignment in inbound_list:\n                if tug_assignment is not None:\n                    try:\n                        k, t = tug_assignment\n                        if 0 <= k < len(tug_occupied) and t is not None and 0 <= v < len(vessel_inbound_service_times):\n                            tug_occupied[k] += vessel_inbound_service_times[v] + inbound_preparation_time\n                    except (ValueError, TypeError):\n                        continue\n    if not hasattr(current_solution, 'tugboat_outbound_assignments') or current_solution.tugboat_outbound_assignments is None:\n        pass\n    else:\n        for v, outbound_list in current_solution.tugboat_outbound_assignments.items():\n            if outbound_list is None or not isinstance(outbound_list, (list, tuple)):\n                continue\n            for tug_assignment in outbound_list:\n                if tug_assignment is not None:\n                    try:\n                        k, t = tug_assignment\n                        if 0 <= k < len(tug_occupied) and t is not None and 0 <= v < len(vessel_outbound_service_times):\n                            tug_occupied[k] += vessel_outbound_service_times[v] + outbound_preparation_time\n                    except (ValueError, TypeError):\n                        continue\n    tug_utilizations = tug_occupied / time_periods if time_periods > 0 else np.zeros(len(tug_occupied))\n\n    # Step 5: Generate candidate inbound times centered on ETA, adjusted up to flex\n    if vessel_etas is None or len(vessel_etas) <= vessel_id:\n        return None, {}\n    eta = vessel_etas[vessel_id]\n    time_window = get_vessel_time_window(vessel_id)\n    # Robust check for invalid time window (prevent unpacking error if None or invalid)\n    if time_window is None or not isinstance(time_window, (list, tuple)) or len(time_window) != 2:\n        return None, {}\n    earliest_inbound, latest_inbound = time_window\n    if not (isinstance(earliest_inbound, (int, float)) and isinstance(latest_inbound, (int, float))) or earliest_inbound > latest_inbound:\n        return None, {}\n    max_adjust = min(max_time_adjust, int(avg_time_window_flex))  # Cap by avg flex\n\n    # Candidates: around ETA, step by time_step, within window\n    candidate_inbounds = []\n    for delta in range(-max_adjust, max_adjust + 1, time_step):\n        cand_time = max(earliest_inbound, min(latest_inbound, eta + delta))\n        if cand_time not in candidate_inbounds:  # Avoid duplicates\n            candidate_inbounds.append(cand_time)\n    # Sort candidates by proximity to ETA (minimize deviation)\n    candidate_inbounds.sort(key=lambda t: abs(t - eta))\n    if not candidate_inbounds:\n        return None, {}\n\n    # Step 6: For each candidate inbound time, try to find feasible tight schedule\n    best_operator = None\n    for inbound_time in candidate_inbounds:\n        # Compute derived times (tight sequencing: no extra tolerance beyond epsilon, but check availability)\n        if vessel_inbound_service_times is None or len(vessel_inbound_service_times) <= vessel_id:\n            continue\n        inbound_duration = vessel_inbound_service_times[vessel_id]\n        berthing_start = inbound_time + inbound_duration  # Start berthing right after inbound\n        if vessel_durations is None or len(vessel_durations) <= vessel_id:\n            continue\n        berthing_duration = vessel_durations[vessel_id]\n        if berthing_start + berthing_duration > time_periods:\n            continue  # Exceeds horizon\n\n        outbound_start = berthing_start + berthing_duration  # Start outbound right after berthing\n        if vessel_outbound_service_times is None or len(vessel_outbound_service_times) <= vessel_id:\n            continue\n        outbound_duration = vessel_outbound_service_times[vessel_id]\n\n        # Check berth availability for [berthing_start, berthing_start + berthing_duration)\n        if not is_berth_available(selected_berth_id, berthing_start, berthing_duration, current_solution):\n            continue\n\n        # Find inbound tug combination (greedy minimizes number, balancing load indirectly)\n        inbound_result = find_tugboat_combination(vessel_id, inbound_time, 'inbound', current_solution)\n        # Robust handling: ensure result is tuple of len 2\n        if not isinstance(inbound_result, (list, tuple)) or len(inbound_result) != 2:\n            continue\n        inbound_tugs, _ = inbound_result\n        if inbound_tugs is None or not isinstance(inbound_tugs, (list, tuple)) or len(inbound_tugs) > max_tugboats_per_service:\n            continue\n        # Verify all inbound tugs available and util threshold\n        inbound_feasible = True\n        for tug_assignment in inbound_tugs:\n            if tug_assignment is None:\n                inbound_feasible = False\n                break\n            try:\n                k, t = tug_assignment\n                if t != inbound_time or not is_tugboat_available(k, inbound_time, inbound_duration, inbound_preparation_time, current_solution):\n                    inbound_feasible = False\n                    break\n                if 0 <= k < len(tug_utilizations) and tug_utilizations[k] > min_tug_util_threshold:\n                    inbound_feasible = False\n                    break"
            }
        ]
    },
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "To verify whether the code is correct, we conducted a smoke test.\nThis is the test data:\nnum_vessels:100\nnum_berths:15\nnum_tugboats:30\navg_vessel_size:3.58\nvar_vessel_size:1.16\ntotal_required_hp:346107\ntotal_available_hp:80275\neta_span:15\navg_berthing_duration:2.25\nvessel_arrival_density:6.67\navg_time_window_flex:3.7\nberth_capacity_ratio:1.01\n\nWhile executing utilization_balanced_ub_eb0a with the given dataset, the program encountered an error and crashed. The following error message was displayed:\nTraceback (most recent call last):\n  File \"C:\\Users\\gongh\\HeurAgenix-tsp\\HeurAgenix-main\\src\\pipeline\\heuristic_generator.py\", line 163, in smoke_test\n    heuristic = load_function(heuristic_code, function_name=function_name)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"C:\\Users\\gongh\\HeurAgenix-tsp\\HeurAgenix-main\\src\\util\\util.py\", line 90, in load_function\n    assert file_path is not None\n           ^^^^^^^^^^^^^^^^^^^^^\nAssertionError\n\n\nPlease try to fix it.\n\nThe response format is very important. For better communication, please respond to me in this format:\n1. If you think this heuristic can not be implemented, respond to me ***python_code:None*** and we will stop this generation.\n2. If you can fix up this issues, please respond to me in this format:\n***python_code:\nfrom src.problems.psp.components import *\nimport other_library (if necessary)\ndef utilization_balanced_ub_eb0a(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[TargetOperatorType, dict]:\n    \"\"\" Description for this heuristic algorithm.\n\n    Args:\n        problem_state (dict): The dictionary contains the problem state.. In this algorithm, the following items are necessary:\n            - necessary_key (value type): description\n            - necessary_key (value type): description\n            ...\n        (Optional and can be omitted if no algorithm data) algorithm_data (dict): The algorithm dictionary for current algorithm only. In this algorithm, the following items are necessary:\n            - necessary_key (value type): description\n            - necessary_key (value type): description\n            ...\n        (Optional and can be omitted if no hyper parameters data) introduction for hyper parameters in kwargs if used.\n\n    Returns:\n        Description of this operator.\n        Description of updated algorithm data.\n\n        ...\n    \"\"\"\nEnsure there is no other content inside the ***, and analysis outside *** is welcome.\nIf you have no information to provide, simply respond with ***None***.\n"
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***python_code:\nfrom src.problems.psp.components import *\nimport numpy as np\nimport copy\n\ndef utilization_balanced_ub_eb0a(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[CompleteVesselAssignmentOperator, dict]:\n    \"\"\"\n    Utilization-Balanced (UB) Heuristic: A constructive heuristic that prioritizes unassigned vessels by decreasing priority weight (\u03b1_i) and attempts to assign the highest-priority vessel to a compatible berth with the lowest current utilization. The inbound service start time is centered on the vessel's ETA and adjusted within the average time window flexibility to find a feasible slot. Tugboat combinations are found using the provided helper to minimize the number of tugs (indirectly balancing utilization by efficiency), with availability checks ensuring no conflicts. The assignment is applied only if the post-assignment solution validates fully. This heuristic builds incrementally on partial solutions by assigning one vessel per invocation, promoting balanced resource use across berths and tugs.\n\n    Hyper-parameters in kwargs (with defaults):\n    - max_time_adjust (int, default=5): Maximum number of time adjustments around ETA (i.e., candidates = ETA \u00b1 max_time_adjust, clipped to time window).\n    - time_step (int, default=1): Step size for generating candidate inbound times around ETA.\n    - min_tug_util_threshold (float, default=0.8): Skip tug combinations if any selected tug's current utilization exceeds this threshold (to minimize impact on heavily used tugs).\n\n    Args:\n        problem_state (dict): The dictionary contains the problem state. In this algorithm, the following items are necessary:\n            - current_solution (Solution): Current partial solution instance to build upon.\n            - vessel_num (int): Total number of vessels.\n            - time_periods (int): Total scheduling horizon in time units.\n            - vessel_priority_weights (numpy.ndarray): Priority weights \u03b1_i for sorting vessels.\n            - vessel_etas (numpy.ndarray): Expected arrival times ETA_i for centering start times.\n            - vessel_sizes (numpy.ndarray): Vessel sizes S_i for compatibility.\n            - vessel_durations (numpy.ndarray): Berthing durations D_i for availability checks.\n            - vessel_inbound_service_times (numpy.ndarray): Inbound service durations \u03c4^in_i.\n            - vessel_outbound_service_times (numpy.ndarray): Outbound service durations \u03c4^out_i.\n            - vessel_horsepower_requirements (numpy.ndarray): Required HP P^req_i for tug selection.\n            - berth_capacities (numpy.ndarray): Berth capacities C_j for compatibility.\n            - tugboat_horsepower (numpy.ndarray): Tugboat HP P_k.\n            - tugboat_costs (numpy.ndarray): Tugboat costs c_k (unused directly but available).\n            - inbound_preparation_time (int): Prep time \u03c1^in after inbound.\n            - outbound_preparation_time (int): Prep time \u03c1^out after outbound.\n            - max_tugboats_per_service (int): H_max limit per service.\n            - avg_time_window_flex (float): Average flexibility for time adjustments.\n            - get_unassigned_vessels (callable): To get list of unassigned vessel IDs.\n            - get_vessel_time_window (callable): To get [earliest, latest] for inbound.\n            - get_compatible_berths (callable): Compatible berths for vessel.\n            - is_berth_available (callable): Berth availability check.\n            - is_tugboat_available (callable): Tugboat availability check.\n            - find_tugboat_combination (callable): To find tug combos for services.\n            - validation_solution (callable): To validate post-assignment feasibility.\n        algorithm_data (dict): Not used in this heuristic (empty dict expected).\n        **kwargs: Hyper-parameters as described above.\n\n    Returns:\n        CompleteVesselAssignmentOperator: Operator to assign the highest-priority unassigned vessel to a balanced berth/time/tug setup if feasible and valid post-assignment; None if no unassigned vessels or no feasible assignment found for the top vessel.\n        dict: Empty dict {} as no algorithm data is updated by this heuristic.\n    \"\"\"\n    # Hyper-parameter defaults\n    max_time_adjust = kwargs.get('max_time_adjust', 5)\n    time_step = kwargs.get('time_step', 1)\n    min_tug_util_threshold = kwargs.get('min_tug_util_threshold', 0.8)\n\n    # Extract necessary data from problem_state (never modify originals)\n    current_solution = problem_state['current_solution']\n    vessel_priority_weights = problem_state['vessel_priority_weights']\n    vessel_etas = problem_state['vessel_etas']\n    vessel_sizes = problem_state['vessel_sizes']\n    vessel_durations = problem_state['vessel_durations']\n    vessel_inbound_service_times = problem_state['vessel_inbound_service_times']\n    vessel_outbound_service_times = problem_state['vessel_outbound_service_times']\n    vessel_horsepower_requirements = problem_state['vessel_horsepower_requirements']\n    berth_capacities = problem_state['berth_capacities']\n    tugboat_horsepower = problem_state['tugboat_horsepower']\n    inbound_preparation_time = problem_state['inbound_preparation_time']\n    outbound_preparation_time = problem_state['outbound_preparation_time']\n    max_tugboats_per_service = problem_state['max_tugboats_per_service']\n    time_periods = problem_state['time_periods']\n    avg_time_window_flex = problem_state['avg_time_window_flex']\n\n    # Helper functions from problem_state (assumed available)\n    get_unassigned_vessels = problem_state['get_unassigned_vessels']\n    get_vessel_time_window = problem_state['get_vessel_time_window']\n    get_compatible_berths = problem_state['get_compatible_berths']\n    is_berth_available = problem_state['is_berth_available']\n    is_tugboat_available = problem_state['is_tugboat_available']\n    find_tugboat_combination = problem_state['find_tugboat_combination']\n    validation_solution = problem_state['validation_solution']\n\n    # Step 1: Get and sort unassigned vessels by decreasing priority weight (\u03b1_i)\n    unassigned_vessels_result = get_unassigned_vessels(current_solution)\n    if unassigned_vessels_result is None or not isinstance(unassigned_vessels_result, (list, tuple)):\n        return None, {}\n    unassigned_vessels = list(unassigned_vessels_result)\n    if not unassigned_vessels:\n        # No unassigned vessels: nothing to do, return empty\n        return None, {}\n\n    # Sort by decreasing priority; take the highest priority one (process one vessel per invocation for incremental construction)\n    if vessel_priority_weights is None or len(vessel_priority_weights) < max(unassigned_vessels) + 1:\n        return None, {}\n    sorted_unassigned = sorted(unassigned_vessels, key=lambda i: -vessel_priority_weights[i])\n    vessel_id = sorted_unassigned[0]  # Focus on top priority vessel\n\n    # Step 2: Get compatible berths\n    compatible_berths_result = get_compatible_berths(vessel_id)\n    if compatible_berths_result is None or not isinstance(compatible_berths_result, (list, tuple)):\n        return None, {}\n    compatible_berths = list(compatible_berths_result)\n    if not compatible_berths:\n        # No compatible berths: cannot assign, return empty\n        return None, {}\n\n    # Step 3: Compute current per-berth utilization (occupied time / time_periods)\n    # Utilization: for each berth, sum D_i of assigned vessels to it (no overlaps due to constraints)\n    if berth_capacities is None or not isinstance(berth_capacities, np.ndarray) or len(berth_capacities) == 0:\n        return None, {}\n    berth_occupied = np.zeros(len(berth_capacities))\n    if not hasattr(current_solution, 'vessel_assignments') or current_solution.vessel_assignments is None:\n        pass\n    else:\n        for assigned_vessel, assignment in current_solution.vessel_assignments.items():\n            if assignment is not None and assigned_vessel != vessel_id:\n                try:\n                    b_id, start_t = assignment\n                    if 0 <= b_id < len(berth_occupied) and start_t is not None:\n                        if 0 <= assigned_vessel < len(vessel_durations):\n                            berth_occupied[b_id] += vessel_durations[assigned_vessel]\n                except (ValueError, TypeError):\n                    continue  # Skip invalid assignments\n    berth_utilizations = berth_occupied / time_periods if time_periods > 0 else np.zeros(len(berth_occupied))\n\n    # Select compatible berth with lowest utilization (tie-break by smallest ID)\n    valid_berths = [(b, berth_utilizations[b]) for b in compatible_berths if 0 <= b < len(berth_utilizations)]\n    if not valid_berths:\n        return None, {}\n    selected_berth_id = min(valid_berths, key=lambda x: (x[1], x[0]))[0]  # min util, then min ID\n\n    # Step 4: Compute per-tug utilization for tug selection (to check threshold later)\n    # For each tug, sum (service_duration + prep) over all its assignments (inbound + outbound)\n    if tugboat_horsepower is None or not isinstance(tugboat_horsepower, np.ndarray) or len(tugboat_horsepower) == 0:\n        return None, {}\n    tug_occupied = np.zeros(len(tugboat_horsepower))\n    if not hasattr(current_solution, 'tugboat_inbound_assignments') or current_solution.tugboat_inbound_assignments is None:\n        pass\n    else:\n        for v, inbound_list in current_solution.tugboat_inbound_assignments.items():\n            if inbound_list is None or not isinstance(inbound_list, (list, tuple)):\n                continue\n            for tug_assignment in inbound_list:\n                if tug_assignment is not None:\n                    try:\n                        k, t = tug_assignment\n                        if 0 <= k < len(tug_occupied) and t is not None and 0 <= v < len(vessel_inbound_service_times):\n                            tug_occupied[k] += vessel_inbound_service_times[v] + inbound_preparation_time\n                    except (ValueError, TypeError):\n                        continue\n    if not hasattr(current_solution, 'tugboat_outbound_assignments') or current_solution.tugboat_outbound_assignments is None:\n        pass\n    else:\n        for v, outbound_list in current_solution.tugboat_outbound_assignments.items():\n            if outbound_list is None or not isinstance(outbound_list, (list, tuple)):\n                continue\n            for tug_assignment in outbound_list:\n                if tug_assignment is not None:\n                    try:\n                        k, t = tug_assignment\n                        if 0 <= k < len(tug_occupied) and t is not None and 0 <= v < len(vessel_outbound_service_times):\n                            tug_occupied[k] += vessel_outbound_service_times[v] + outbound_preparation_time\n                    except (ValueError, TypeError):\n                        continue\n    tug_utilizations = tug_occupied / time_periods if time_periods > 0 else np.zeros(len(tug_occupied))\n\n    # Step 5: Generate candidate inbound times centered on ETA, adjusted up to flex\n    if vessel_etas is None or len(vessel_etas) <= vessel_id:\n        return None, {}\n    eta = vessel_etas[vessel_id]\n    time_window = get_vessel_time_window(vessel_id)\n    # Robust check for invalid time window (prevent unpacking error if None or invalid)\n    if time_window is None or not isinstance(time_window, (list, tuple)) or len(time_window) != 2:\n        return None, {}\n    earliest_inbound, latest_inbound = time_window\n    if not (isinstance(earliest_inbound, (int, float)) and isinstance(latest_inbound, (int, float))) or earliest_inbound > latest_inbound:\n        return None, {}\n    max_adjust = min(max_time_adjust, int(avg_time_window_flex))  # Cap by avg flex\n\n    # Candidates: around ETA, step by time_step, within window\n    candidate_inbounds = []\n    for delta in range(-max_adjust, max_adjust + 1, time_step):\n        cand_time = max(earliest_inbound, min(latest_inbound, eta + delta))\n        if cand_time not in candidate_inbounds:  # Avoid duplicates\n            candidate_inbounds.append(cand_time)\n    # Sort candidates by proximity to ETA (minimize deviation)\n    candidate_inbounds.sort(key=lambda t: abs(t - eta))\n    if not candidate_inbounds:\n        return None, {}\n\n    # Step 6: For each candidate inbound time, try to find feasible tight schedule\n    best_operator = None\n    for inbound_time in candidate_inbounds:\n        # Compute derived times (tight sequencing: no extra tolerance beyond epsilon, but check availability)\n        if vessel_inbound_service_times is None or len(vessel_inbound_service_times) <= vessel_id:\n            continue\n        inbound_duration = vessel_inbound_service_times[vessel_id]\n        berthing_start = inbound_time + inbound_duration  # Start berthing right after inbound\n        if vessel_durations is None or len(vessel_durations) <= vessel_id:\n            continue\n        berthing_duration = vessel_durations[vessel_id]\n        if berthing_start + berthing_duration > time_periods:\n            continue  # Exceeds horizon\n\n        outbound_start = berthing_start + berthing_duration  # Start outbound right after berthing\n        if vessel_outbound_service_times is None or len(vessel_outbound_service_times) <= vessel_id:\n            continue\n        outbound_duration = vessel_outbound_service_times[vessel_id]\n\n        # Check berth availability for [berthing_start, berthing_start + berthing_duration)\n        if not is_berth_available(selected_berth_id, berthing_start, berthing_duration, current_solution):\n            continue\n\n        # Find inbound tug combination (greedy minimizes number, balancing load indirectly)\n        inbound_result = find_tugboat_combination(vessel_id, inbound_time, 'inbound', current_solution)\n        # Robust handling: ensure result is tuple of len 2\n        if not isinstance(inbound_result, (list, tuple)) or len(inbound_result) != 2:\n            continue\n        inbound_tugs, _ = inbound_result\n        if inbound_tugs is None or not isinstance(inbound_tugs, (list, tuple)) or len(inbound_tugs) > max_tugboats_per_service:\n            continue\n        # Verify all inbound tugs available and util threshold\n        inbound_feasible = True\n        for tug_assignment in inbound_tugs:\n            if tug_assignment is None:\n                inbound_feasible = False\n                break\n            try:\n                k, t = tug_assignment\n                if t != inbound_time or not is_tugboat_available(k, inbound_time, inbound_duration, inbound_preparation_time, current_solution):\n                    inbound_feasible = False\n                    break\n                if 0 <= k < len(tug_utilizations) and tug_utilizations[k] > min_tug_util_threshold:\n                    inbound_feasible = False\n                    break"
            }
        ]
    },
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "To verify whether the code is correct, we conducted a smoke test.\nThis is the test data:\nnum_vessels:100\nnum_berths:15\nnum_tugboats:30\navg_vessel_size:3.58\nvar_vessel_size:1.16\ntotal_required_hp:346107\ntotal_available_hp:80275\neta_span:15\navg_berthing_duration:2.25\nvessel_arrival_density:6.67\navg_time_window_flex:3.7\nberth_capacity_ratio:1.01\n\nWhile executing utilization_balanced_ub_eb0a with the given dataset, the program encountered an error and crashed. The following error message was displayed:\nTraceback (most recent call last):\n  File \"C:\\Users\\gongh\\HeurAgenix-tsp\\HeurAgenix-main\\src\\pipeline\\heuristic_generator.py\", line 163, in smoke_test\n    heuristic = load_function(heuristic_code, function_name=function_name)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"C:\\Users\\gongh\\HeurAgenix-tsp\\HeurAgenix-main\\src\\util\\util.py\", line 90, in load_function\n    assert file_path is not None\n           ^^^^^^^^^^^^^^^^^^^^^\nAssertionError\n\n\nPlease try to fix it.\n\nThe response format is very important. For better communication, please respond to me in this format:\n1. If you think this heuristic can not be implemented, respond to me ***python_code:None*** and we will stop this generation.\n2. If you can fix up this issues, please respond to me in this format:\n***python_code:\nfrom src.problems.psp.components import *\nimport other_library (if necessary)\ndef utilization_balanced_ub_eb0a(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[TargetOperatorType, dict]:\n    \"\"\" Description for this heuristic algorithm.\n\n    Args:\n        problem_state (dict): The dictionary contains the problem state.. In this algorithm, the following items are necessary:\n            - necessary_key (value type): description\n            - necessary_key (value type): description\n            ...\n        (Optional and can be omitted if no algorithm data) algorithm_data (dict): The algorithm dictionary for current algorithm only. In this algorithm, the following items are necessary:\n            - necessary_key (value type): description\n            - necessary_key (value type): description\n            ...\n        (Optional and can be omitted if no hyper parameters data) introduction for hyper parameters in kwargs if used.\n\n    Returns:\n        Description of this operator.\n        Description of updated algorithm data.\n\n        ...\n    \"\"\"\nEnsure there is no other content inside the ***, and analysis outside *** is welcome.\nIf you have no information to provide, simply respond with ***None***.\n"
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***python_code:\nfrom src.problems.psp.components import *\nimport numpy as np\nimport copy\n\ndef utilization_balanced_ub_eb0a(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[CompleteVesselAssignmentOperator, dict]:\n    \"\"\"\n    Utilization-Balanced (UB) Heuristic: A constructive heuristic that prioritizes unassigned vessels by decreasing priority weight (\u03b1_i) and attempts to assign the highest-priority vessel to a compatible berth with the lowest current utilization. The inbound service start time is centered on the vessel's ETA and adjusted within the average time window flexibility to find a feasible slot. Tugboat combinations are found using the provided helper to minimize the number of tugs (indirectly balancing utilization by efficiency), with availability checks ensuring no conflicts. The assignment is applied only if the post-assignment solution validates fully. This heuristic builds incrementally on partial solutions by assigning one vessel per invocation, promoting balanced resource use across berths and tugs.\n\n    Hyper-parameters in kwargs (with defaults):\n    - max_time_adjust (int, default=5): Maximum number of time adjustments around ETA (i.e., candidates = ETA \u00b1 max_time_adjust, clipped to time window).\n    - time_step (int, default=1): Step size for generating candidate inbound times around ETA.\n    - min_tug_util_threshold (float, default=0.8): Skip tug combinations if any selected tug's current utilization exceeds this threshold (to minimize impact on heavily used tugs).\n\n    Args:\n        problem_state (dict): The dictionary contains the problem state. In this algorithm, the following items are necessary:\n            - current_solution (Solution): Current partial solution instance to build upon.\n            - vessel_num (int): Total number of vessels.\n            - time_periods (int): Total scheduling horizon in time units.\n            - vessel_priority_weights (numpy.ndarray): Priority weights \u03b1_i for sorting vessels.\n            - vessel_etas (numpy.ndarray): Expected arrival times ETA_i for centering start times.\n            - vessel_sizes (numpy.ndarray): Vessel sizes S_i for compatibility.\n            - vessel_durations (numpy.ndarray): Berthing durations D_i for availability checks.\n            - vessel_inbound_service_times (numpy.ndarray): Inbound service durations \u03c4^in_i.\n            - vessel_outbound_service_times (numpy.ndarray): Outbound service durations \u03c4^out_i.\n            - vessel_horsepower_requirements (numpy.ndarray): Required HP P^req_i for tug selection.\n            - berth_capacities (numpy.ndarray): Berth capacities C_j for compatibility.\n            - tugboat_horsepower (numpy.ndarray): Tugboat HP P_k.\n            - tugboat_costs (numpy.ndarray): Tugboat costs c_k (unused directly but available).\n            - inbound_preparation_time (int): Prep time \u03c1^in after inbound.\n            - outbound_preparation_time (int): Prep time \u03c1^out after outbound.\n            - max_tugboats_per_service (int): H_max limit per service.\n            - avg_time_window_flex (float): Average flexibility for time adjustments.\n            - get_unassigned_vessels (callable): To get list of unassigned vessel IDs.\n            - get_vessel_time_window (callable): To get [earliest, latest] for inbound.\n            - get_compatible_berths (callable): Compatible berths for vessel.\n            - is_berth_available (callable): Berth availability check.\n            - is_tugboat_available (callable): Tugboat availability check.\n            - find_tugboat_combination (callable): To find tug combos for services.\n            - validation_solution (callable): To validate post-assignment feasibility.\n        algorithm_data (dict): Not used in this heuristic (empty dict expected).\n        **kwargs: Hyper-parameters as described above.\n\n    Returns:\n        CompleteVesselAssignmentOperator: Operator to assign the highest-priority unassigned vessel to a balanced berth/time/tug setup if feasible and valid post-assignment; None if no unassigned vessels or no feasible assignment found for the top vessel.\n        dict: Empty dict {} as no algorithm data is updated by this heuristic.\n    \"\"\"\n    # Hyper-parameter defaults\n    max_time_adjust = kwargs.get('max_time_adjust', 5)\n    time_step = kwargs.get('time_step', 1)\n    min_tug_util_threshold = kwargs.get('min_tug_util_threshold', 0.8)\n\n    # Extract necessary data from problem_state (never modify originals)\n    current_solution = problem_state['current_solution']\n    vessel_priority_weights = problem_state['vessel_priority_weights']\n    vessel_etas = problem_state['vessel_etas']\n    vessel_sizes = problem_state['vessel_sizes']\n    vessel_durations = problem_state['vessel_durations']\n    vessel_inbound_service_times = problem_state['vessel_inbound_service_times']\n    vessel_outbound_service_times = problem_state['vessel_outbound_service_times']\n    vessel_horsepower_requirements = problem_state['vessel_horsepower_requirements']\n    berth_capacities = problem_state['berth_capacities']\n    tugboat_horsepower = problem_state['tugboat_horsepower']\n    inbound_preparation_time = problem_state['inbound_preparation_time']\n    outbound_preparation_time = problem_state['outbound_preparation_time']\n    max_tugboats_per_service = problem_state['max_tugboats_per_service']\n    time_periods = problem_state['time_periods']\n    avg_time_window_flex = problem_state['avg_time_window_flex']\n\n    # Helper functions from problem_state (assumed available)\n    get_unassigned_vessels = problem_state['get_unassigned_vessels']\n    get_vessel_time_window = problem_state['get_vessel_time_window']\n    get_compatible_berths = problem_state['get_compatible_berths']\n    is_berth_available = problem_state['is_berth_available']\n    is_tugboat_available = problem_state['is_tugboat_available']\n    find_tugboat_combination = problem_state['find_tugboat_combination']\n    validation_solution = problem_state['validation_solution']\n\n    # Step 1: Get and sort unassigned vessels by decreasing priority weight (\u03b1_i)\n    unassigned_vessels_result = get_unassigned_vessels(current_solution)\n    if unassigned_vessels_result is None or not isinstance(unassigned_vessels_result, (list, tuple)):\n        return None, {}\n    unassigned_vessels = list(unassigned_vessels_result)\n    if not unassigned_vessels:\n        # No unassigned vessels: nothing to do, return empty\n        return None, {}\n\n    # Sort by decreasing priority; take the highest priority one (process one vessel per invocation for incremental construction)\n    if vessel_priority_weights is None or not isinstance(vessel_priority_weights, np.ndarray) or len(vessel_priority_weights) < max(unassigned_vessels) + 1:\n        return None, {}\n    sorted_unassigned = sorted(unassigned_vessels, key=lambda i: -vessel_priority_weights[i])\n    vessel_id = sorted_unassigned[0]  # Focus on top priority vessel\n\n    # Step 2: Get compatible berths\n    compatible_berths_result = get_compatible_berths(vessel_id)\n    if compatible_berths_result is None or not isinstance(compatible_berths_result, (list, tuple)):\n        return None, {}\n    compatible_berths = list(compatible_berths_result)\n    if not compatible_berths:\n        # No compatible berths: cannot assign, return empty\n        return None, {}\n\n    # Step 3: Compute current per-berth utilization (occupied time / time_periods)\n    # Utilization: for each berth, sum D_i of assigned vessels to it (no overlaps due to constraints)\n    if berth_capacities is None or not isinstance(berth_capacities, np.ndarray) or len(berth_capacities) == 0:\n        return None, {}\n    berth_occupied = np.zeros(len(berth_capacities))\n    if not hasattr(current_solution, 'vessel_assignments') or current_solution.vessel_assignments is None:\n        pass\n    else:\n        for assigned_vessel, assignment in current_solution.vessel_assignments.items():\n            if assignment is not None and assigned_vessel != vessel_id:\n                try:\n                    if isinstance(assignment, (list, tuple)) and len(assignment) == 2:\n                        b_id, start_t = assignment\n                        if isinstance(b_id, int) and isinstance(start_t, (int, type(None))) and 0 <= b_id < len(berth_occupied) and start_t is not None:\n                            if isinstance(assigned_vessel, int) and 0 <= assigned_vessel < len(vessel_durations):\n                                berth_occupied[b_id] += vessel_durations[assigned_vessel]\n                except (ValueError, TypeError, IndexError):\n                    continue  # Skip invalid assignments\n    berth_utilizations = berth_occupied / time_periods if time_periods > 0 else np.zeros(len(berth_occupied))\n\n    # Select compatible berth with lowest utilization (tie-break by smallest ID)\n    valid_berths = [(b, berth_utilizations[b]) for b in compatible_berths if 0 <= b < len(berth_utilizations)]\n    if not valid_berths:\n        return None, {}\n    selected_berth_id = min(valid_berths, key=lambda x: (x[1], x[0]))[0]  # min util, then min ID\n\n    # Step 4: Compute per-tug utilization for tug selection (to check threshold later)\n    # For each tug, sum (service_duration + prep) over all its assignments (inbound + outbound)\n    if tugboat_horsepower is None or not isinstance(tugboat_horsepower, np.ndarray) or len(tugboat_horsepower) == 0:\n        return None, {}\n    tug_occupied = np.zeros(len(tugboat_horsepower))\n    if not hasattr(current_solution, 'tugboat_inbound_assignments') or current_solution.tugboat_inbound_assignments is None:\n        pass\n    else:\n        for v, inbound_list in current_solution.tugboat_inbound_assignments.items():\n            if inbound_list is None or not isinstance(inbound_list, (list, tuple)):\n                continue\n            for tug_assignment in inbound_list:\n                if tug_assignment is not None:\n                    try:\n                        if isinstance(tug_assignment, (list, tuple)) and len(tug_assignment) == 2:\n                            k, t = tug_assignment\n                            if isinstance(k, int) and isinstance(t, (int, type(None))) and 0 <= k < len(tug_occupied) and t is not None:\n                                if isinstance(v, int) and 0 <= v < len(vessel_inbound_service_times):\n                                    tug_occupied[k] += vessel_inbound_service_times[v] + inbound_preparation_time\n                    except (ValueError, TypeError, IndexError):\n                        continue\n    if not hasattr(current_solution, 'tugboat_outbound_assignments') or current_solution.tugboat_outbound_assignments is None:\n        pass\n    else:\n        for v, outbound_list in current_solution.tugboat_outbound_assignments.items():\n            if outbound_list is None or not isinstance(outbound_list, (list, tuple)):\n                continue\n            for tug_assignment in outbound_list:\n                if tug_assignment is not None:\n                    try:\n                        if isinstance(tug_assignment, (list, tuple)) and len(tug_assignment) == 2:\n                            k, t = tug_assignment\n                            if isinstance(k, int) and isinstance(t, (int, type(None))) and 0 <= k < len(tug_occupied) and t is not None:\n                                if isinstance(v, int) and 0 <= v < len(vessel_outbound_service_times):\n                                    tug_occupied[k] += vessel_outbound_service_times[v] + outbound_preparation_time\n                    except (ValueError, TypeError, IndexError):\n                        continue\n    tug_utilizations = tug_occupied / time_periods if time_periods > 0 else np.zeros(len(tug_occupied))\n\n    # Step 5: Generate candidate inbound times centered on ETA, adjusted up to flex\n    if vessel_etas is None or not isinstance(vessel_etas, np.ndarray) or len(vessel_etas) <= vessel_id:\n        return None, {}\n    eta = vessel_etas[vessel_id]\n    time_window = get_vessel_time_window(vessel_id)\n    # Robust check for invalid time window (prevent unpacking error if None or invalid)\n    if time_window is None or not isinstance(time_window, (list, tuple)) or len(time_window) != 2:\n        return None, {}\n    earliest_inbound, latest_inbound = time_window\n    if not (isinstance(earliest_inbound, (int, float)) and isinstance(latest_inbound, (int, float))) or earliest_inbound > latest_inbound:\n        return None, {}\n    max_adjust = min(max_time_adjust, int(avg_time_window_flex))  # Cap by avg flex\n\n    # Candidates: around ETA, step by time_step, within window\n    candidate_inbounds = []\n    for delta in range(-max_adjust, max_adjust + 1, time_step):\n        cand_time = max(earliest_inbound, min(latest_inbound, eta + delta))\n        if cand_time not in candidate_inbounds:  # Avoid duplicates\n            candidate_inbounds.append(cand_time)\n    # Sort candidates by proximity to ETA (minimize deviation)\n    candidate_inbounds.sort(key=lambda t: abs(t - eta))\n    if not candidate_inbounds:\n        return None, {}\n\n    # Step 6: For each candidate inbound time, try to find feasible tight schedule\n    for inbound_time in candidate_inbounds:\n        # Compute derived times (tight sequencing: no extra tolerance beyond epsilon, but check availability)\n        if vessel_inbound_service_times is None or not isinstance(vessel_inbound_service_times, np.ndarray) or len(vessel_inbound_service_times) <= vessel_id:\n            continue\n        inbound_duration = vessel_inbound_service_times[vessel_id]\n        berthing_start = inbound_time + inbound_duration  # Start berthing right after inbound\n        if vessel_durations is None or not isinstance(vessel_durations, np.ndarray) or len(vessel_durations) <= vessel_id:\n            continue\n        berthing_duration = vessel_durations[vessel_id]\n        if berthing_start + berthing_duration > time_periods:\n            continue  # Exceeds horizon\n\n        outbound_start = berthing_start + berthing_duration  # Start outbound right after berthing\n        if vessel_outbound_service_times is None or not isinstance(vessel_outbound_service_times, np.ndarray) or len(vessel_outbound_service_times) <= vessel_id:\n            continue\n        outbound_duration = vessel_outbound_service_times[vessel_id]\n\n        # Check berth availability for [berthing_start, berthing_start + berthing_duration)\n        if not is_berth_available(selected_berth_id, berthing_start, berthing_duration, current_solution):\n            continue\n\n        # Find inbound tug combination (greedy minimizes number, balancing load indirectly)\n        inbound_result = find_tugboat_combination(vessel_id, inbound_time, 'inbound', current_solution)\n        # Robust handling: ensure result is tuple of len 2\n        if not"
            }
        ]
    },
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "We can not implement and give up."
            }
        ]
    }
]