user
I am working on Hyper-heuristics for Combinatorial Operation (CO) problem.

Currently, I am working on psp problem:
Port Scheduling Problem (PSP) - Mathematical Model Description

Problem Overview

The Port Scheduling Problem (PSP) involves optimal allocation of vessels to berths with coordinated tugboat services. The system manages multiple berths with different capacity levels, multiple tugboats with varying horsepower capabilities, and multiple vessels with specific requirements and time constraints.

Key Problem Characteristics

Each vessel must receive three sequential services if allocated:
1. Inbound tugboat service - to guide vessel to berth
2. Berthing service - vessel occupies berth for cargo operations
3. Outbound tugboat service - to guide vessel away from berth

The services must be properly sequenced and temporally connected within allowable time tolerances. Vessels that cannot receive complete service are penalized heavily.

Mathematical Model Formulation

Decision Variables
- x_ijt ∈ {0,1}: vessel i starts berthing at berth j at time t (only if berth capacity Cⱼ ≥ vessel size Sᵢ)
- y^in_ikt ∈ {0,1}: tugboat k starts inbound service for vessel i at time t
- y^out_ikt ∈ {0,1}: tugboat k starts outbound service for vessel i at time t
- z^in_it ∈ {0,1}: auxiliary variable indicating vessel i starts inbound tugboat service at time t
- z^out_it ∈ {0,1}: auxiliary variable indicating vessel i starts outbound tugboat service at time t
- u^early_i ≥ 0: early deviation from ETA for vessel i
- u^late_i ≥ 0: late deviation from ETA for vessel i

Objective Function
Minimize: λ₁Z₁ + λ₂Z₂ + λ₃Z₃ + λ₄Z₄

Where:
- Z₁ = Σᵢ M·αᵢ·(1 - Σⱼ Σₜ x_ijt) [Unserved vessel penalty]
- Z₂ = Σᵢ αᵢ·βᵢ·[Σₜ (t + τ^out_i)·z^out_it - Σₜ t·z^in_it] [Total port time cost]
- Z₃ = Σᵢ αᵢ·γᵢ·(u^early_i + u^late_i) [ETA deviation cost]
- Z₄ = Σₖ Σᵢ Σₜ cₖ·(τ^in_i·y^in_ikt + τ^out_i·y^out_ikt) [Tugboat utilization cost]

Complete Constraint Set

Constraint (1): Vessel Assignment Constraints
Σⱼ Σₜ x_ijt ≤ 1, ∀i ∈ I
Each vessel can be assigned at most once.

Constraint (2): Vessel-Berth Compatibility Constraints
x_ijt = 0, ∀i ∈ I, j ∈ J, t ∈ T : Cⱼ < Sᵢ
Vessels can only be assigned to berths with sufficient capacity.

Constraint (3): Inbound Tugboat Service Coupling
Σₜ z^in_it = Σⱼ Σₜ x_ijt, ∀i ∈ I
If a vessel is assigned to any berth, it must receive inbound tugboat service exactly once.

Constraint (4): Outbound Tugboat Service Coupling
Σₜ z^out_it = Σⱼ Σₜ x_ijt, ∀i ∈ I
If a vessel is assigned to any berth, it must receive outbound tugboat service exactly once.

Constraint (5): Tugboat Horsepower Constraints for Inbound
Σₖ Pₖ·y^in_ikt ≥ P^req_i·z^in_it, ∀i ∈ I, t ∈ T
Assigned tugboats must provide sufficient total horsepower for inbound service.

Constraint (6): Tugboat Horsepower Constraints for Outbound
Σₖ Pₖ·y^out_ikt ≥ P^req_i·z^out_it, ∀i ∈ I, t ∈ T
Assigned tugboats must provide sufficient total horsepower for outbound service.

Constraint (7): Tugboat Quantity Limits for Inbound
Σₖ y^in_ikt ≤ H_max·z^in_it, ∀i ∈ I, t ∈ T
Maximum number of tugboats per inbound service is limited to H_max.

Constraint (8): Tugboat Quantity Limits for Outbound
Σₖ y^out_ikt ≤ H_max·z^out_it, ∀i ∈ I, t ∈ T
Maximum number of tugboats per outbound service is limited to H_max.

Constraint (9): Auxiliary Variable Definition for Inbound
z^in_it ≤ Σₖ y^in_ikt, ∀i ∈ I, t ∈ T
Auxiliary variables for inbound service are properly linked to tugboat assignment variables.
Additional requirement: All tugboats serving the same vessel for inbound service must start at the same time.

Constraint (10): Auxiliary Variable Definition for Outbound
z^out_it ≤ Σₖ y^out_ikt, ∀i ∈ I, t ∈ T
Auxiliary variables for outbound service are properly linked to tugboat assignment variables.
Additional requirement: All tugboats serving the same vessel for outbound service must start at the same time.

Constraint (11): Berth Capacity Constraints
Σᵢ Σₜ'=max(1,t-Dᵢ+1)^t x_ijt' ≤ 1, ∀j ∈ J, t ∈ T
Each berth can accommodate at most one vessel at any time, considering vessel duration Dᵢ.

Constraint (12): Tugboat Capacity Constraints (with Preparation Time)
Σᵢ [Σₜ'=max(1,t-τ^in_i-ρ^in+1)^t y^in_ikt' + Σₜ'=max(1,t-τ^out_i-ρ^out+1)^t y^out_ikt'] ≤ 1, ∀k ∈ K, t ∈ T
Each tugboat can provide only one service at a time, including preparation time between services.

Constraint (13): Inbound Service Time Window Constraints
y^in_ikt = 0, ∀i ∈ I, k ∈ K, t < ETAᵢ - Δ^early_i or t > ETAᵢ + Δ^late_i
Tugboat inbound services can only start within the vessel's ETA allowed time window.

Constraint (14): Inbound-Berthing Timing Sequence Constraints
0 ≤ Σⱼ Σₜ t·x_ijt - Σₜ (t + τ^in_i)·z^in_it ≤ ε_time·Σⱼ Σₜ x_ijt, ∀i ∈ I
Berthing must start after inbound service completion, within tolerance ε_time.

Constraint (15): Berthing-Outbound Timing Sequence Constraints
0 ≤ Σₜ t·z^out_it - Σⱼ Σₜ (t + Dᵢ)·x_ijt ≤ ε_time·Σⱼ Σₜ x_ijt, ∀i ∈ I
Outbound service must start after berthing completion, within tolerance ε_time.

Constraint (16): ETA Deviation Linearization Constraints
Σₜ t·z^in_it = ETAᵢ + u^late_i - u^early_i, ∀i ∈ I
Linear representation of ETA deviations for cost calculation.

Constraint (17): Variable Domain Constraints
u^early_i, u^late_i ≥ 0, ∀i ∈ I
x_ijt, y^in_ikt, y^out_ikt, z^in_it, z^out_it ∈ {0,1}, ∀i ∈ I, j ∈ J, k ∈ K, t ∈ T
Variable domain constraints for all decision variables.

Input Parameters

Vessel Parameters
- Sᵢ: Size level of vessel i
- ETAᵢ: Expected arrival time of vessel i
- Dᵢ: Berthing duration required by vessel i
- τ^in_i, τ^out_i: Inbound and outbound tugboat service durations for vessel i
- P^req_i: Minimum tugboat horsepower required by vessel i
- Δ^early_i, Δ^late_i: Maximum allowed early/late deviations from ETA for vessel i
- αᵢ, βᵢ, γᵢ: Priority weight, unit waiting cost, and JIT deviation unit cost for vessel i

Berth Parameters
- Cⱼ: Capacity level of berth j

Tugboat Parameters
- Pₖ: Horsepower of tugboat k
- cₖ: Unit time usage cost of tugboat k
- ρ^in, ρ^out: Preparation times for tugboats after completing inbound/outbound services

System Parameters
- H_max: Maximum number of tugboats allowed per service
- ε_time: Maximum allowed time deviation in sequencing constraints
- M: Large penalty parameter for unserved vessels
- λ₁, λ₂, λ₃, λ₄: Weighting coefficients in the objective function

Problem Constraints Summary

The model ensures that:
1. Each vessel receives complete service (inbound → berthing → outbound) or no service at all
2. Services follow proper temporal sequence with bounded time gaps
3. Resource capacity constraints are respected for both berths and tugboats
4. Tugboat horsepower and quantity requirements are satisfied
5. Tugboat inbound services can only start within the vessel's ETA allowed time window.
6. Berth-vessel size compatibility is maintained
7. Tugboat availability considering preparation times is enforced
8. All tugboats serving the same vessel must start their service at the same time

To support different heuristic algorithms, I build the Solution and Operator framework.
The Solution is designed as:
class Solution:
    """The solution of Port Scheduling Problem supporting multi-tugboat services.
Attributes:
    vessel_assignments (dict): Maps vessel_id to (berth_id, start_time) tuple. None if vessel is unassigned.
    tugboat_inbound_assignments (dict): Maps vessel_id to list of tuple (tugboat_id, start_time) for inbound service.
    tugboat_outbound_assignments (dict): Maps vessel_id to list of tuple (tugboat_id, start_time) for outbound service."""
    def __init__(self, vessel_assignments: dict=None, tugboat_inbound_assignments: dict=None, tugboat_outbound_assignments: dict=None):
        self.vessel_assignments = vessel_assignments or {}
        self.tugboat_inbound_assignments = tugboat_inbound_assignments or {}
        self.tugboat_outbound_assignments = tugboat_outbound_assignments or {}
Operator servers as a mechanism to modify solution, which enables the application of heuristic algorithms. 
To support heuristic algorithm, we have build the following operators:
class CompleteVesselAssignmentOperator(BaseOperator):
    """Assign a vessel to berth with complete multi-tugboat services and feasibility validation."""
    def __init__(self, vessel_id: int, berth_id: int, start_time: int, inbound_tugboats: List[Tuple[int, int]], outbound_tugboats: List[Tuple[int, int]]):
        self.vessel_id = vessel_id
        self.berth_id = berth_id
        self.start_time = start_time
        self.inbound_tugboats = inbound_tugboats
        self.outbound_tugboats = outbound_tugboats
    def run(self, solution: Solution) -> Solution:
        if not self.inbound_tugboats or not self.outbound_tugboats:
            return copy.deepcopy(solution)
        if len(self.inbound_tugboats) > 1:
            inbound_times = [start_time for _, start_time in self.inbound_tugboats]
            if len(set(inbound_times)) > 1:
                return copy.deepcopy(solution)
        if len(self.outbound_tugboats) > 1:
            outbound_times = [start_time for _, start_time in self.outbound_tugboats]
            if len(set(outbound_times)) > 1:
                return copy.deepcopy(solution)
        new_vessel_assignments = copy.deepcopy(solution.vessel_assignments)
        new_tugboat_inbound = copy.deepcopy(solution.tugboat_inbound_assignments)
        new_tugboat_outbound = copy.deepcopy(solution.tugboat_outbound_assignments)
        new_vessel_assignments[self.vessel_id] = (self.berth_id, self.start_time)
        new_tugboat_inbound[self.vessel_id] = copy.deepcopy(self.inbound_tugboats)
        new_tugboat_outbound[self.vessel_id] = copy.deepcopy(self.outbound_tugboats)
        return Solution(vessel_assignments=new_vessel_assignments, tugboat_inbound_assignments=new_tugboat_inbound, tugboat_outbound_assignments=new_tugboat_outbound)
class UnassignVesselOperator(BaseOperator):
    """Remove assignment for a vessel."""
    def __init__(self, vessel_id: int):
        self.vessel_id = vessel_id
    def run(self, solution: Solution) -> Solution:
        new_vessel_assignments = copy.deepcopy(solution.vessel_assignments)
        new_tugboat_inbound = copy.deepcopy(solution.tugboat_inbound_assignments)
        new_tugboat_outbound = copy.deepcopy(solution.tugboat_outbound_assignments)
        new_vessel_assignments[self.vessel_id] = None
        new_tugboat_inbound[self.vessel_id] = []
        new_tugboat_outbound[self.vessel_id] = []
        return Solution(vessel_assignments=new_vessel_assignments, tugboat_inbound_assignments=new_tugboat_inbound, tugboat_outbound_assignments=new_tugboat_outbound)

In pursuit of augmenting our heuristic algorithmic suite, we require the following standardized heuristic function signature:
def heuristic(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[TargetOperatorType, dict]:
The inputs are:
problem_state (dict): A dictionary containing the problem state information, organized into five categories of keys:
1. Input Data:
    - vessel_num (int): The total number of vessels requesting berthing service.
    - berth_num (int): The total number of berths available at the port.
    - tugboat_num (int): The total number of tugboats available for service.
    - time_periods (int): The total number of time periods in the scheduling horizon.
    - vessel_sizes (numpy.ndarray): 1D array of size levels for each vessel (Si).
    - berth_capacities (numpy.ndarray): 1D array of capacity levels for each berth (Cj).
    - vessel_etas (numpy.ndarray): 1D array of expected arrival times for each vessel (ETAi).
    - vessel_durations (numpy.ndarray): 1D array of berthing durations required by each vessel (Di).
    - vessel_inbound_service_times (numpy.ndarray): 1D array of inbound tugboat service durations for each vessel.
    - vessel_outbound_service_times (numpy.ndarray): 1D array of outbound tugboat service durations for each vessel.
    - vessel_priority_weights (numpy.ndarray): 1D array of priority weights for each vessel.
    - vessel_waiting_costs (numpy.ndarray): 1D array of unit waiting costs for each vessel.
    - vessel_jit_costs (numpy.ndarray): 1D array of JIT deviation unit costs for each vessel.
    - vessel_horsepower_requirements (numpy.ndarray): 1D array of minimum tugboat horsepower required by each vessel.
    - vessel_early_limits (numpy.ndarray): 1D array of maximum early arrival allowances for each vessel.
    - vessel_late_limits (numpy.ndarray): 1D array of maximum late arrival allowances for each vessel.
    - tugboat_horsepower (numpy.ndarray): 1D array of horsepower for each tugboat.
    - tugboat_costs (numpy.ndarray): 1D array of unit time usage costs for each tugboat.
    - inbound_preparation_time (int): Preparation time for tugboats after completing inbound service (rho_in).
    - outbound_preparation_time (int): Preparation time for tugboats after completing outbound service (rho_out).
    - max_tugboats_per_service (int): Maximum number of tugboats allowed for a single service (Hmax).
    - time_constraint_tolerance (float): Maximum allowed time deviation in timing constraints (epsilon_time).
    - penalty_parameter (float): Large penalty parameter for unserved vessels.
    - objective_weights (numpy.ndarray): 1D array of four weighting coefficients [lambda_1, lambda_2, lambda_3, lambda_4] for objective function components.
2. Current Solution:
    - current_solution (Solution): Current solution instance.
    - total_scheduling_cost (float): The total scheduling cost of the current solution.
3. Helper Functions (these Functions may help you to generation the following heuristic):
    - get_problem_state (callable): def get_problem_state(solution: Solution) -> dict: The function to get the complete problem state for given solution without modifying it. Returns a dictionary containing state information.
    - validation_solution (callable): def validation_solution(solution: Solution = None) -> bool: The function to check whether the solution is valid according to all mathematical model constraints. If solution is None, checks current solution. Returns True if valid, False otherwise.
    - get_unassigned_vessels (callable): def get_unassigned_vessels(solution: Solution = None) -> list[int]: Get list of vessel IDs that have not been assigned to any berth. If solution is None, uses current solution. Returns list of integers representing unassigned vessel IDs (range 0 to vessel_num-1).
    - get_vessel_time_window (callable): def get_vessel_time_window(vessel_id: int) -> tuple[int, int]: Get the feasible time window (earliest_start, latest_start) for vessel's inbound service considering ETA and early/late limits. Returns tuple of two integers representing the valid start time range.
    - get_compatible_berths (callable): def get_compatible_berths(vessel_id: int) -> list[int]: Get list of berth IDs that can serve the vessel based on capacity level compatibility (berth_capacity >= vessel_size). Returns list of integers representing compatible berth IDs (range 0 to berth_num-1).
    - is_berth_available (callable): def is_berth_available(berth_id: int, start_time: int, duration: int, solution: Solution = None) -> bool: Check if a berth is free during the specified time period [start_time, start_time + duration) without conflicts with existing assignments. If solution is None, uses current solution. Returns True if available, False if conflicted.
    - is_tugboat_available (callable): def is_tugboat_available(tugboat_id: int, start_time: int, duration: int, prep_time: int = 0, solution: Solution = None) -> bool: Check if a tugboat is free during the specified service period [start_time, start_time + duration + prep_time) including preparation time. If solution is None, uses current solution. Returns True if available, False if conflicted.
    - find_tugboat_combination (callable): def find_tugboat_combination(vessel_id: int, start_time: int, service_type: str, solution: Solution = None) -> tuple: Find a tugboat combination with sufficient horsepower for the service using greedy selection. The service_type parameter accepts 'inbound' or 'outbound'. Uses greedy strategy sorting tugboats by horsepower descending to minimize the number of tugboats needed. If greedy fails, performs exhaustive search to find any valid combination. Returns (selected_tugboats, total_cost) where selected_tugboats is a list of (tugboat_id, start_time) tuples, or (None, 0) if no valid combination found that meets horsepower requirements within tugboat quantity limits.
    - find_feasible_assignments (callable): def find_feasible_assignments(vessel_id: int, max_results: int = 3, solution: Solution = None) -> list[dict]: Find a feasible complete assignment (berth + multi-tugboat services) for a vessel using ETA-centered heuristic search. Tries candidate inbound times near ETA (ETA ± {0,1,2,3,4}) in order of proximity to ETA. Uses tight scheduling with berth starting immediately after inbound service and outbound starting immediately after berthing. Returns immediately upon finding the first valid assignment. Returns list containing at most one dictionary with: {'berth_id': int, 'start_time': int, 'inbound_tugboats': list[tuple[int, int]], 'outbound_tugboats': list[tuple[int, int]], 'total_cost': float}. The tugboat lists contain multiple tuples of (tugboat_id, start_time) representing tugboat combinations that meet horsepower requirements. All timing constraints and horsepower constraints are properly handled. Returns empty list if no feasible assignment found.
    - calculate_assignment_cost (callable): def calculate_assignment_cost(vessel_id: int, berth_id: int, start_time: int, inbound_tugboats: list, outbound_tugboats: list) -> float: Calculate the total cost for a specific vessel assignment including port time cost (Z2), ETA deviation cost (Z3), and tugboat utilization cost (Z4). The inbound_tugboats and outbound_tugboats parameters are lists of (tugboat_id, start_time) tuples representing multi-tugboat combinations. Returns float representing the assignment cost, or float('inf') if assignment is invalid.
4. Instance Statistics (these Instance Statistics may help you to generation the following heuristic):
   - num_vessels (int): Number of vessels.
    - num_berths (int): Number of berths.
    - num_tugboats (int): Number of tugboats.
    - avg_vessel_size (float): Average vessel size.
    - var_vessel_size (float): Variance of vessel sizes.
    - total_required_hp (float): Total required horsepower for all vessels.
    - total_available_hp (float): Total available horsepower from all tugboats.
    - eta_span (float): Span between maximum and minimum ETA.
    - avg_berthing_duration (float): Average berthing duration.
    - vessel_arrival_density (float): Density of vessel arrivals (num_vessels / eta_span).
    - avg_time_window_flex (float): Average flexibility in time windows (mean of early + late limits).
    - berth_capacity_ratio (float): Ratio of average berth capacity to average vessel size.
5. Current Solution Statistics (these Solution Statistics may help you to generation the following heuristic):
    - assigned_vessels_fraction (float): Fraction of vessels with full service assignments (inbound, berthing, outbound).
    - partial_objective_value (float): Partial objective value computed as weighted sum of Z1 to Z4 for the current assignments.
    - unassigned_vessels (int): Number of vessels without full service assignments.
    - berth_utilization (float): Utilization of berths based on assigned berthing durations.
    - tug_utilization (float): Utilization of tugboats based on assigned service durations.
    - avg_eta_deviation_assigned (float): Average ETA deviation for vessels with full assignments.
    - remaining_hp_demand (float): Total horsepower requirement for unassigned vessels.
    - schedule_progress (float): Progress as the maximum end time of assigned services normalized by time periods.
    - full_service_completion_rate (float): Fraction of vessels with full and valid service assignments (no local violations).
    - potential_conflict_ratio (float): Ratio of full assignments that have local violations.
algorithm_data(dict): Algorithm data contains the data that necessary for some algorithms.
Other hyper-parameters in kwargs.
The outputs includes the operator that must be an instance of a predefined target operator type and updated algorithm dict, which contains new information for future work for both this or other algorithm.

Please consider is psp a combinatorial operation problem and can be solved by heuristics?
If you think this problem is not a combinatorial operation problem or the solution, operator, data are incorrect, response ***is_cop:no*** to me, or response ***is_cop:yes***.

The response format is very important. For better communication, please respond to me in this format:
***is_cop:yes/no***
Ensure there is no other content inside the ***, and analysis outside *** is welcome.
If you have no information to provide, simply respond with ***None***.
------------------------------------------------------------------------------------

assistant
***is_cop:yes***

The Port Scheduling Problem (PSP) is indeed a classic example of a combinatorial optimization (CO) problem. It involves discrete decision-making—such as assigning vessels to specific berths at discrete times, selecting combinations of tugboats for inbound/outbound services, and ensuring feasibility under constraints like capacity, horsepower requirements, timing sequences, and resource availability. The objective is to minimize a multi-component cost function (penalties for unserved vessels, port time, ETA deviations, and tugboat usage), which aligns with CO characteristics: a finite search space of feasible combinations, NP-hard complexity due to scheduling and resource allocation interdependencies, and the need for optimization over exponential possibilities.

Heuristics (and hyper-heuristics) are well-suited for solving PSP, as exact methods (e.g., MILP solvers) may be intractable for realistic instances with large time horizons, multiple vessels, berths, and tugboats. Your framework supports this effectively: the Solution class encapsulates the state (assignments for vessels and tugboats), operators like CompleteVesselAssignmentOperator and UnassignVesselOperator enable local search/modifications, and the provided helper functions (e.g., find_tugboat_combination, find_feasible_assignments) facilitate greedy, nearest-neighbor, or metaheuristic approaches. The heuristic signature allows generating targeted operators (e.g., for assigning unserved vessels or resolving conflicts) while updating algorithm data for iterative improvement, making it extensible for methods like genetic algorithms, simulated annealing, or hyper-heuristic selection.

Potential enhancements: Consider adding operators for swapping assignments between vessels or adjusting timings to handle dynamic densities (using instance stats like vessel_arrival_density). Validation via the mathematical constraints ensures heuristic-generated solutions remain feasible or quantifiable in terms of violations. Overall, the setup is solid and correctly oriented toward CO heuristics.
------------------------------------------------------------------------------------

user
I need your help to design different 5 basic heuristics for the psp problem.

## Heuristic Requirements:
1. **Constructive Nature**: Each heuristic must be constructive (or constructive followed by improvement), and build solutions step-by-step from scratch.

2. **Diversity**: The 5 heuristics should represent different strategies to ensure diversity in solution approaches.

The problem will work on following data.
Please try to understand the data and generate based on them, especially setting the default value for hyper-parameters:
All data is possible

The response format is very important. For better communication, please respond to me in this format:
***heuristic:
heuristic_name: only text description
heuristic_name: only text description
....
***
Ensure there is no other content (including blank lines) inside the ***, and analysis outside *** is welcome.
If you have no information to provide, simply respond with ***None***.
------------------------------------------------------------------------------------

assistant
***heuristic:
Earliest Arrival First (EAF): Sort unassigned vessels by increasing ETA; for each vessel in order, use find_feasible_assignments to select the earliest available assignment within its time window, preferring the compatible berth with highest remaining capacity; apply CompleteVesselAssignmentOperator to add the assignment if feasible, tracking total cost.
Largest Vessel First (LVF): Prioritize unassigned vessels by decreasing vessel size (S_i); for each, identify compatible berths via get_compatible_berths, then use find_tugboat_combination for inbound/outbound at the median of the vessel's time window; assign to the berth with lowest current utilization using is_berth_available, applying the operator only if all resources (tugboats via is_tugboat_available) are free.
Cost-Minimizing Greedy (CMG): Iterate over unassigned vessels in random order; for each, generate up to 5 candidate assignments via find_feasible_assignments, compute costs with calculate_assignment_cost, and select the one with minimal marginal cost increase to total_scheduling_cost; apply CompleteVesselAssignmentOperator for the best, updating solution statistics.
Randomized Sequential (RS): Randomly permute all vessel IDs; sequentially attempt assignments starting from an empty solution; for each vessel, sample 3 random start times within get_vessel_time_window, check berth/tugboat availability, and use find_tugboat_combination; apply operator for the first feasible option found, defaulting to unassign if none.
Utilization-Balanced (UB): Sort vessels by decreasing priority weight (α_i); for each, select the compatible berth with the lowest current utilization (from berth_utilization stat); center the start time on ETA, adjust by up to avg_time_window_flex to fit availability; find tugboat combos minimizing tug_utilization impact, apply operator if validation_solution passes post-assignment.
***

These heuristics are designed to be constructive, starting from an empty solution (all vessels unassigned) and iteratively building by applying CompleteVesselAssignmentOperator (or UnassignVesselOperator implicitly for failures). Diversity comes from prioritization (ETA, size, cost, random, priority/utilization), selection criteria (earliest, median/random, cost-min, balanced), and use of helpers like find_feasible_assignments for feasibility. Default hyperparameters: max_results=3 in find_feasible_assignments, up to 5 candidates in CMG, sample size=3 in RS; all leverage instance stats (e.g., avg_time_window_flex=mean(Δ^early_i + Δ^late_i)) for robustness. An improvement phase could follow each by re-running on unassigned vessels, but kept basic as per requirements. For implementation, TargetOperatorType would be CompleteVesselAssignmentOperator or UnassignVesselOperator, with algorithm_data updated to include iteration count or partial costs.
------------------------------------------------------------------------------------

user
Based on previous discuss, we get the heuristic Largest Vessel First (LVF):
 Prioritize unassigned vessels by decreasing vessel size (S_i); for each, identify compatible berths via get_compatible_berths, then use find_tugboat_combination for inbound/outbound at the median of the vessel's time window; assign to the berth with lowest current utilization using is_berth_available, applying the operator only if all resources (tugboats via is_tugboat_available) are free..

Now please implement it in python function largest_vessel_first_lvf_5e04.

To implement this heuristic function in python, please note:
1. We can assume that Solution and all Operators are imported.
2. The operator type must be defined previously, do not create a new one in your code.
3. Never modify the data in problem_state.
4. All hyper parameters in kwargs should be set a default value.
5. Any reasonable partial solution may be used as input, such as an empty solution.
6. Comments in the code are very important. They must clearly explain which hyper-parameters are required by the algorithm (i.e., the parameters in **kwargs), how the algorithm proceeds, and under what circumstances it will not return any operator or will return an empty operator. We hope that people can understand the principles and workflow of the algorithm clearly just by reading the comments, without needing to look at the code.
7. The name of function must be largest_vessel_first_lvf_5e04. The TargetOperatorType should be replaced by real returned operator type.
8. No any omissions or placeholders, I'm just going to use the code.
9. For the algorithm to update the algorithm_data, do not modify directly "algorithm_data["abc"] = 123", we should return operator, {"abc": 123}.For algorithm that do not update them, just return operator, {}
10. For the circumstances that algorithm return empty operator, please return None, {}.
11. Do not forget to check whether the content is empty when calculating the min/max/average/std/..., such as when using min([distance[node][other] for other in nodes if other != node]).
12. Make the result must be valid.
13. Do not forget the input problem_state:
problem_state (dict): A dictionary containing the problem state information, organized into five categories of keys:
1. Input Data:
    - vessel_num (int): The total number of vessels requesting berthing service.
    - berth_num (int): The total number of berths available at the port.
    - tugboat_num (int): The total number of tugboats available for service.
    - time_periods (int): The total number of time periods in the scheduling horizon.
    - vessel_sizes (numpy.ndarray): 1D array of size levels for each vessel (Si).
    - berth_capacities (numpy.ndarray): 1D array of capacity levels for each berth (Cj).
    - vessel_etas (numpy.ndarray): 1D array of expected arrival times for each vessel (ETAi).
    - vessel_durations (numpy.ndarray): 1D array of berthing durations required by each vessel (Di).
    - vessel_inbound_service_times (numpy.ndarray): 1D array of inbound tugboat service durations for each vessel.
    - vessel_outbound_service_times (numpy.ndarray): 1D array of outbound tugboat service durations for each vessel.
    - vessel_priority_weights (numpy.ndarray): 1D array of priority weights for each vessel.
    - vessel_waiting_costs (numpy.ndarray): 1D array of unit waiting costs for each vessel.
    - vessel_jit_costs (numpy.ndarray): 1D array of JIT deviation unit costs for each vessel.
    - vessel_horsepower_requirements (numpy.ndarray): 1D array of minimum tugboat horsepower required by each vessel.
    - vessel_early_limits (numpy.ndarray): 1D array of maximum early arrival allowances for each vessel.
    - vessel_late_limits (numpy.ndarray): 1D array of maximum late arrival allowances for each vessel.
    - tugboat_horsepower (numpy.ndarray): 1D array of horsepower for each tugboat.
    - tugboat_costs (numpy.ndarray): 1D array of unit time usage costs for each tugboat.
    - inbound_preparation_time (int): Preparation time for tugboats after completing inbound service (rho_in).
    - outbound_preparation_time (int): Preparation time for tugboats after completing outbound service (rho_out).
    - max_tugboats_per_service (int): Maximum number of tugboats allowed for a single service (Hmax).
    - time_constraint_tolerance (float): Maximum allowed time deviation in timing constraints (epsilon_time).
    - penalty_parameter (float): Large penalty parameter for unserved vessels.
    - objective_weights (numpy.ndarray): 1D array of four weighting coefficients [lambda_1, lambda_2, lambda_3, lambda_4] for objective function components.
2. Current Solution:
    - current_solution (Solution): Current solution instance.
    - total_scheduling_cost (float): The total scheduling cost of the current solution.
3. Helper Functions (these Functions may help you to generation the following heuristic):
    - get_problem_state (callable): def get_problem_state(solution: Solution) -> dict: The function to get the complete problem state for given solution without modifying it. Returns a dictionary containing state information.
    - validation_solution (callable): def validation_solution(solution: Solution = None) -> bool: The function to check whether the solution is valid according to all mathematical model constraints. If solution is None, checks current solution. Returns True if valid, False otherwise.
    - get_unassigned_vessels (callable): def get_unassigned_vessels(solution: Solution = None) -> list[int]: Get list of vessel IDs that have not been assigned to any berth. If solution is None, uses current solution. Returns list of integers representing unassigned vessel IDs (range 0 to vessel_num-1).
    - get_vessel_time_window (callable): def get_vessel_time_window(vessel_id: int) -> tuple[int, int]: Get the feasible time window (earliest_start, latest_start) for vessel's inbound service considering ETA and early/late limits. Returns tuple of two integers representing the valid start time range.
    - get_compatible_berths (callable): def get_compatible_berths(vessel_id: int) -> list[int]: Get list of berth IDs that can serve the vessel based on capacity level compatibility (berth_capacity >= vessel_size). Returns list of integers representing compatible berth IDs (range 0 to berth_num-1).
    - is_berth_available (callable): def is_berth_available(berth_id: int, start_time: int, duration: int, solution: Solution = None) -> bool: Check if a berth is free during the specified time period [start_time, start_time + duration) without conflicts with existing assignments. If solution is None, uses current solution. Returns True if available, False if conflicted.
    - is_tugboat_available (callable): def is_tugboat_available(tugboat_id: int, start_time: int, duration: int, prep_time: int = 0, solution: Solution = None) -> bool: Check if a tugboat is free during the specified service period [start_time, start_time + duration + prep_time) including preparation time. If solution is None, uses current solution. Returns True if available, False if conflicted.
    - find_tugboat_combination (callable): def find_tugboat_combination(vessel_id: int, start_time: int, service_type: str, solution: Solution = None) -> tuple: Find a tugboat combination with sufficient horsepower for the service using greedy selection. The service_type parameter accepts 'inbound' or 'outbound'. Uses greedy strategy sorting tugboats by horsepower descending to minimize the number of tugboats needed. If greedy fails, performs exhaustive search to find any valid combination. Returns (selected_tugboats, total_cost) where selected_tugboats is a list of (tugboat_id, start_time) tuples, or (None, 0) if no valid combination found that meets horsepower requirements within tugboat quantity limits.
    - find_feasible_assignments (callable): def find_feasible_assignments(vessel_id: int, max_results: int = 3, solution: Solution = None) -> list[dict]: Find a feasible complete assignment (berth + multi-tugboat services) for a vessel using ETA-centered heuristic search. Tries candidate inbound times near ETA (ETA ± {0,1,2,3,4}) in order of proximity to ETA. Uses tight scheduling with berth starting immediately after inbound service and outbound starting immediately after berthing. Returns immediately upon finding the first valid assignment. Returns list containing at most one dictionary with: {'berth_id': int, 'start_time': int, 'inbound_tugboats': list[tuple[int, int]], 'outbound_tugboats': list[tuple[int, int]], 'total_cost': float}. The tugboat lists contain multiple tuples of (tugboat_id, start_time) representing tugboat combinations that meet horsepower requirements. All timing constraints and horsepower constraints are properly handled. Returns empty list if no feasible assignment found.
    - calculate_assignment_cost (callable): def calculate_assignment_cost(vessel_id: int, berth_id: int, start_time: int, inbound_tugboats: list, outbound_tugboats: list) -> float: Calculate the total cost for a specific vessel assignment including port time cost (Z2), ETA deviation cost (Z3), and tugboat utilization cost (Z4). The inbound_tugboats and outbound_tugboats parameters are lists of (tugboat_id, start_time) tuples representing multi-tugboat combinations. Returns float representing the assignment cost, or float('inf') if assignment is invalid.
4. Instance Statistics (these Instance Statistics may help you to generation the following heuristic):
   - num_vessels (int): Number of vessels.
    - num_berths (int): Number of berths.
    - num_tugboats (int): Number of tugboats.
    - avg_vessel_size (float): Average vessel size.
    - var_vessel_size (float): Variance of vessel sizes.
    - total_required_hp (float): Total required horsepower for all vessels.
    - total_available_hp (float): Total available horsepower from all tugboats.
    - eta_span (float): Span between maximum and minimum ETA.
    - avg_berthing_duration (float): Average berthing duration.
    - vessel_arrival_density (float): Density of vessel arrivals (num_vessels / eta_span).
    - avg_time_window_flex (float): Average flexibility in time windows (mean of early + late limits).
    - berth_capacity_ratio (float): Ratio of average berth capacity to average vessel size.
5. Current Solution Statistics (these Solution Statistics may help you to generation the following heuristic):
    - assigned_vessels_fraction (float): Fraction of vessels with full service assignments (inbound, berthing, outbound).
    - partial_objective_value (float): Partial objective value computed as weighted sum of Z1 to Z4 for the current assignments.
    - unassigned_vessels (int): Number of vessels without full service assignments.
    - berth_utilization (float): Utilization of berths based on assigned berthing durations.
    - tug_utilization (float): Utilization of tugboats based on assigned service durations.
    - avg_eta_deviation_assigned (float): Average ETA deviation for vessels with full assignments.
    - remaining_hp_demand (float): Total horsepower requirement for unassigned vessels.
    - schedule_progress (float): Progress as the maximum end time of assigned services normalized by time periods.
    - full_service_completion_rate (float): Fraction of vessels with full and valid service assignments (no local violations).
    - potential_conflict_ratio (float): Ratio of full assignments that have local violations.

For psp problem, take about following:
1. Consider partial solution as input where some vessels may be unassigned.
2. When calculating costs, consider all four components: unserved vessel penalties, port time costs, ETA deviation costs, and tugboat utilization costs.
3. Make the result must be valid. 

The problem will work on following data.
Please try to understand the data and generate based on them, especially setting the default value for hyper-parameters:
All data is possible

The response format is very important. For better communication, please respond to me in this format:
***python_code:
from src.problems.psp.components import *
import other_library (if necessary)
def largest_vessel_first_lvf_5e04(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[TargetOperatorType, dict]:
    """ Description for this heuristic algorithm.

    Args:
        problem_state (dict): The dictionary contains the problem state.. In this algorithm, the following items are necessary:
            - necessary_key (value type): description
            - necessary_key (value type): description
            ...
        (Optional and can be omitted if no algorithm data) algorithm_data (dict): The algorithm dictionary for current algorithm only. In this algorithm, the following items are necessary:
            - necessary_key (value type): description
            - necessary_key (value type): description
            ...
        (Optional and can be omitted if no hyper parameters data) introduction for hyper parameters in kwargs if used.

    Returns:
        Description of this operator.
        Description of updated algorithm data.

        ...
    """
Ensure there is no other content inside the ***, ,and analysis outside *** is welcome.
If you have no information to provide, simply respond with ***None***.

------------------------------------------------------------------------------------

assistant
***python_code:
from src.problems.psp.components import *
import numpy as np

def largest_vessel_first_lvf_5e04(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[CompleteVesselAssignmentOperator, dict]:
    """Implements the Largest Vessel First (LVF) heuristic for the Port Scheduling Problem (PSP). This constructive heuristic builds upon a partial solution by prioritizing the largest unassigned vessel (by vessel size S_i) and attempting to assign it to a compatible berth with the lowest current utilization. The assignment uses tight scheduling centered on the median of the vessel's inbound time window, with inbound tugboat service starting at the median time, berthing immediately after inbound completion, and outbound tugboat service immediately after berthing completion. Tugboat combinations are found using greedy selection, and availability is verified for berths and all selected tugboats. If a feasible assignment is found for the prioritized vessel, a CompleteVesselAssignmentOperator is returned to apply the assignment; otherwise, None is returned if no unassigned vessels remain or no feasible assignment exists for the largest unassigned vessel. This allows iterative application in a hyper-heuristic framework to build the solution step-by-step. The result ensures validity by checking resource availabilities and compatibility before returning the operator.

    Hyper-parameters:
        - max_berth_tries (int, default=10): Limits the number of compatible berths to try in order of increasing utilization (all if fewer available). Set to a low value for efficiency in large instances.
        - utilization_threshold (float, default=0.8): Skips berths with current utilization above this threshold to prefer less loaded ones. Set to 1.0 to disable.

    Args:
        problem_state (dict): The dictionary contains the problem state. In this algorithm, the following items are necessary:
            - 'current_solution' (Solution): The current partial solution to build upon.
            - 'vessel_sizes' (numpy.ndarray): 1D array of vessel sizes for prioritization.
            - 'vessel_durations' (numpy.ndarray): 1D array of berthing durations.
            - 'vessel_inbound_service_times' (numpy.ndarray): 1D array of inbound service durations.
            - 'vessel_outbound_service_times' (numpy.ndarray): 1D array of outbound service durations.
            - 'vessel_horsepower_requirements' (numpy.ndarray): 1D array of required horsepower per vessel.
            - 'berth_capacities' (numpy.ndarray): 1D array of berth capacities for compatibility.
            - 'vessel_etas' (numpy.ndarray): 1D array of ETAs (used indirectly via time windows).
            - 'vessel_early_limits' (numpy.ndarray): 1D array of early limits (used in time windows).
            - 'vessel_late_limits' (numpy.ndarray): 1D array of late limits (used in time windows).
            - 'tugboat_horsepower' (numpy.ndarray): 1D array of tugboat horsepowers.
            - 'inbound_preparation_time' (int): Preparation time after inbound service.
            - 'outbound_preparation_time' (int): Preparation time after outbound service.
            - 'time_periods' (int): Total time horizon for utilization calculation.
            - 'get_unassigned_vessels' (callable): Returns list of unassigned vessel IDs.
            - 'get_vessel_time_window' (callable): Returns (earliest, latest) inbound start times.
            - 'get_compatible_berths' (callable): Returns list of compatible berth IDs.
            - 'is_berth_available' (callable): Checks berth availability for [start, start + duration).
            - 'is_tugboat_available' (callable): Checks tugboat availability including prep time.
            - 'find_tugboat_combination' (callable): Finds tugboat list for service at start time.
        algorithm_data (dict): Not used in this algorithm; can be empty.
        **kwargs: Optional hyper-parameters as described above.

    Returns:
        CompleteVesselAssignmentOperator or None: The operator to assign the largest unassigned vessel if feasible, including berth, berthing start time, and tugboat lists for inbound/outbound; None if no unassigned vessels or no feasible assignment found.
        dict: Empty dictionary as no algorithm data is updated.
    """
    # Extract necessary data from problem_state (do not modify)
    current_solution = problem_state['current_solution']
    vessel_sizes = problem_state['vessel_sizes']
    vessel_durations = problem_state['vessel_durations']
    vessel_inbound_service_times = problem_state['vessel_inbound_service_times']
    vessel_outbound_service_times = problem_state['vessel_outbound_service_times']
    vessel_horsepower_requirements = problem_state['vessel_horsepower_requirements']
    berth_capacities = problem_state['berth_capacities']
    inbound_prep_time = problem_state['inbound_preparation_time']
    outbound_prep_time = problem_state['outbound_preparation_time']
    time_periods = problem_state['time_periods']
    get_unassigned_vessels = problem_state['get_unassigned_vessels']
    get_vessel_time_window = problem_state['get_vessel_time_window']
    get_compatible_berths = problem_state['get_compatible_berths']
    is_berth_available = problem_state['is_berth_available']
    is_tugboat_available = problem_state['is_tugboat_available']
    find_tugboat_combination = problem_state['find_tugboat_combination']

    # Hyper-parameters with defaults
    max_berth_tries = kwargs.get('max_berth_tries', 10)
    utilization_threshold = kwargs.get('utilization_threshold', 0.8)

    # Step 1: Get list of unassigned vessels
    unassigned_vessels = get_unassigned_vessels(current_solution)
    if not unassigned_vessels:
        # No unassigned vessels; solution is complete, return no operator
        return None, {}

    # Step 2: Prioritize by decreasing vessel size; select the largest unassigned vessel
    # Sort indices by vessel_sizes descending
    sorted_unassigned = sorted(unassigned_vessels, key=lambda vid: vessel_sizes[vid], reverse=True)
    vessel_id = sorted_unassigned[0]  # Largest first

    # Step 3: Get time window for inbound service
    earliest_inbound, latest_inbound = get_vessel_time_window(vessel_id)
    if earliest_inbound > latest_inbound:
        # Invalid time window; cannot assign this vessel
        return None, {}

    # Compute median inbound start time
    median_inbound_start = (earliest_inbound + latest_inbound) // 2

    # Compute tight schedule times
    tau_in = vessel_inbound_service_times[vessel_id]
    D = vessel_durations[vessel_id]
    tau_out = vessel_outbound_service_times[vessel_id]
    berthing_start = median_inbound_start + tau_in
    outbound_start = berthing_start + D

    # Check if schedule fits within time horizon (basic sanity check)
    if outbound_start + tau_out > time_periods:
        # Schedule overruns; try shifting earlier if possible, but for simplicity, skip this vessel
        return None, {}

    # Step 4: Compute current berth utilizations for sorting
    # Initialize utilization array
    berth_util = np.zeros(len(berth_capacities))
    for vid, (bid, bstart) in current_solution.vessel_assignments.items():
        if bid is not None:
            berth_util[bid] += vessel_durations[vid]
    # Utilization as fraction of time periods
    current_utilizations = berth_util / time_periods if time_periods > 0 else np.zeros_like(berth_util)

    # Step 5: Get compatible berths and sort by increasing utilization (lowest first)
    compatible_berths = get_compatible_berths(vessel_id)
    # Filter by utilization threshold
    compatible_berths = [b for b in compatible_berths if current_utilizations[b] <= utilization_threshold]
    if not compatible_berths:
        return None, {}
    # Sort by increasing utilization
    compatible_berths.sort(key=lambda b: current_utilizations[b])
    # Limit tries
    compatible_berths = compatible_berths[:max_berth_tries]

    # Step 6: For each compatible berth in order, try to find feasible tugboat combinations and check availabilities
    for berth_id in compatible_berths:
        # Check berth availability for berthing period
        if not is_berth_available(berth_id, berthing_start, D, current_solution):
            continue

        # Find inbound tugboat combination at median_inbound_start
        inbound_result = find_tugboat_combination(vessel_id, median_inbound_start, 'inbound', current_solution)
        inbound_tugboats, _ = inbound_result
        if inbound_tugboats is None:
            continue

        # Check availability for all inbound tugboats
        inbound_duration = tau_in
        inbound_available = all(
            is_tugboat_available(tug_id, median_inbound_start, inbound_duration, inbound_prep_time, current_solution)
            for tug_id, _ in inbound_tugboats
        )
        if not inbound_available:
            continue

        # Find outbound tugboat combination at outbound_start
        outbound_result = find_tugboat_combination(vessel_id, outbound_start, 'outbound', current_solution)
        outbound_tugboats, _ = outbound_result
        if outbound_tugboats is None:
            continue

        # Check availability for all outbound tugboats
        outbound_duration = tau_out
        outbound_available = all(
            is_tugboat_available(tug_id, outbound_start, outbound_duration, outbound_prep_time, current_solution)
            for tug_id, _ in outbound_tugboats
        )
        if not outbound_available:
            continue

        # All checks passed: feasible assignment found
        # Create operator with berthing start, and tugboat lists (all start times are set)
        operator = CompleteVesselAssignmentOperator(
            vessel_id=vessel_id,
            berth_id=berth_id,
            start_time=berthing_start,  # Berthing start time
            inbound_tugboats=inbound_tugboats,  # List of (tug_id, start_time)
            outbound_tugboats=outbound_tugboats  # List of (tug_id, start_time)
        )
        # The operator ensures same start times for multi-tugboats as per its run logic
        return operator, {}

    # No feasible assignment found after trying berths
    return None, {}
***

The implementation follows the LVF description precisely while ensuring constructiveness on partial solutions. It computes per-berth utilization from the current_solution's assignments for accurate sorting (total occupied time / time_periods). Tight scheduling minimizes deviations, and all checks (availability, combinations) guarantee the returned operator produces a valid extension (no local violations; global validation can be done post-application via validation_solution). Hyper-parameters are optional with sensible defaults for efficiency. If unassigned vessels exist but the largest cannot be assigned (e.g., due to resource constraints), it returns None to allow other heuristics to proceed, preventing stalls. No algorithm_data updates are needed, as the heuristic is stateless beyond the solution. Costs are implicitly considered via feasibility (unserved penalties avoided when possible), but explicit cost calculation is omitted here since the focus is assignment; calculate_assignment_cost could be added post-assignment if needed. The code handles empty lists/arrays safely (e.g., no min/max on empty).
------------------------------------------------------------------------------------

user
To verify whether the code is correct, we conducted a smoke test.
This is the test data:
num_vessels:100
num_berths:15
num_tugboats:30
avg_vessel_size:3.58
var_vessel_size:1.16
total_required_hp:346107
total_available_hp:80275
eta_span:15
avg_berthing_duration:2.25
vessel_arrival_density:6.67
avg_time_window_flex:3.7
berth_capacity_ratio:1.01

While executing largest_vessel_first_lvf_5e04 with the given dataset, the program encountered an error and crashed. The following error message was displayed:
Traceback (most recent call last):
  File "C:\Users\gongh\HeurAgenix-tsp\HeurAgenix-main\src\problems\base\env.py", line 104, in run_heuristic
    operator, delta = heuristic(
                      ^^^^^^^^^^
  File "<string>", line 97, in largest_vessel_first_lvf_5e04
TypeError: cannot unpack non-iterable NoneType object


Please try to fix it.

The response format is very important. For better communication, please respond to me in this format:
1. If you think this heuristic can not be implemented, respond to me ***python_code:None*** and we will stop this generation.
2. If you can fix up this issues, please respond to me in this format:
***python_code:
from src.problems.psp.components import *
import other_library (if necessary)
def largest_vessel_first_lvf_5e04(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[TargetOperatorType, dict]:
    """ Description for this heuristic algorithm.

    Args:
        problem_state (dict): The dictionary contains the problem state.. In this algorithm, the following items are necessary:
            - necessary_key (value type): description
            - necessary_key (value type): description
            ...
        (Optional and can be omitted if no algorithm data) algorithm_data (dict): The algorithm dictionary for current algorithm only. In this algorithm, the following items are necessary:
            - necessary_key (value type): description
            - necessary_key (value type): description
            ...
        (Optional and can be omitted if no hyper parameters data) introduction for hyper parameters in kwargs if used.

    Returns:
        Description of this operator.
        Description of updated algorithm data.

        ...
    """
Ensure there is no other content inside the ***, and analysis outside *** is welcome.
If you have no information to provide, simply respond with ***None***.

------------------------------------------------------------------------------------

assistant
***python_code:
from src.problems.psp.components import *
import numpy as np

def largest_vessel_first_lvf_5e04(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[CompleteVesselAssignmentOperator, dict]:
    """Implements the Largest Vessel First (LVF) heuristic for the Port Scheduling Problem (PSP). This constructive heuristic builds upon a partial solution by prioritizing the largest unassigned vessel (by vessel size S_i) and attempting to assign it to a compatible berth with the lowest current utilization. The assignment uses tight scheduling centered on the median of the vessel's inbound time window, with inbound tugboat service starting at the median time, berthing immediately after inbound completion, and outbound tugboat service immediately after berthing completion. Tugboat combinations are found using greedy selection, and availability is verified for berths and all selected tugboats. If a feasible assignment is found for the prioritized vessel, a CompleteVesselAssignmentOperator is returned to apply the assignment; otherwise, None is returned if no unassigned vessels remain or no feasible assignment exists for the largest unassigned vessel. This allows iterative application in a hyper-heuristic framework to build the solution step-by-step. The result ensures validity by checking resource availabilities and compatibility before returning the operator.

    Hyper-parameters:
        - max_berth_tries (int, default=10): Limits the number of compatible berths to try in order of increasing utilization (all if fewer available). Set to a low value for efficiency in large instances.
        - utilization_threshold (float, default=0.8): Skips berths with current utilization above this threshold to prefer less loaded ones. Set to 1.0 to disable.

    Args:
        problem_state (dict): The dictionary contains the problem state. In this algorithm, the following items are necessary:
            - 'current_solution' (Solution): The current partial solution to build upon.
            - 'vessel_sizes' (numpy.ndarray): 1D array of vessel sizes for prioritization.
            - 'vessel_durations' (numpy.ndarray): 1D array of berthing durations.
            - 'vessel_inbound_service_times' (numpy.ndarray): 1D array of inbound service durations.
            - 'vessel_outbound_service_times' (numpy.ndarray): 1D array of outbound service durations.
            - 'vessel_horsepower_requirements' (numpy.ndarray): 1D array of required horsepower per vessel.
            - 'berth_capacities' (numpy.ndarray): 1D array of berth capacities for compatibility.
            - 'vessel_etas' (numpy.ndarray): 1D array of ETAs (used indirectly via time windows).
            - 'vessel_early_limits' (numpy.ndarray): 1D array of early limits (used in time windows).
            - 'vessel_late_limits' (numpy.ndarray): 1D array of late limits (used in time windows).
            - 'tugboat_horsepower' (numpy.ndarray): 1D array of tugboat horsepowers.
            - 'inbound_preparation_time' (int): Preparation time after inbound service.
            - 'outbound_preparation_time' (int): Preparation time after outbound service.
            - 'time_periods' (int): Total time horizon for utilization calculation.
            - 'get_unassigned_vessels' (callable): Returns list of unassigned vessel IDs.
            - 'get_vessel_time_window' (callable): Returns (earliest, latest) inbound start times.
            - 'get_compatible_berths' (callable): Returns list of compatible berth IDs.
            - 'is_berth_available' (callable): Checks berth availability for [start, start + duration).
            - 'is_tugboat_available' (callable): Checks tugboat availability including prep time.
            - 'find_tugboat_combination' (callable): Finds tugboat list for service at start time.
        algorithm_data (dict): Not used in this algorithm; can be empty.
        **kwargs: Optional hyper-parameters as described above.

    Returns:
        CompleteVesselAssignmentOperator or None: The operator to assign the largest unassigned vessel if feasible, including berth, berthing start time, and tugboat lists for inbound/outbound; None if no unassigned vessels or no feasible assignment found.
        dict: Empty dictionary as no algorithm data is updated.
    """
    # Extract necessary data from problem_state (do not modify)
    current_solution = problem_state['current_solution']
    vessel_sizes = problem_state['vessel_sizes']
    vessel_durations = problem_state['vessel_durations']
    vessel_inbound_service_times = problem_state['vessel_inbound_service_times']
    vessel_outbound_service_times = problem_state['vessel_outbound_service_times']
    vessel_horsepower_requirements = problem_state['vessel_horsepower_requirements']
    berth_capacities = problem_state['berth_capacities']
    inbound_prep_time = problem_state['inbound_preparation_time']
    outbound_prep_time = problem_state['outbound_preparation_time']
    time_periods = problem_state['time_periods']
    get_unassigned_vessels = problem_state['get_unassigned_vessels']
    get_vessel_time_window = problem_state['get_vessel_time_window']
    get_compatible_berths = problem_state['get_compatible_berths']
    is_berth_available = problem_state['is_berth_available']
    is_tugboat_available = problem_state['is_tugboat_available']
    find_tugboat_combination = problem_state['find_tugboat_combination']

    # Hyper-parameters with defaults
    max_berth_tries = kwargs.get('max_berth_tries', 10)
    utilization_threshold = kwargs.get('utilization_threshold', 0.8)

    # Step 1: Get list of unassigned vessels
    unassigned_vessels = get_unassigned_vessels(current_solution)
    if not unassigned_vessels:
        # No unassigned vessels; solution is complete, return no operator
        return None, {}

    # Step 2: Prioritize by decreasing vessel size; select the largest unassigned vessel
    # Sort indices by vessel_sizes descending
    sorted_unassigned = sorted(unassigned_vessels, key=lambda vid: vessel_sizes[vid], reverse=True)
    vessel_id = sorted_unassigned[0]  # Largest first

    # Step 3: Get time window for inbound service
    earliest_inbound, latest_inbound = get_vessel_time_window(vessel_id)
    if earliest_inbound > latest_inbound:
        # Invalid time window; cannot assign this vessel
        return None, {}

    # Compute median inbound start time
    median_inbound_start = (earliest_inbound + latest_inbound) // 2

    # Compute tight schedule times
    tau_in = vessel_inbound_service_times[vessel_id]
    D = vessel_durations[vessel_id]
    tau_out = vessel_outbound_service_times[vessel_id]
    berthing_start = median_inbound_start + tau_in
    outbound_start = berthing_start + D

    # Check if schedule fits within time horizon (basic sanity check)
    if outbound_start + tau_out > time_periods:
        # Schedule overruns; try shifting earlier if possible, but for simplicity, skip this vessel
        return None, {}

    # Step 4: Compute current berth utilizations for sorting
    # Initialize utilization array
    berth_util = np.zeros(len(berth_capacities))
    for vid, assignment in current_solution.vessel_assignments.items():
        if assignment is not None:
            bid, _ = assignment
            berth_util[bid] += vessel_durations[vid]
    # Utilization as fraction of time periods
    current_utilizations = berth_util / time_periods if time_periods > 0 else np.zeros_like(berth_util)

    # Step 5: Get compatible berths and sort by increasing utilization (lowest first)
    compatible_berths = get_compatible_berths(vessel_id)
    # Filter by utilization threshold
    compatible_berths = [b for b in compatible_berths if current_utilizations[b] <= utilization_threshold]
    if not compatible_berths:
        return None, {}
    # Sort by increasing utilization
    compatible_berths.sort(key=lambda b: current_utilizations[b])
    # Limit tries
    compatible_berths = compatible_berths[:max_berth_tries]

    # Step 6: For each compatible berth in order, try to find feasible tugboat combinations and check availabilities
    for berth_id in compatible_berths:
        # Check berth availability for berthing period
        if not is_berth_available(berth_id, berthing_start, D, current_solution):
            continue

        # Find inbound tugboat combination at median_inbound_start
        inbound_result = find_tugboat_combination(vessel_id, median_inbound_start, 'inbound', current_solution)
        # Safely handle potential None return or invalid tuple from find_tugboat_combination
        if not isinstance(inbound_result, tuple) or len(inbound_result) != 2 or inbound_result[0] is None:
            continue
        inbound_tugboats = inbound_result[0]

        # Check availability for all inbound tugboats
        inbound_duration = tau_in
        inbound_available = all(
            is_tugboat_available(tug_id, median_inbound_start, inbound_duration, inbound_prep_time, current_solution)
            for tug_id, _ in inbound_tugboats
        )
        if not inbound_available:
            continue

        # Find outbound tugboat combination at outbound_start
        outbound_result = find_tugboat_combination(vessel_id, outbound_start, 'outbound', current_solution)
        # Safely handle potential None return or invalid tuple from find_tugboat_combination
        if not isinstance(outbound_result, tuple) or len(outbound_result) != 2 or outbound_result[0] is None:
            continue
        outbound_tugboats = outbound_result[0]

        # Check availability for all outbound tugboats
        outbound_duration = tau_out
        outbound_available = all(
            is_tugboat_available(tug_id, outbound_start, outbound_duration, outbound_prep_time, current_solution)
            for tug_id, _ in outbound_tugboats
        )
        if not outbound_available:
            continue

        # All checks passed: feasible assignment found
        # Create operator with berthing start, and tugboat lists (all start times are set)
        operator = CompleteVesselAssignmentOperator(
            vessel_id=vessel_id,
            berth_id=berth_id,
            start_time=berthing_start,  # Berthing start time
            inbound_tugboats=inbound_tugboats,  # List of (tug_id, start_time)
            outbound_tugboats=outbound_tugboats  # List of (tug_id, start_time)
        )
        # The operator ensures same start times for multi-tugboats as per its run logic
        return operator, {}

    # No feasible assignment found after trying berths
    return None, {}
***

The error was caused by attempting to unpack the result of `find_tugboat_combination`, which likely returns `None` in failure cases instead of the specified `(None, 0)` tuple, leading to a `TypeError` when unpacking `None`. To fix this, I added safe checks before unpacking: verify that the result is a tuple of length 2 and that the first element (tugboat list) is not `None`. If not, skip to the next berth. This handles potential implementation discrepancies in the helper function without altering its expected behavior.

Additionally, I fixed a minor issue in the utilization calculation loop: changed `for vid, (bid, bstart) in current_solution.vessel_assignments.items():` to `for vid, assignment in current_solution.vessel_assignments.items(): if assignment is not None: bid, _ = assignment`, as the description indicates `None` for unassigned vessels, ensuring no unpacking error if somehow an unassigned entry has `None`.

These changes prevent crashes during smoke tests with constrained resources (e.g., insufficient total HP), allowing the heuristic to gracefully skip infeasible cases and return `(None, {})` when no assignment is possible for the largest vessel. The code remains faithful to the LVF strategy and ensures partial solutions are extended validly when feasible.
------------------------------------------------------------------------------------

user
To verify whether the code is correct, we conducted a smoke test.
This is the test data:
num_vessels:100
num_berths:15
num_tugboats:30
avg_vessel_size:3.58
var_vessel_size:1.16
total_required_hp:346107
total_available_hp:80275
eta_span:15
avg_berthing_duration:2.25
vessel_arrival_density:6.67
avg_time_window_flex:3.7
berth_capacity_ratio:1.01

We run the following operations:
None

The current solution are
Port Scheduling Solution:
Vessel Assignments:
  Vessel 0: Unassigned
  Vessel 1: Unassigned
  Vessel 2: Unassigned
  Vessel 3: Unassigned
  Vessel 4: Unassigned
  Vessel 5: Unassigned
  Vessel 6: Unassigned
  Vessel 7: Unassigned
  Vessel 8: Unassigned
  Vessel 9: Unassigned
  Vessel 10: Unassigned
  Vessel 11: Unassigned
  Vessel 12: Unassigned
  Vessel 13: Unassigned
  Vessel 14: Unassigned
  Vessel 15: Unassigned
  Vessel 16: Unassigned
  Vessel 17: Unassigned
  Vessel 18: Unassigned
  Vessel 19: Unassigned
  Vessel 20: Unassigned
  Vessel 21: Unassigned
  Vessel 22: Unassigned
  Vessel 23: Unassigned
  Vessel 24: Unassigned
  Vessel 25: Unassigned
  Vessel 26: Unassigned
  Vessel 27: Unassigned
  Vessel 28: Unassigned
  Vessel 29: Unassigned
  Vessel 30: Unassigned
  Vessel 31: Unassigned
  Vessel 32: Unassigned
  Vessel 33: Unassigned
  Vessel 34: Unassigned
  Vessel 35: Unassigned
  Vessel 36: Unassigned
  Vessel 37: Unassigned
  Vessel 38: Unassigned
  Vessel 39: Unassigned
  Vessel 40: Unassigned
  Vessel 41: Unassigned
  Vessel 42: Unassigned
  Vessel 43: Unassigned
  Vessel 44: Unassigned
  Vessel 45: Unassigned
  Vessel 46: Unassigned
  Vessel 47: Unassigned
  Vessel 48: Unassigned
  Vessel 49: Unassigned
  Vessel 50: Unassigned
  Vessel 51: Unassigned
  Vessel 52: Unassigned
  Vessel 53: Unassigned
  Vessel 54: Unassigned
  Vessel 55: Unassigned
  Vessel 56: Unassigned
  Vessel 57: Unassigned
  Vessel 58: Unassigned
  Vessel 59: Unassigned
  Vessel 60: Unassigned
  Vessel 61: Unassigned
  Vessel 62: Unassigned
  Vessel 63: Unassigned
  Vessel 64: Unassigned
  Vessel 65: Unassigned
  Vessel 66: Unassigned
  Vessel 67: Unassigned
  Vessel 68: Unassigned
  Vessel 69: Unassigned
  Vessel 70: Unassigned
  Vessel 71: Unassigned
  Vessel 72: Unassigned
  Vessel 73: Unassigned
  Vessel 74: Unassigned
  Vessel 75: Unassigned
  Vessel 76: Unassigned
  Vessel 77: Unassigned
  Vessel 78: Unassigned
  Vessel 79: Unassigned
  Vessel 80: Unassigned
  Vessel 81: Unassigned
  Vessel 82: Unassigned
  Vessel 83: Unassigned
  Vessel 84: Unassigned
  Vessel 85: Unassigned
  Vessel 86: Unassigned
  Vessel 87: Unassigned
  Vessel 88: Unassigned
  Vessel 89: Unassigned
  Vessel 90: Unassigned
  Vessel 91: Unassigned
  Vessel 92: Unassigned
  Vessel 93: Unassigned
  Vessel 94: Unassigned
  Vessel 95: Unassigned
  Vessel 96: Unassigned
  Vessel 97: Unassigned
  Vessel 98: Unassigned
  Vessel 99: Unassigned
Inbound Tugboat Services:
Outbound Tugboat Services:

with related problem state
assigned_vessels_fraction:0.0
partial_objective_value:110130.77
unassigned_vessels:100
berth_utilization:0.0
tug_utilization:0.0
avg_eta_deviation_assigned:0.0
remaining_hp_demand:346107.0
schedule_progress:0.0
full_service_completion_rate:0.0
potential_conflict_ratio:0.0

Now we run largest_vessel_first_lvf_5e04 once and think about what the expected output is.

The response format is very important. For better communication, please respond to me in this format:
***expected_result:xxx***
Ensure there is no other content inside the ***, and analysis outside *** is welcome.
If you have no information to provide, simply respond with ***None***.
------------------------------------------------------------------------------------

assistant
***expected_result:CompleteVesselAssignmentOperator for the largest unassigned vessel (vessel with max S_i) to a compatible berth (the first in sorted order, since all utilizations are 0), with berthing start time computed as median inbound time + tau_in, and inbound/outbound tugboat combinations found via find_tugboat_combination at respective start times, provided all availability checks pass (which they should on empty solution unless the single vessel's HP req > total available or time window/schedule overruns); if no feasible (e.g., due to HP shortage for that vessel or invalid time window), returns None, {}.***

In an empty solution with all resources free, the heuristic should successfully assign the largest vessel unless its individual constraints (HP req > total available, invalid time window, or schedule exceeding time_periods) prevent it. Given the stats (total_available_hp=80275, but per-vessel HP not specified—assuming avg ~3461 per vessel, feasible for one), and short eta_span=15 with avg flex=3.7, it's likely to return an operator for vessel argmax(S_i), with tight scheduling around its ETA. The partial_objective_value=110130.77 suggests pre-computed unserved penalties (100 * penalty * avg alpha?), which would decrease post-assignment. If the test crashes or returns None unexpectedly, it indicates issues with helper functions (e.g., find_tugboat_combination failing on empty) or data (e.g., time_periods too small).
------------------------------------------------------------------------------------

user
In fact we run the largest_vessel_first_lvf_5e04 once, and now we got the output operation from largest_vessel_first_lvf_5e04:
CompleteVesselAssignmentOperator(vessel_id=3, berth_id=0, start_time=12, inbound_tugboats=[(8, 10), (28, 10)], outbound_tugboats=[(8, 14), (28, 14)])

The updated solution are
Port Scheduling Solution:
Vessel Assignments:
  Vessel 0: Unassigned
  Vessel 1: Unassigned
  Vessel 2: Unassigned
  Vessel 3: Berth 0, Start Time 12
  Vessel 4: Unassigned
  Vessel 5: Unassigned
  Vessel 6: Unassigned
  Vessel 7: Unassigned
  Vessel 8: Unassigned
  Vessel 9: Unassigned
  Vessel 10: Unassigned
  Vessel 11: Unassigned
  Vessel 12: Unassigned
  Vessel 13: Unassigned
  Vessel 14: Unassigned
  Vessel 15: Unassigned
  Vessel 16: Unassigned
  Vessel 17: Unassigned
  Vessel 18: Unassigned
  Vessel 19: Unassigned
  Vessel 20: Unassigned
  Vessel 21: Unassigned
  Vessel 22: Unassigned
  Vessel 23: Unassigned
  Vessel 24: Unassigned
  Vessel 25: Unassigned
  Vessel 26: Unassigned
  Vessel 27: Unassigned
  Vessel 28: Unassigned
  Vessel 29: Unassigned
  Vessel 30: Unassigned
  Vessel 31: Unassigned
  Vessel 32: Unassigned
  Vessel 33: Unassigned
  Vessel 34: Unassigned
  Vessel 35: Unassigned
  Vessel 36: Unassigned
  Vessel 37: Unassigned
  Vessel 38: Unassigned
  Vessel 39: Unassigned
  Vessel 40: Unassigned
  Vessel 41: Unassigned
  Vessel 42: Unassigned
  Vessel 43: Unassigned
  Vessel 44: Unassigned
  Vessel 45: Unassigned
  Vessel 46: Unassigned
  Vessel 47: Unassigned
  Vessel 48: Unassigned
  Vessel 49: Unassigned
  Vessel 50: Unassigned
  Vessel 51: Unassigned
  Vessel 52: Unassigned
  Vessel 53: Unassigned
  Vessel 54: Unassigned
  Vessel 55: Unassigned
  Vessel 56: Unassigned
  Vessel 57: Unassigned
  Vessel 58: Unassigned
  Vessel 59: Unassigned
  Vessel 60: Unassigned
  Vessel 61: Unassigned
  Vessel 62: Unassigned
  Vessel 63: Unassigned
  Vessel 64: Unassigned
  Vessel 65: Unassigned
  Vessel 66: Unassigned
  Vessel 67: Unassigned
  Vessel 68: Unassigned
  Vessel 69: Unassigned
  Vessel 70: Unassigned
  Vessel 71: Unassigned
  Vessel 72: Unassigned
  Vessel 73: Unassigned
  Vessel 74: Unassigned
  Vessel 75: Unassigned
  Vessel 76: Unassigned
  Vessel 77: Unassigned
  Vessel 78: Unassigned
  Vessel 79: Unassigned
  Vessel 80: Unassigned
  Vessel 81: Unassigned
  Vessel 82: Unassigned
  Vessel 83: Unassigned
  Vessel 84: Unassigned
  Vessel 85: Unassigned
  Vessel 86: Unassigned
  Vessel 87: Unassigned
  Vessel 88: Unassigned
  Vessel 89: Unassigned
  Vessel 90: Unassigned
  Vessel 91: Unassigned
  Vessel 92: Unassigned
  Vessel 93: Unassigned
  Vessel 94: Unassigned
  Vessel 95: Unassigned
  Vessel 96: Unassigned
  Vessel 97: Unassigned
  Vessel 98: Unassigned
  Vessel 99: Unassigned
Inbound Tugboat Services:
  Vessel 3: Tugboat 8 at time 10, Tugboat 28 at time 10
Outbound Tugboat Services:
  Vessel 3: Tugboat 8 at time 14, Tugboat 28 at time 14

with related problem state
assigned_vessels_fraction:0.01
partial_objective_value:109284.45
unassigned_vessels:99
berth_utilization:0.01
tug_utilization:0.01
avg_eta_deviation_assigned:0.0
remaining_hp_demand:340430.0
schedule_progress:0.67
full_service_completion_rate:0.01
potential_conflict_ratio:0.0

Please compare with your expected result: CompleteVesselAssignmentOperator for the largest unassigned vessel (vessel with max S_i) to a compatible berth (the first in sorted order, since all utilizations are 0), with berthing start time computed as median inbound time + tau_in, and inbound/outbound tugboat combinations found via find_tugboat_combination at respective start times, provided all availability checks pass (which they should on empty solution unless the single vessel's HP req > total available or time window/schedule overruns); if no feasible (e.g., due to HP shortage for that vessel or invalid time window), returns None, {}.
1. If the result is aligned with your target output, respond to me ***python_code:correct*** and we will save the code and finish this generation.
2. If the result is not aligned with your target output and you can not generate correct one, respond to me ***python_code:None*** and we will stop this generation.
3. If the result is not aligned with your target output and you can fix up this issues, please respond to me in this format:
***python_code:
from src.problems.psp.components import *
import other_library (if necessary)
def largest_vessel_first_lvf_5e04(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[TargetOperatorType, dict]:
    """ Description for this heuristic algorithm.

    Args:
        problem_state (dict): The dictionary contains the problem state.. In this algorithm, the following items are necessary:
            - necessary_key (value type): description
            - necessary_key (value type): description
            ...
        (Optional and can be omitted if no algorithm data) algorithm_data (dict): The algorithm dictionary for current algorithm only. In this algorithm, the following items are necessary:
            - necessary_key (value type): description
            - necessary_key (value type): description
            ...
        (Optional and can be omitted if no hyper parameters data) introduction for hyper parameters in kwargs if used.

    Returns:
        Description of this operator.
        Description of updated algorithm data.

        ...
    """
Ensure there is no other content inside the ***, and analysis outside *** is welcome.
If you have no information to provide, simply respond with ***None***.

------------------------------------------------------------------------------------

assistant
***python_code:correct***

The actual output aligns well with the expected result. Vessel 3 was selected as the largest unassigned vessel based on the instance's vessel_sizes array (where it has the maximum S_i value). The assignment to berth 0 (first in sorted compatible list, all utilizations=0) uses tight scheduling: inbound at median time=10, berthing at 12 (implying τ_in=2), outbound at 14 (implying D=2). Tugboat combinations with tugboats 8 and 28 (sufficient HP, same start times) passed availability checks on the empty solution. The updated stats reflect successful extension: one vessel assigned, objective improved by ~846 (removing one unserved penalty), utilizations ~0.01, remaining HP demand reduced by ~6677 (vessel 3's P_req). No issues detected; the code is correct and produces valid, expected behavior.
------------------------------------------------------------------------------------

user
To ensure the stable of heuristics, we adjust the code to:
from src.problems.psp.components import *
import numpy as np

def largest_vessel_first_lvf_5e04(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[CompleteVesselAssignmentOperator, dict]:
    """Implements the Largest Vessel First (LVF) heuristic for the Port Scheduling Problem (PSP). This constructive heuristic builds upon a partial solution by prioritizing the largest unassigned vessel (by vessel size S_i) and attempting to assign it to a compatible berth with the lowest current utilization. The assignment uses tight scheduling centered on the median of the vessel's inbound time window, with inbound tugboat service starting at the median time, berthing immediately after inbound completion, and outbound tugboat service immediately after berthing completion. Tugboat combinations are found using greedy selection, and availability is verified for berths and all selected tugboats. If a feasible assignment is found for the prioritized vessel, a CompleteVesselAssignmentOperator is returned to apply the assignment; otherwise, None is returned if no unassigned vessels remain or no feasible assignment exists for the largest unassigned vessel. This allows iterative application in a hyper-heuristic framework to build the solution step-by-step. The result ensures validity by checking resource availabilities and compatibility before returning the operator.

    Hyper-parameters:
        - max_berth_tries (int, default=10): Limits the number of compatible berths to try in order of increasing utilization (all if fewer available). Set to a low value for efficiency in large instances.
        - utilization_threshold (float, default=0.8): Skips berths with current utilization above this threshold to prefer less loaded ones. Set to 1.0 to disable.

    Args:
        problem_state (dict): The dictionary contains the problem state. In this algorithm, the following items are necessary:
            - 'current_solution' (Solution): The current partial solution to build upon.
            - 'vessel_sizes' (numpy.ndarray): 1D array of vessel sizes for prioritization.
            - 'vessel_durations' (numpy.ndarray): 1D array of berthing durations.
            - 'vessel_inbound_service_times' (numpy.ndarray): 1D array of inbound service durations.
            - 'vessel_outbound_service_times' (numpy.ndarray): 1D array of outbound service durations.
            - 'vessel_horsepower_requirements' (numpy.ndarray): 1D array of required horsepower per vessel.
            - 'berth_capacities' (numpy.ndarray): 1D array of berth capacities for compatibility.
            - 'vessel_etas' (numpy.ndarray): 1D array of ETAs (used indirectly via time windows).
            - 'vessel_early_limits' (numpy.ndarray): 1D array of early limits (used in time windows).
            - 'vessel_late_limits' (numpy.ndarray): 1D array of late limits (used in time windows).
            - 'tugboat_horsepower' (numpy.ndarray): 1D array of tugboat horsepowers.
            - 'inbound_preparation_time' (int): Preparation time after inbound service.
            - 'outbound_preparation_time' (int): Preparation time after outbound service.
            - 'time_periods' (int): Total time horizon for utilization calculation.
            - 'get_unassigned_vessels' (callable): Returns list of unassigned vessel IDs.
            - 'get_vessel_time_window' (callable): Returns (earliest, latest) inbound start times.
            - 'get_compatible_berths' (callable): Returns list of compatible berth IDs.
            - 'is_berth_available' (callable): Checks berth availability for [start, start + duration).
            - 'is_tugboat_available' (callable): Checks tugboat availability including prep time.
            - 'find_tugboat_combination' (callable): Finds tugboat list for service at start time.
        algorithm_data (dict): Not used in this algorithm; can be empty.
        **kwargs: Optional hyper-parameters as described above.

    Returns:
        CompleteVesselAssignmentOperator or None: The operator to assign the largest unassigned vessel if feasible, including berth, berthing start time, and tugboat lists for inbound/outbound; None if no unassigned vessels or no feasible assignment found.
        dict: Empty dictionary as no algorithm data is updated.
    """
    # Extract necessary data from problem_state (do not modify)
    current_solution = problem_state['current_solution']
    vessel_sizes = problem_state['vessel_sizes']
    vessel_durations = problem_state['vessel_durations']
    vessel_inbound_service_times = problem_state['vessel_inbound_service_times']
    vessel_outbound_service_times = problem_state['vessel_outbound_service_times']
    vessel_horsepower_requirements = problem_state['vessel_horsepower_requirements']
    berth_capacities = problem_state['berth_capacities']
    inbound_prep_time = problem_state['inbound_preparation_time']
    outbound_prep_time = problem_state['outbound_preparation_time']
    time_periods = problem_state['time_periods']
    get_unassigned_vessels = problem_state['get_unassigned_vessels']
    get_vessel_time_window = problem_state['get_vessel_time_window']
    get_compatible_berths = problem_state['get_compatible_berths']
    is_berth_available = problem_state['is_berth_available']
    is_tugboat_available = problem_state['is_tugboat_available']
    find_tugboat_combination = problem_state['find_tugboat_combination']

    # Hyper-parameters with defaults
    max_berth_tries = kwargs.get('max_berth_tries', 10)
    utilization_threshold = kwargs.get('utilization_threshold', 0.8)

    # Step 1: Get list of unassigned vessels
    unassigned_vessels = get_unassigned_vessels(current_solution)
    if not unassigned_vessels:
        # No unassigned vessels; solution is complete, return no operator
        return None, {}

    # Step 2: Prioritize by decreasing vessel size; select the largest unassigned vessel
    # Sort indices by vessel_sizes descending
    sorted_unassigned = sorted(unassigned_vessels, key=lambda vid: vessel_sizes[vid], reverse=True)
    vessel_id = sorted_unassigned[0]  # Largest first

    # Step 3: Get time window for inbound service
    earliest_inbound, latest_inbound = get_vessel_time_window(vessel_id)
    if earliest_inbound > latest_inbound:
        # Invalid time window; cannot assign this vessel
        return None, {}

    # Compute median inbound start time
    median_inbound_start = (earliest_inbound + latest_inbound) // 2

    # Compute tight schedule times
    tau_in = vessel_inbound_service_times[vessel_id]
    D = vessel_durations[vessel_id]
    tau_out = vessel_outbound_service_times[vessel_id]
    berthing_start = median_inbound_start + tau_in
    outbound_start = berthing_start + D

    # Check if schedule fits within time horizon (basic sanity check)
    if outbound_start + tau_out > time_periods:
        # Schedule overruns; try shifting earlier if possible, but for simplicity, skip this vessel
        return None, {}

    # Step 4: Compute current berth utilizations for sorting
    # Initialize utilization array
    berth_util = np.zeros(len(berth_capacities))
    for vid, assignment in current_solution.vessel_assignments.items():
        if assignment is not None:
            bid, _ = assignment
            berth_util[bid] += vessel_durations[vid]
    # Utilization as fraction of time periods
    current_utilizations = berth_util / time_periods if time_periods > 0 else np.zeros_like(berth_util)

    # Step 5: Get compatible berths and sort by increasing utilization (lowest first)
    compatible_berths = get_compatible_berths(vessel_id)
    # Filter by utilization threshold
    compatible_berths = [b for b in compatible_berths if current_utilizations[b] <= utilization_threshold]
    if not compatible_berths:
        return None, {}
    # Sort by increasing utilization
    compatible_berths.sort(key=lambda b: current_utilizations[b])
    # Limit tries
    compatible_berths = compatible_berths[:max_berth_tries]

    # Step 6: For each compatible berth in order, try to find feasible tugboat combinations and check availabilities
    for berth_id in compatible_berths:
        # Check berth availability for berthing period
        if not is_berth_available(berth_id, berthing_start, D, current_solution):
            continue

        # Find inbound tugboat combination at median_inbound_start
        inbound_result = find_tugboat_combination(vessel_id, median_inbound_start, 'inbound', current_solution)
        # Safely handle potential None return or invalid tuple from find_tugboat_combination
        if not isinstance(inbound_result, tuple) or len(inbound_result) != 2 or inbound_result[0] is None:
            continue
        inbound_tugboats = inbound_result[0]

        # Check availability for all inbound tugboats
        inbound_duration = tau_in
        inbound_available = all(
            is_tugboat_available(tug_id, median_inbound_start, inbound_duration, inbound_prep_time, current_solution)
            for tug_id, _ in inbound_tugboats
        )
        if not inbound_available:
            continue

        # Find outbound tugboat combination at outbound_start
        outbound_result = find_tugboat_combination(vessel_id, outbound_start, 'outbound', current_solution)
        # Safely handle potential None return or invalid tuple from find_tugboat_combination
        if not isinstance(outbound_result, tuple) or len(outbound_result) != 2 or outbound_result[0] is None:
            continue
        outbound_tugboats = outbound_result[0]

        # Check availability for all outbound tugboats
        outbound_duration = tau_out
        outbound_available = all(
            is_tugboat_available(tug_id, outbound_start, outbound_duration, outbound_prep_time, current_solution)
            for tug_id, _ in outbound_tugboats
        )
        if not outbound_available:
            continue

        # All checks passed: feasible assignment found
        # Create operator with berthing start, and tugboat lists (all start times are set)
        operator = CompleteVesselAssignmentOperator(
            vessel_id=vessel_id,
            berth_id=berth_id,
            start_time=berthing_start,  # Berthing start time
            inbound_tugboats=inbound_tugboats,  # List of (tug_id, start_time)
            outbound_tugboats=outbound_tugboats  # List of (tug_id, start_time)
        )
        # The operator ensures same start times for multi-tugboats as per its run logic
        return operator, {}

    # No feasible assignment found after trying berths
    return None, {}
------------------------------------------------------------------------------------

