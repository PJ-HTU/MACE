[
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "I am working on Hyper-heuristics for Combinatorial Operation (CO) problem.\n\nCurrently, I am working on jssp problem:\nJob Shop Scheduling Problem (JSSP) involves scheduling a series of jobs, each comprising a sequence of operations, across different machines to optimize production efficiency. In this variant, there is a one-to-one correspondence between machines and operation types, ensuring that each operation is carried out by a specific machine. Consequently, the number of operations (N) matches the number of machines, and each job includes these N operations precisely once.\n\nTo support different heuristic algorithms, I build the Solution and Operator framework.\nThe Solution is designed as:\nclass Solution:\n    \"\"\"The solution for the Job Shop Scheduling Problem (JSSP).\nA list of lists where each sublist represents the sequence of jobs scheduled on a machine, identified by its index in the outer list.\nEach job is represented by its integer identifier and is processed in the order specified within the sublist.\nEach sublist in 'job_sequences' corresponds to a machine's job processing sequence, with machines sorted by their identifier (index in the outer list).\nEach job within a sublist is sorted by its scheduled order of execution on that machine.\nJob matrix records the target operation(machine) sequence in job.\"\"\"\n    def __init__(self, job_sequences: list[list[int]], job_operation_sequence: list[list[int]], job_operation_index: list[int]):\n        self.job_sequences = job_sequences\n        self.job_operation_sequence = job_operation_sequence\n        self.job_operation_index = job_operation_index\nOperator servers as a mechanism to modify solution, which enables the application of heuristic algorithms.\u00a0\nTo support heuristic algorithm, we have build the following operators:\nclass AdvanceOperator(BaseOperator):\n    \"\"\"AdvanceOperator is responsible for advancing the next operation in the job's processing sequence.\nThis operator appends the next operation of the specified job to the processing queue of the machine that is scheduled to execute the operation.\nIt identifies the appropriate machine based on the job's current operation index and the job matrix within the provided Solution instance.\"\"\"\n    def __init__(self, job_id: int):\n        self.job_id = job_id\n    def run(self, solution: Solution) -> Solution:\n        new_job_sequences = [ops[:] for ops in solution.job_sequences]\n        machine_id = solution.job_operation_sequence[self.job_id][solution.job_operation_index[self.job_id]]\n        new_job_sequences[machine_id].append(self.job_id)\n        job_operation_index = solution.job_operation_index\n        job_operation_index[self.job_id] += 1\n        return Solution(new_job_sequences, solution.job_operation_sequence, job_operation_index)\n\nIn pursuit of augmenting our heuristic algorithmic suite, we require the following standardized heuristic function signature:\ndef heuristic(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[TargetOperatorType, dict]:\nThe inputs are:\nproblem_state (dict): The dictionary contains the problem state with:\n    - job_operation_sequence (numpy.ndarray): A list of jobs where each job is a list of operations in target sequence.\n    - job_operation_time (numpy.ndarray): The time cost for each operation in target job.\n    - job_num (int): The total number of jobs in the problem.\n    - machine_num (int): The total number of machines in the problem, also as operation num.\n    - current_solution (Solution): Current solution instance.\n    - current_makespan (int): The time cost for current operation jobs, also known as the current_makespan.\n    - get_problem_state (callable): def get_problem_state(solution: Solution) -> dict: The function to get the complete problem state for given solution without modifying it. Returns a dictionary containing 'total_scheduling_cost' and other state information.\n    - validation_solution (callable): def validation_solution(solution: Solution = None) -> bool: The function to check whether the solution is valid according to all mathematical model constraints. If solution is None, checks current solution. Returns True if valid, False otherwise.\n    - get_schedulable_jobs (callable): def get_schedulable_jobs(solution: Solution = None) -> list[int]: Get list of job IDs that have remaining operations to schedule. A job is schedulable if its current operation index is less than the total number of operations in its sequence. If solution is None, uses current solution. Returns list of integers representing schedulable job IDs.\n    - get_next_operation_time (callable): def get_next_operation_time(job_id: int, solution: Solution = None) -> int: Get the processing time of the next unscheduled operation for a specific job. Uses the job's current operation index to retrieve the corresponding processing time from the job_operation_time matrix. If solution is None, uses current solution. Returns integer representing the processing time of the next operation. Raises IndexError if the job has no remaining operations.\n    - get_total_remaining_time (callable): def get_total_remaining_time(job_id: int, solution: Solution = None) -> int: Calculate the sum of processing times for all remaining unscheduled operations of a specific job. Considers all operations from the current operation index to the end of the job's sequence. If solution is None, uses current solution. Returns integer representing the total remaining processing time for the job.\n    - num_jobs (int): The total number of jobs in the problem.\n    - num_machines (int): The total number of machines in the problem.\n    - avg_processing_time (float): The average processing time across all operations.\n    - coeff_variation_processing_times (float): The coefficient of variation of processing times.\n    - machine_load_variance (float): The variance of total processing times (loads) across machines.\n    - max_processing_time (float): The maximum processing time among all operations.\n    - scheduled_operations_ratio (float): Ratio of scheduled operations to total operations.\n    - current_makespan (float): Maximum completion time among scheduled operations.\n    - avg_machine_utilization (float): Average utilization across machines based on busy time over makespan.\n    - remaining_workload (float): Total processing time of all unscheduled operations.\n    - max_machine_queue_length (int): Maximum number of eligible unscheduled operations waiting for any machine.\n    - critical_path_length (float): Length (time) of the longest path to a scheduled operation.\n    - avg_operation_waiting_time (float): Average waiting time of scheduled operations beyond their job release.\nalgorithm_data(dict): Algorithm data contains the data that necessary for some algorithms.\nOther hyper-parameters in kwargs.\nThe outputs includes the operator that must be an instance of a predefined target operator type and updated algorithm dict, which contains new information for future work for both this or other algorithm.\n\nPlease consider is jssp a combinatorial operation problem and can be solved by heuristics?\nIf you think this problem is not a combinatorial operation problem or the solution, operator, data are incorrect, response ***is_cop:no*** to me, or response ***is_cop:yes***.\n\nThe response format is very important. For better communication, please respond to me in this format:\n***is_cop:yes/no***\nEnsure there is no other content inside the ***, and analysis outside *** is welcome.\nIf you have no information to provide, simply respond with ***None***."
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***is_cop:yes***\n\nYes, the Job Shop Scheduling Problem (JSSP) is a classic example of a combinatorial optimization (CO) problem. It involves discrete decisions\u2014such as sequencing operations on machines while respecting job precedence constraints and machine availability\u2014to minimize objectives like makespan, which makes it inherently combinatorial. JSSP is NP-hard, so exact methods are impractical for large instances, and it's routinely solved using heuristics (e.g., dispatching rules like SPT or LPT), metaheuristics (e.g., genetic algorithms, tabu search), and hyper-heuristics, which aligns well with your framework of selecting operators to build partial schedules incrementally.\n\nYour Solution and Operator design appears sound for a constructive heuristic approach: the job_sequences represent machine-specific permutations (building the schedule disjunctively), job_operation_sequence captures the conjunctive (job-internal) order, and job_operation_index tracks progress per job. The AdvanceOperator effectively implements a selection heuristic by advancing a specific job's next operation to its machine queue, enabling priority-based dispatching. This setup supports hyper-heuristics by allowing the selection of which job to advance next based on the provided problem_state features (e.g., using remaining workload or machine loads for informed decisions). The heuristic signature you defined is appropriate for outputting a TargetOperatorType instance (like AdvanceOperator(job_id)) and updating algorithm_data for iterative improvement. If you're implementing specific rules (e.g., Apparent Tardiness Cost or Critical Path), ensure validation_solution checks for feasibility like no machine overlaps. Overall, this is a solid foundation for hyper-heuristic application to JSSP."
            }
        ]
    },
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "I need your help to design different 5 basic heuristics for the jssp problem.\n\n## Heuristic Requirements:\n1. **Constructive Nature**: Each heuristic must be constructive (or constructive followed by improvement), and build solutions step-by-step from scratch.\n\n2. **Diversity**: The 5 heuristics should represent different strategies to ensure diversity in solution approaches.\n\nThe problem will work on following data.\nPlease try to understand the data and generate based on them, especially setting the default value for hyper-parameters:\nAll data is possible\n\nThe response format is very important. For better communication, please respond to me in this format:\n***heuristic:\nheuristic_name: only text description\nheuristic_name: only text description\n....\n***\nEnsure there is no other content (including blank lines) inside the ***, and analysis outside *** is welcome.\nIf you have no information to provide, simply respond with ***None***."
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***heuristic:\nRandom Selection: Randomly selects one job from the list of schedulable jobs returned by get_schedulable_jobs() to advance its next operation. No hyperparameters required.\nShortest Processing Time (SPT): Selects the schedulable job with the smallest processing time for its next operation, obtained via get_next_operation_time(job_id). If ties, pick the lowest job ID. No hyperparameters.\nLongest Processing Time (LPT): Selects the schedulable job with the largest processing time for its next operation, using get_next_operation_time(job_id). If ties, pick the lowest job ID. No hyperparameters.\nLeast Remaining Workload (LWR): Selects the schedulable job with the smallest total remaining processing time, computed by get_total_remaining_time(job_id). If ties, pick the lowest job ID. No hyperparameters.\nMost Remaining Workload (MWR): Selects the schedulable job with the largest total remaining processing time, using get_total_remaining_time(job_id). If ties, pick the lowest job ID. No hyperparameters.\n***\n\nThese heuristics are all purely constructive, iteratively selecting a job to advance via AdvanceOperator until all operations are scheduled (i.e., no schedulable jobs left). They leverage the provided callables in problem_state for efficiency without needing to recompute full states each time. Diversity comes from varying priorities: randomness for exploration, SPT/LPT for operation duration focus, and LWR/MWR for job-level workload balance. Each returns the operator instance and an unchanged algorithm_data dict (or minimally updated if tracking selections). For implementation, inside the function: fetch schedulable_jobs = problem_state['get_schedulable_jobs'](), then evaluate candidates based on the rule, select job_id, create AdvanceOperator(job_id), and return (operator, algorithm_data). If no schedulable jobs, you might want to handle termination, but assuming the caller manages the loop. These are basic dispatching rules adapted to your incremental operator framework, proven effective in JSSP literature for generating diverse initial solutions in hyper-heuristics."
            }
        ]
    },
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "Based on previous discuss, we get the heuristic Most Remaining Workload (MWR):\n Selects the schedulable job with the largest total remaining processing time, using get_total_remaining_time(job_id). If ties, pick the lowest job ID. No hyperparameters..\n\nNow please implement it in python function most_remaining_workload_mwr_6a42.\n\nTo implement this heuristic function in python, please note:\n1. We can assume that Solution and all Operators are imported.\n2. The operator type must be defined previously, do not create a new one in your code.\n3. Never modify the data in problem_state.\n4. All hyper parameters in kwargs should be set a default value.\n5. Any reasonable partial solution may be used as input, such as an empty solution.\n6. Comments in the code are very important. They must clearly explain which hyper-parameters are required by the algorithm (i.e., the parameters in **kwargs), how the algorithm proceeds, and under what circumstances it will not return any operator or will return an empty operator. We hope that people can understand the principles and workflow of the algorithm clearly just by reading the comments, without needing to look at the code.\n7. The name of function must be most_remaining_workload_mwr_6a42. The TargetOperatorType should be replaced by real returned operator type.\n8. No any omissions or placeholders, I'm just going to use the code.\n9. For the algorithm to update the algorithm_data, do not modify directly \"algorithm_data[\"abc\"] = 123\", we should return operator, {\"abc\": 123}.For algorithm that do not update them, just return operator, {}\n10. For the circumstances that algorithm return empty operator, please return None, {}.\n11. Do not forget to check whether the content is empty when calculating the min/max/average/std/..., such as when using min([distance[node][other] for other in nodes if other != node]).\n12. Make the result must be valid.\n13. Do not forget the input problem_state:\nproblem_state (dict): The dictionary contains the problem state with:\n    - job_operation_sequence (numpy.ndarray): A list of jobs where each job is a list of operations in target sequence.\n    - job_operation_time (numpy.ndarray): The time cost for each operation in target job.\n    - job_num (int): The total number of jobs in the problem.\n    - machine_num (int): The total number of machines in the problem, also as operation num.\n    - current_solution (Solution): Current solution instance.\n    - current_makespan (int): The time cost for current operation jobs, also known as the current_makespan.\n    - get_problem_state (callable): def get_problem_state(solution: Solution) -> dict: The function to get the complete problem state for given solution without modifying it. Returns a dictionary containing 'total_scheduling_cost' and other state information.\n    - validation_solution (callable): def validation_solution(solution: Solution = None) -> bool: The function to check whether the solution is valid according to all mathematical model constraints. If solution is None, checks current solution. Returns True if valid, False otherwise.\n    - get_schedulable_jobs (callable): def get_schedulable_jobs(solution: Solution = None) -> list[int]: Get list of job IDs that have remaining operations to schedule. A job is schedulable if its current operation index is less than the total number of operations in its sequence. If solution is None, uses current solution. Returns list of integers representing schedulable job IDs.\n    - get_next_operation_time (callable): def get_next_operation_time(job_id: int, solution: Solution = None) -> int: Get the processing time of the next unscheduled operation for a specific job. Uses the job's current operation index to retrieve the corresponding processing time from the job_operation_time matrix. If solution is None, uses current solution. Returns integer representing the processing time of the next operation. Raises IndexError if the job has no remaining operations.\n    - get_total_remaining_time (callable): def get_total_remaining_time(job_id: int, solution: Solution = None) -> int: Calculate the sum of processing times for all remaining unscheduled operations of a specific job. Considers all operations from the current operation index to the end of the job's sequence. If solution is None, uses current solution. Returns integer representing the total remaining processing time for the job.\n    - num_jobs (int): The total number of jobs in the problem.\n    - num_machines (int): The total number of machines in the problem.\n    - avg_processing_time (float): The average processing time across all operations.\n    - coeff_variation_processing_times (float): The coefficient of variation of processing times.\n    - machine_load_variance (float): The variance of total processing times (loads) across machines.\n    - max_processing_time (float): The maximum processing time among all operations.\n    - scheduled_operations_ratio (float): Ratio of scheduled operations to total operations.\n    - current_makespan (float): Maximum completion time among scheduled operations.\n    - avg_machine_utilization (float): Average utilization across machines based on busy time over makespan.\n    - remaining_workload (float): Total processing time of all unscheduled operations.\n    - max_machine_queue_length (int): Maximum number of eligible unscheduled operations waiting for any machine.\n    - critical_path_length (float): Length (time) of the longest path to a scheduled operation.\n    - avg_operation_waiting_time (float): Average waiting time of scheduled operations beyond their job release.\n\nFor jssp problem, take about following:\n1. Make the result must be valid, such as: no re-finished operations.\n2. As we consider that operations within a job need to be executed in sequence, to avoid unnecessary complications, we have provided only the AdvanceOperator during the construction phase, which simply requires specifying the job to advance it by one step.\n\nThe problem will work on following data.\nPlease try to understand the data and generate based on them, especially setting the default value for hyper-parameters:\nAll data is possible\n\nThe response format is very important. For better communication, please respond to me in this format:\n***python_code:\nfrom src.problems.jssp.components import *\nimport other_library (if necessary)\ndef most_remaining_workload_mwr_6a42(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[TargetOperatorType, dict]:\n    \"\"\" Description for this heuristic algorithm.\n\n    Args:\n        problem_state (dict): The dictionary contains the problem state.. In this algorithm, the following items are necessary:\n            - necessary_key (value type): description\n            - necessary_key (value type): description\n            ...\n        (Optional and can be omitted if no algorithm data) algorithm_data (dict): The algorithm dictionary for current algorithm only. In this algorithm, the following items are necessary:\n            - necessary_key (value type): description\n            - necessary_key (value type): description\n            ...\n        (Optional and can be omitted if no hyper parameters data) introduction for hyper parameters in kwargs if used.\n\n    Returns:\n        Description of this operator.\n        Description of updated algorithm data.\n\n        ...\n    \"\"\"\nEnsure there is no other content inside the ***, ,and analysis outside *** is welcome.\nIf you have no information to provide, simply respond with ***None***.\n"
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***python_code:\nfrom src.problems.jssp.components import *\ndef most_remaining_workload_mwr_6a42(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[AdvanceOperator, dict]:\n    \"\"\"\n    Most Remaining Workload (MWR) heuristic for JSSP. This constructive heuristic selects the schedulable job with the largest total remaining processing time to advance its next operation. It prioritizes jobs with the most unfinished work to balance the schedule by handling heavy workloads early. Ties are broken by selecting the job with the lowest job ID to ensure determinism.\n\n    Hyperparameters:\n        This algorithm has no hyperparameters, so kwargs are ignored. Default values are implicitly set by not using any.\n\n    Algorithm workflow:\n        1. Retrieve the list of currently schedulable jobs using the get_schedulable_jobs callable from problem_state. A schedulable job is one with remaining operations (job_operation_index[job_id] < len(job_operation_sequence[job_id])).\n        2. If no schedulable jobs are available (i.e., all operations are scheduled), return None, {} to indicate termination of construction; no further operators can be applied.\n        3. For each schedulable job, compute the total remaining processing time using get_total_remaining_time(job_id), which sums processing times from the current operation index to the end of the job's sequence.\n        4. Identify the job with the maximum remaining time value. If multiple jobs tie for the maximum, select the one with the smallest job ID.\n        5. Create an AdvanceOperator instance for the selected job_id, which will append the job to the sequence of its next machine and increment the job's operation index.\n        6. The returned operator ensures validity: it advances only the next operation in sequence per job, prevents re-finishing operations (as it uses current job_operation_index), and respects machine-specific scheduling without overlaps (validation handled externally via validation_solution).\n        7. No updates to algorithm_data are needed for this basic heuristic, so return an empty dict. This heuristic does not rely on or modify any persistent state beyond the solution updated by the operator.\n\n    Necessary items from problem_state:\n        - get_schedulable_jobs (callable): Returns list[int] of job IDs with remaining operations. Uses current_solution if solution=None.\n        - get_total_remaining_time (callable): Returns int, the sum of processing times for remaining operations of a job. Uses current_solution if solution=None. Raises IndexError if no remaining operations, but we check schedulable first.\n        - current_solution (Solution): Implicitly used by the callables to access job_operation_index and job_operation_sequence for determining schedulable status and remaining times.\n\n    algorithm_data (dict): Not used or required by this algorithm; can be empty or arbitrary.\n\n    Returns:\n        AdvanceOperator: Instance for the selected job_id to advance its next operation, or None if no schedulable jobs.\n        dict: Empty dict {} as no algorithm data is updated.\n    \"\"\"\n    # Step 1: Get schedulable jobs\n    schedulable_jobs = problem_state['get_schedulable_jobs']()\n    \n    # Step 2: Check if any schedulable jobs exist\n    if not schedulable_jobs:\n        # No more operations to schedule; construction complete\n        return None, {}\n    \n    # Step 3 & 4: Find job with max remaining time, tie-break by min job ID\n    max_remaining_time = -1\n    selected_job_id = float('inf')  # Initialize to a large value for min tie-break\n    \n    for job_id in schedulable_jobs:\n        remaining_time = problem_state['get_total_remaining_time'](job_id)\n        if remaining_time > max_remaining_time or (remaining_time == max_remaining_time and job_id < selected_job_id):\n            max_remaining_time = remaining_time\n            selected_job_id = job_id\n    \n    # Step 5: Create operator for selected job\n    operator = AdvanceOperator(selected_job_id)\n    \n    # Step 6 & 7: No algorithm data updates\n    return operator, {}\n***\n\nThis implementation strictly follows the MWR rule, ensuring the solution remains valid by only advancing eligible jobs via the provided operator. It uses the callables directly to avoid modifying or duplicating computations from problem_state. The docstring provides a self-contained explanation, and the code handles the empty case explicitly. Since there are no hyperparameters, kwargs are safely ignored. For ties, it correctly picks the lowest job ID by comparing during iteration. This should integrate seamlessly into your hyper-heuristic loop, where the operator is applied to update the current_solution iteratively until None is returned."
            }
        ]
    },
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "To verify whether the code is correct, we conducted a smoke test.\nThis is the test data:\nnum_jobs:10\nnum_machines:10\navg_processing_time:77.73\ncoeff_variation_processing_times:0.18\nmachine_load_variance:1408.01\nmax_processing_time:99\n\nWe run the following operations:\nNone\n\nThe current solution are\nmachine_0: \nmachine_1: \nmachine_2: \nmachine_3: \nmachine_4: \nmachine_5: \nmachine_6: \nmachine_7: \nmachine_8: \nmachine_9: \n\nwith related problem state\nscheduled_operations_ratio:0.0\ncurrent_makespan:0.0\navg_machine_utilization:0.0\nremaining_workload:7773.0\nmax_machine_queue_length:2\ncritical_path_length:0.0\navg_operation_waiting_time:0.0\n\nNow we run most_remaining_workload_mwr_6a42 once and think about what the expected output is.\n\nThe response format is very important. For better communication, please respond to me in this format:\n***expected_result:xxx***\nEnsure there is no other content inside the ***, and analysis outside *** is welcome.\nIf you have no information to provide, simply respond with ***None***."
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***expected_result:(AdvanceOperator(job_id), {})***\n\nAt the initial state with an empty solution (no operations scheduled, all jobs fully remaining), the function will return an AdvanceOperator for the job_id that has the maximum total processing time across all its operations (since get_total_remaining_time(job_id) equals the full job duration for each), with ties broken by the lowest job_id. The exact job_id depends on the unspecified job_operation_time matrix, but given the aggregate stats (e.g., remaining_workload=7773.0 implying total operations time), it will select one from 0-9 without error, ensuring validity by advancing only an eligible job's first operation. The second return value is always {} for this heuristic. If the test reveals a specific job_id (e.g., based on your instance data), it would match the one with max sum(job_operation_time[job_id]), but the structure confirms the code's correctness for non-empty schedulable_jobs. Note: max_machine_queue_length:2 seems anomalous for a truly empty start (should be 0), possibly indicating pre-queued or miscomputed state, but doesn't affect the heuristic logic."
            }
        ]
    },
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "In fact we run the most_remaining_workload_mwr_6a42 once, and now we got the output operation from most_remaining_workload_mwr_6a42:\nAdvanceOperator(job_id=0)\n\nThe updated solution are\nmachine_0: \nmachine_1: \nmachine_2: \nmachine_3: \nmachine_4: 0\nmachine_5: \nmachine_6: \nmachine_7: \nmachine_8: \nmachine_9: \n\nwith related problem state\nscheduled_operations_ratio:0.01\ncurrent_makespan:88\navg_machine_utilization:0.1\nremaining_workload:7685.0\nmax_machine_queue_length:2\ncritical_path_length:88\navg_operation_waiting_time:0.0\n\nPlease compare with your expected result: (AdvanceOperator(job_id), {})\n1. If the result is aligned with your target output, respond to me ***python_code:correct*** and we will save the code and finish this generation.\n2. If the result is not aligned with your target output and you can not generate correct one, respond to me ***python_code:None*** and we will stop this generation.\n3. If the result is not aligned with your target output and you can fix up this issues, please respond to me in this format:\n***python_code:\nfrom src.problems.jssp.components import *\nimport other_library (if necessary)\ndef most_remaining_workload_mwr_6a42(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[TargetOperatorType, dict]:\n    \"\"\" Description for this heuristic algorithm.\n\n    Args:\n        problem_state (dict): The dictionary contains the problem state.. In this algorithm, the following items are necessary:\n            - necessary_key (value type): description\n            - necessary_key (value type): description\n            ...\n        (Optional and can be omitted if no algorithm data) algorithm_data (dict): The algorithm dictionary for current algorithm only. In this algorithm, the following items are necessary:\n            - necessary_key (value type): description\n            - necessary_key (value type): description\n            ...\n        (Optional and can be omitted if no hyper parameters data) introduction for hyper parameters in kwargs if used.\n\n    Returns:\n        Description of this operator.\n        Description of updated algorithm data.\n\n        ...\n    \"\"\"\nEnsure there is no other content inside the ***, and analysis outside *** is welcome.\nIf you have no information to provide, simply respond with ***None***.\n"
            }
        ]
    },
    {
        "role": "assistant",
        "content": [
            {
                "type": "text",
                "text": "***python_code:correct***\n\nThe output AdvanceOperator(job_id=0) aligns with the expected behavior: at the start, all jobs are schedulable with full remaining times, so it selects the one with the max total processing time, tie-broken to the lowest ID (job 0), and returns {} for algorithm_data. The updated solution correctly appends job 0 to machine_4 (indicating the first operation of job 0 is on machine 4), and state updates (makespan=88 matching the processing time, ratio=0.01 for 1/100 ops, workload drop by 88) confirm validity without re-finishing or overlaps. No fixes needed."
            }
        ]
    },
    {
        "role": "user",
        "content": [
            {
                "type": "text",
                "text": "To ensure the stable of heuristics, we adjust the code to:\nfrom src.problems.jssp.components import *\ndef most_remaining_workload_mwr_6a42(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[AdvanceOperator, dict]:\n    \"\"\"\n    Most Remaining Workload (MWR) heuristic for JSSP. This constructive heuristic selects the schedulable job with the largest total remaining processing time to advance its next operation. It prioritizes jobs with the most unfinished work to balance the schedule by handling heavy workloads early. Ties are broken by selecting the job with the lowest job ID to ensure determinism.\n\n    Hyperparameters:\n        This algorithm has no hyperparameters, so kwargs are ignored. Default values are implicitly set by not using any.\n\n    Algorithm workflow:\n        1. Retrieve the list of currently schedulable jobs using the get_schedulable_jobs callable from problem_state. A schedulable job is one with remaining operations (job_operation_index[job_id] < len(job_operation_sequence[job_id])).\n        2. If no schedulable jobs are available (i.e., all operations are scheduled), return None, {} to indicate termination of construction; no further operators can be applied.\n        3. For each schedulable job, compute the total remaining processing time using get_total_remaining_time(job_id), which sums processing times from the current operation index to the end of the job's sequence.\n        4. Identify the job with the maximum remaining time value. If multiple jobs tie for the maximum, select the one with the smallest job ID.\n        5. Create an AdvanceOperator instance for the selected job_id, which will append the job to the sequence of its next machine and increment the job's operation index.\n        6. The returned operator ensures validity: it advances only the next operation in sequence per job, prevents re-finishing operations (as it uses current job_operation_index), and respects machine-specific scheduling without overlaps (validation handled externally via validation_solution).\n        7. No updates to algorithm_data are needed for this basic heuristic, so return an empty dict. This heuristic does not rely on or modify any persistent state beyond the solution updated by the operator.\n\n    Necessary items from problem_state:\n        - get_schedulable_jobs (callable): Returns list[int] of job IDs with remaining operations. Uses current_solution if solution=None.\n        - get_total_remaining_time (callable): Returns int, the sum of processing times for remaining operations of a job. Uses current_solution if solution=None. Raises IndexError if no remaining operations, but we check schedulable first.\n        - current_solution (Solution): Implicitly used by the callables to access job_operation_index and job_operation_sequence for determining schedulable status and remaining times.\n\n    algorithm_data (dict): Not used or required by this algorithm; can be empty or arbitrary.\n\n    Returns:\n        AdvanceOperator: Instance for the selected job_id to advance its next operation, or None if no schedulable jobs.\n        dict: Empty dict {} as no algorithm data is updated.\n    \"\"\"\n    # Step 1: Get schedulable jobs\n    schedulable_jobs = problem_state['get_schedulable_jobs']()\n    \n    # Step 2: Check if any schedulable jobs exist\n    if not schedulable_jobs:\n        # No more operations to schedule; construction complete\n        return None, {}\n    \n    # Step 3 & 4: Find job with max remaining time, tie-break by min job ID\n    max_remaining_time = -1\n    selected_job_id = float('inf')  # Initialize to a large value for min tie-break\n    \n    for job_id in schedulable_jobs:\n        remaining_time = problem_state['get_total_remaining_time'](job_id)\n        if remaining_time > max_remaining_time or (remaining_time == max_remaining_time and job_id < selected_job_id):\n            max_remaining_time = remaining_time\n            selected_job_id = job_id\n    \n    # Step 5: Create operator for selected job\n    operator = AdvanceOperator(selected_job_id)\n    \n    # Step 6 & 7: No algorithm data updates\n    return operator, {}"
            }
        ]
    }
]