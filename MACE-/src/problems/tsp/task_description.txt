I am working on Hyper-heuristics for Combinatorial Operation (CO) problem.

Currently, I am working on tsp problem:
Traveling Salesman Problem (TSP) is the challenge of finding the shortest possible route that visits a given list of cities exactly once and returns to the origin city, based on the distances between each pair of cities.

To support different heuristic algorithms, I build the Solution and Operator framework.
The Solution is designed as:
class Solution:
    """The solution of TSP.
A list of integers where each integer represents a node (city) in the TSP tour.
The order of the nodes in the list defines the order in which the cities are visited in the tour."""
    def __init__(self, tour: list[int]):
        self.tour = tour
Operator servers as a mechanism to modify solution, which enables the application of heuristic algorithms.Â 
To support heuristic algorithm, we have build the following operators:
class AppendOperator(BaseOperator):
    """Append the node at the end of the solution."""
    def __init__(self, node: int):
        self.node = node
    def run(self, solution: Solution) -> Solution:
        new_tour = solution.tour + [self.node]
        return Solution(new_tour)
class InsertOperator(BaseOperator):
    """Insert the node into the solution at the target position."""
    def __init__(self, node: int, position: int):
        self.node = node
        self.position = position
    def run(self, solution: Solution) -> Solution:
        new_tour = solution.tour[:self.position] + [self.node] + solution.tour[self.position:]
        return Solution(new_tour)

In pursuit of augmenting our heuristic algorithmic suite, we require the following standardized heuristic function signature:
def heuristic(problem_state: dict, algorithm_data: dict, **kwargs) -> tuple[TargetOperatorType, dict]:
The inputs are:
problem_state (dict): A dictionary containing the problem state information, organized into five categories of keys:
1. Input Data:
    - node_num (int): The total number of nodes in the problem.
    - distance_matrix (numpy.ndarray): A 2D array representing the distances between nodes.
2. Current Solution:
    - current_solution (Solution): Current solution instance.
    - current_cost (int): The total cost of the current solution.
3. Helper Functions (these Functions may help you to generation the following heuristic):
    - get_problem_state (callable): def get_problem_state(solution: Solution) -> dict: The function to get the complete problem state for given solution without modifying it. Returns a dictionary containing 'total_scheduling_cost' and other state information.
    - validation_solution (callable): def validation_solution(solution: Solution = None) -> bool: The function to check whether the solution is valid according to all mathematical model constraints. If solution is None, checks current solution. Returns True if valid, False otherwise.
    - get_unvisited_nodes (callable): def get_unvisited_nodes(solution: Solution = None) -> list[int]: Get list of node IDs that have not been visited in the tour. Returns all nodes from 0 to node_num-1 that are not present in the current tour. If solution is None, uses current solution. Returns list of integers representing unvisited node IDs.
    - get_insertion_cost (callable): def get_insertion_cost(node: int, position: int, solution: Solution = None) -> float: Calculate the cost increase when inserting a node at a specific position in the tour. Handles three cases: insertion at beginning (position=0), at end (position=len(tour)), or in middle (between position-1 and position). For middle insertion, returns new_edges_cost minus removed_edge_cost. For empty tour, returns 0.0. If solution is None, uses current solution. Returns float representing the tour length increase caused by the insertion.
    - get_min_distance_to_tour (callable): def get_min_distance_to_tour(node: int, solution: Solution = None) -> float: Calculate the minimum distance from a given node to any node currently in the tour. Useful for nearest/farthest insertion heuristics to find the closest tour node to an unvisited node. If solution is None, uses current solution. Returns float representing the minimum distance; returns inf if the tour is empty.
    - find_closest_pair (callable): def find_closest_pair(nodes: list = None) -> tuple[int, int, float]: Find the pair of nodes with the smallest distance between them from a given node list. If nodes is None, searches among all nodes (0 to node_num-1). Returns tuple of (node1, node2, distance) where node1 and node2 are the indices of the closest pair and distance is their distance value.
4. Instance Statistics (these Instance Statistics may help you to generation the following heuristic):
    - num_cities (int): The total number of cities/nodes in the instance.
    - min_distance (float): The minimum pairwise distance between distinct nodes.
    - max_distance (float): The maximum pairwise distance between distinct nodes.
    - avg_distance (float): The average pairwise distance between distinct nodes.
    - std_distance (float): The standard deviation of pairwise distances between distinct nodes.
    - aspect_ratio (float or None): The aspect ratio of the city positions if coordinates were available; set to None if not computable from distance matrix alone.
5. Current Solution Statistics (these Solution Statistics may help you to generation the following heuristic):
    - num_visited (int): The number of distinct cities visited in the partial tour.
    - current_tour_length (float): The total length of the partial tour (sum of edge distances).
    - num_unvisited (int): The number of cities remaining unvisited.
    - avg_visited_edge_length (float): The average length of edges in the partial tour.
    - min_unvisited_to_visited (float): The minimum distance from any unvisited city to the tour endpoints.
    - estimated_lower_bound (float): An approximation of the lower bound for the total tour length, including partial tour, MST on unvisited, and connection estimates.
    - progress_ratio (float): The ratio of visited cities to total cities (0 to 1).
algorithm_data(dict): Algorithm data contains the data that necessary for some algorithms.
Other hyper-parameters in kwargs.
The outputs includes the operator that must be an instance of a predefined target operator type and updated algorithm dict, which contains new information for future work for both this or other algorithm.